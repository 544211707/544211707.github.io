<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>gitpost</title>
    <link href="/2021/09/07/gitpost/"/>
    <url>/2021/09/07/gitpost/</url>
    
    <content type="html"><![CDATA[<p>首先你需要一个github账号，所有还没有的话先去注册吧！</p><p><a href="https://github.com/">https://github.com/</a></p><p>我们使用git需要先安装git工具，这里给出下载地址，下载后一路直接安装即可：</p><p><a href="https://git-for-windows.github.io/">https://git-for-windows.github.io/</a></p><p>1.进入Github首页，点击New repository新建一个项目</p><p><img src="https://images2015.cnblogs.com/blog/913913/201608/913913-20160823164154526-418441991.png" alt="img"></p><p> 2.填写相应信息后点击create即可 </p><p>Repository name: 仓库名称</p><p>Description(可选): 仓库描述介绍</p><p>Public, Private : 仓库权限（公开共享，私有或指定合作者）</p><p>Initialize this repository with a README: 添加一个README.md</p><p>gitignore: 不需要进行版本管理的仓库类型，对应生成文件.gitignore</p><p>license: 证书类型，对应生成文件LICENSE</p><p><img src="https://images2015.cnblogs.com/blog/913913/201608/913913-20160823165025370-49444506.png" alt="img"></p><p><img src="https://images2015.cnblogs.com/blog/913913/201608/913913-20160823165107308-439926006.png" alt="img"></p><p>4.点击Clone or dowload会出现一个地址，copy这个地址备用。</p><p><img src="https://images2015.cnblogs.com/blog/913913/201608/913913-20160823165450636-1167722003.png" alt="img"></p><p>5.接下来就到本地操作了，首先右键你的项目，如果你之前安装git成功的话，右键会出现两个新选项，分别为Git Gui Here,Git Bash Here,这里我们选择Git Bash Here，进入如下界面，Test_Bluetooth即为我的项目名。</p><p><img src="https://images2015.cnblogs.com/blog/913913/201608/913913-20160823171048308-194895299.png" alt="img"></p><p>6.接下来输入如下代码（关键步骤），把github上面的仓库克隆到本地</p><p>git clone <a href="https://github.com/CKTim/BlueTooth.git%EF%BC%88https://github.com/CKTim/BlueTooth.git%E6%9B%BF%E6%8D%A2%E6%88%90%E4%BD%A0%E4%B9%8B%E5%89%8D%E5%A4%8D%E5%88%B6%E7%9A%84%E5%9C%B0%E5%9D%80%EF%BC%89">https://github.com/CKTim/BlueTooth.git（https://github.com/CKTim/BlueTooth.git替换成你之前复制的地址）</a></p><p><img src="https://images2015.cnblogs.com/blog/913913/201608/913913-20160823171143980-741152042.png" alt="img"></p><p> 7.这个步骤以后你的本地项目文件夹下面就会多出个文件夹，该文件夹名即为你github上面的项目名，如图我多出了个Test文件夹，我们把本地项目文件夹下的所有文件（除了新多出的那个文件夹不用），其余都复制到那个新多出的文件夹下，</p><p><img src="https://images2015.cnblogs.com/blog/913913/201608/913913-20160823171209730-2089496483.png" alt="img"></p><p>8.接着继续输入命令 cd Test，进入Test文件夹</p><p><img src="https://images2015.cnblogs.com/blog/913913/201608/913913-20160823171454261-10363777.png" alt="img"></p><p>9.接下来依次输入以下代码即可完成其他剩余操作：</p><p>git add .     （注：别忘记后面的.，此操作是把Test文件夹下面的文件都添加进来）</p><p>git commit  -m  “提交信息”  （注：“提交信息”里面换成你需要，如“first commit”）</p><p>git push -u origin master  （注：此操作目的是把本地仓库push到github上面，此步骤需要你输入帐号和密码）</p><p> <img src="https://images2015.cnblogs.com/blog/913913/201608/913913-20160823171557823-3863512.png" alt="img"></p><p><img src="https://images2015.cnblogs.com/blog/913913/201608/913913-20160823171651808-1225335136.png" alt="img"></p><p><img src="https://images2015.cnblogs.com/blog/913913/201608/913913-20160823171818933-1506815566.png" alt="img"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>JS高级04_进程与线程、浏览器模块、定时器、时间循环机制</title>
    <link href="/2021/08/29/JSadvance04/"/>
    <url>/2021/08/29/JSadvance04/</url>
    
    <content type="html"><![CDATA[<h1 id="1-线程与进程"><a href="#1-线程与进程" class="headerlink" title="1. 线程与进程"></a>1. 线程与进程</h1><h2 id="1-进程"><a href="#1-进程" class="headerlink" title="1). 进程:"></a>1). 进程:</h2><p>（即打开一个程序）</p><p>程序的一次执行, 它占有一片独有的内存空间<br>可以通过windows任务管理器查看进程</p><h2 id="2-线程"><a href="#2-线程" class="headerlink" title="2). 线程:"></a>2). 线程:</h2><p>（即比如 一个程序里有负责渲染的、网络的 等等线程）</p><p>是进程内的一个独立执行单元<br>是程序执行的一个完整流程<br>是CPU的最小调度单元</p><p>进程 &gt; 线程</p><h2 id="3-关系"><a href="#3-关系" class="headerlink" title="3). 关系"></a>3). 关系</h2><p>一个进程中一般至少有一个运行的线程:主线程<br>一个进程中也可以同时运行多个线程，我们会说程序是多线程运行的<br>一个进程内的数据可以供其中的多个线程直接共享<br>多个进程之间的数据是不能直接共享的</p><h1 id="2-浏览器内核模块组成"><a href="#2-浏览器内核模块组成" class="headerlink" title="2. 浏览器内核模块组成"></a>2. 浏览器内核模块组成</h1><p>内核由很多模块组成：</p><h2 id="1-主线程"><a href="#1-主线程" class="headerlink" title="1). 主线程"></a>1). 主线程</h2><p>js引擎模块 : 负责js程序的编译与运行<br>html,css文档解析模块 : 负责页面文本的解析<br>DOM/CSS模块 : 负责dom/css在内存中的相关处理<br>布局和渲染模块 : 负责页面的布局和效果的绘制(内存中的对象)</p><h2 id="2-分线程"><a href="#2-分线程" class="headerlink" title="2). 分线程"></a>2). 分线程</h2><p>定时器模块 : 负责定时器的管理<br>事件响应模块 : 负责事件的管理<br>网络请求模块 : 负责Ajax请求</p><h2 id="3-js线程"><a href="#3-js线程" class="headerlink" title="3). js线程"></a>3). js线程</h2><p>js是单线程（所以可以叫主线程）执行的(回调函数也是在主线程)</p><p>单线程特点:<br>1．代码从上至下依次执行<br>2．同步&amp;异步同步任务可能会导致阻塞<br>3．同步代表:alert( ) console.log() 赋值语句<br>4.异步代表:定时器，事件的回调</p><p><del>H5提出了实现多线程的方案: Web Workers   —&gt;Worker</del><br><del>只能是主线程更新界面</del></p><h1 id="3-定时器问题"><a href="#3-定时器问题" class="headerlink" title="3. 定时器问题:"></a>3. 定时器问题:</h1><p>定时器并不 真正按照规定时间执行<br>如果在主线程执行了一个长时间的操作, 可能导致延时才处理，所以不要在定时器后放很耗资源的代码段</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> oldTime = <span class="hljs-built_in">Date</span>.now();<br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;花费的时间: &#x27;</span>, <span class="hljs-built_in">Date</span>.now() - oldTime);<br>&#125;,<span class="hljs-number">2000</span>)<br><span class="hljs-comment">//千万要注意不要在定时器的后边放置任务量特别大的代码段,不然花费的时间会很长很长</span><br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000000</span>; i++) i<br><span class="hljs-built_in">console</span>.log(i);<br><br></code></pre></td></tr></table></figure><h1 id="4-事件循环机制"><a href="#4-事件循环机制" class="headerlink" title="4. 事件循环机制"></a>4. 事件循环机制</h1><p>事件循环机制：</p><p>1.js是单线程的<br>2.所有的js代码都会在主线程执行<br>3.同步任务加载即执行<br>4.异步任务不会立即执行，而是会交给对应的管理模块<br>5.管理模块一直在监视异步任务是否满足条件，如果满足条件会将对应的回调放入callback queue(回调队列)<br>6.主线程上的同步任务执行完以后 会通过event loop(事件轮询机制)询问callback queue：</p><ul><li>查看事件是否有可执行的回调函数，如果有将回调钩到主线程上执行</li><li>如果没有待会再来问 </li></ul><p><img src="/2021/08/29/JSadvance04/img1.png" alt="image-20210823173030400"></p><h2 id="1-代码分类"><a href="#1-代码分类" class="headerlink" title="1). 代码分类"></a>1). 代码分类</h2><pre><code>初始化执行代码: 包含绑定dom事件监听, 设置定时器, 发送ajax请求的代码回调执行代码: 处理回调逻辑</code></pre><h2 id="2-js引擎执行代码的基本流程"><a href="#2-js引擎执行代码的基本流程" class="headerlink" title="2). js引擎执行代码的基本流程:"></a>2). js引擎执行代码的基本流程:</h2><pre><code>初始化代码===&gt;回调代码</code></pre><h2 id="3-模型的2个重要组成部分"><a href="#3-模型的2个重要组成部分" class="headerlink" title="3). 模型的2个重要组成部分:"></a>3). 模型的2个重要组成部分:</h2><pre><code>事件管理模块回调队列</code></pre><h2 id="4-模型的运转流程"><a href="#4-模型的运转流程" class="headerlink" title="4). 模型的运转流程"></a>4). 模型的运转流程</h2><pre><code>执行初始化代码, 将事件回调函数交给对应模块管理当事件发生时, 管理模块会将回调函数及其数据添加到回调列队中只有当初始化代码执行完后(可能要一定时间), 才会遍历读取回调队列中的回调函数执行</code></pre>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>JS高级03_对象的创建、继承、GC</title>
    <link href="/2021/08/29/JSadvance03/"/>
    <url>/2021/08/29/JSadvance03/</url>
    
    <content type="html"><![CDATA[<h1 id="1-对象的创建（设计）模式"><a href="#1-对象的创建（设计）模式" class="headerlink" title="1. 对象的创建（设计）模式"></a>1. 对象的创建（设计）模式</h1><h2 id="1-Object构造函数模式"><a href="#1-Object构造函数模式" class="headerlink" title="1). Object构造函数模式"></a>1). Object构造函数模式</h2><p>缺点：语句多，流程繁杂</p><pre><code>var obj = &#123;&#125;obj.name = &#39;Tom&#39;obj.setName = function(name)&#123;this.name=name&#125;</code></pre><h2 id="2-对象字面量模式-一下都定义了"><a href="#2-对象字面量模式-一下都定义了" class="headerlink" title="2). 对象字面量模式 {}一下都定义了"></a>2). 对象字面量模式 {}一下都定义了</h2><p>优点：书写简单，直观。</p><p>缺点：new多个实例对象的时候，重复代码多。</p><pre><code>var obj = &#123;    name : &#39;Tom&#39;,    setName : function(name)&#123;this.name = name&#125;&#125;</code></pre><h2 id="3-构造函数模式"><a href="#3-构造函数模式" class="headerlink" title="3). 构造函数模式"></a>3). 构造函数模式</h2><p>优点：可以大量new，避免重复代码</p><p>缺点：不能明确区分属于哪一类</p><pre><code>function Person(name, age) &#123;    this.name = name    this.age = age    this.setName = function(name)&#123;this.name=name&#125;&#125;new Person(&#39;tom&#39;, 12)</code></pre><h2 id="4-构造函数-原型的组合模式"><a href="#4-构造函数-原型的组合模式" class="headerlink" title="4). 构造函数+原型的组合模式"></a>4). 构造函数+原型的组合模式</h2><p>方法<strong>写在原型</strong>上，可以不用每次new一个实例，都开辟出内存空间，比较省内存。</p><pre><code>function Person(name, age) &#123;    this.name = name    this.age = age&#125;Person.prototype.setName = function(name)&#123;this.name=name&#125;new Person(&#39;tom&#39;, 12) </code></pre><h1 id="2-继承"><a href="#2-继承" class="headerlink" title="2. 继承"></a>2. 继承</h1><h2 id="1-原型链继承-继承方法"><a href="#1-原型链继承-继承方法" class="headerlink" title="1). 原型链继承 : 继承方法"></a>1). 原型链继承 : 继承方法</h2><ul><li><p>子类的原型对象===父类的实例，例如:child.prototype = new Parent();</p></li><li><p>注意点:以上的步骤会导致子类原型的构造器属性丢失，所以需要手动添加构造器属性</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">child.prototype.constructor = child;<br><br><span class="hljs-keyword">function</span> <span class="hljs-constructor">Parent()</span>&#123;&#125;<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Parent</span>.</span></span>prototype.test = <span class="hljs-keyword">function</span><span class="hljs-literal">()</span>&#123;&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-constructor">Child()</span>&#123;&#125;<br><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Child</span>.</span></span>prototype = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Parent()</span> <span class="hljs-comment">//△子类原型指向父类的实例</span><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Child</span>.</span></span>prototype.constructor = Child <span class="hljs-comment">//△然后手动校正 子类的构造器属性重新指向子类（因为上面的操作会新指向一个内存，而丢弃原有的原型对象内存，原有的是有构造器属性的。）</span><br><br>var child = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Child()</span> <br>child.test<span class="hljs-literal">()</span> <span class="hljs-comment">//调用父类型的方法</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="2-借用构造函数-得到属性，无继承关系"><a href="#2-借用构造函数-得到属性，无继承关系" class="headerlink" title="2). 借用构造函数 : 得到属性，无继承关系"></a>2). 借用构造函数 : 得到属性，无继承关系</h2><ul><li><p>在子类的构造函数中调用父类的构造函数-注意点:父类构造函数的this指向问题</p></li><li><p>解决方案:通过call/apply强制修改this的指向 —&gt; 当前子类的实例对象</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">function</span> <span class="hljs-constructor">Parent(<span class="hljs-params">xxx</span>)</span>&#123;this.xxx = xxx&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-constructor">Child(<span class="hljs-params">xxx</span>,<span class="hljs-params">yyy</span>)</span>&#123;<br>  <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Parent</span>.</span></span>call(this, xxx) <span class="hljs-comment">//△借用父类型的构造函数。不写this就window调用了，写半天也没把xxx属性写到子类上。</span><br>  <span class="hljs-comment">//或Parent.apply(this,[xxx]) apply与call用法不同，得是数组。</span><br>&#125;<br>var child = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Child(&#x27;<span class="hljs-params">a</span>&#x27;, &#x27;<span class="hljs-params">b</span>&#x27;)</span>  <span class="hljs-comment">//child.xxx为&#x27;a&#x27;, 但child没有test()</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="3-组合"><a href="#3-组合" class="headerlink" title="3). 组合"></a>3). 组合</h2><pre><code>function Parent(xxx)&#123;this.xxx = xxx&#125;Parent.prototype.test = function()&#123;&#125;function Child(xxx,yyy)&#123;  Parent.call(this, xxx) //借用构造函数   this.Parent(xxx)&#125;Child.prototype = new Parent() //得到test()Child.prototype.constructor = Childvar child = new Child() //child.xxx为&#39;a&#39;, 也有test()</code></pre><h1 id="3-理解"><a href="#3-理解" class="headerlink" title="3. 理解"></a>3. 理解</h1><h2 id="1-定义一个函数背后做了什么"><a href="#1-定义一个函数背后做了什么" class="headerlink" title="1). 定义一个函数背后做了什么?"></a>1). 定义一个函数背后做了什么?</h2><pre><code>创建一个Function的实例对象给对象添加prototype属性, 其值为object空对象(原型对象)给原型对象添加constructor属性, 指向当前函数对象</code></pre><h2 id="2-new一个对象背后做了些什么"><a href="#2-new一个对象背后做了些什么" class="headerlink" title="2). new一个对象背后做了些什么?"></a>2). new一个对象背后做了些什么?</h2><pre><code>创建一个新的空对象给对象设置__proto__, 值为构造函数对象的prototype属性值通过对象执行构造函数体(给对象添加属性/方法)</code></pre><h1 id="垃圾回收GC"><a href="#垃圾回收GC" class="headerlink" title="垃圾回收GC"></a>垃圾回收GC</h1><p>garbage collection<br>垃圾回收机制：循环机制，反复检测环境中的垃圾</p><h2 id="1-计数清除"><a href="#1-计数清除" class="headerlink" title="1.计数清除"></a>1.计数清除</h2><p>IE低版本，老的chrome<br>看内存的地址身上有几个指针指向，当一块内存地址身上指针个数为0，说明这块内存马上要被回收</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs nix">var <span class="hljs-attr">obj</span> = &#123;name : &#x27; kobe &#x27; &#125;<br><span class="hljs-attr">obj</span> = <span class="hljs-literal">null</span>;<br><br>//但是以下互相指的情况不会被GC<br>var <span class="hljs-attr">obj</span> = &#123;<br>a: obj1<br>&#125;<br><br>var <span class="hljs-attr">obj1</span> = &#123;<br>b: obj<br>&#125;<br><br><span class="hljs-attr">obj</span> = <span class="hljs-literal">null</span>;<br><span class="hljs-attr">obj1</span> = <span class="hljs-literal">null</span>;<br></code></pre></td></tr></table></figure><h2 id="2-标记清除"><a href="#2-标记清除" class="headerlink" title="2.标记清除"></a>2.标记清除</h2><p>进入到代码行的环境以后检测到 需要使用的变量 就在其身上加一个进场标记，在代码执行完将return的时候，就会在 之前加标记的变量的身上 再添加一个出场标记</p>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>JS高级02_原型、执行上下文、作用域、闭包</title>
    <link href="/2021/08/29/JSadvance02/"/>
    <url>/2021/08/29/JSadvance02/</url>
    
    <content type="html"><![CDATA[<p>P20 P21没看 +22前11</p><h1 id="1-原型与原型链"><a href="#1-原型与原型链" class="headerlink" title="1. 原型与原型链"></a>1. 原型与原型链</h1><ol><li>函数的prototype属性(图)</li></ol><ul><li><p>每个函数都有一个prototype属性, 它默认指向一个Object空对象(即称为: 原型对象)</p></li><li><p>原型对象中有一个属性constructor, 它指向函数对象</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-keyword">function</span> Person( ) &#123;<br><br>&#125;<br><br><span class="hljs-regexp">//</span><span class="hljs-number">1</span>．每一个函数都有一个属性prototype<br>console.log(Person.prototype);<span class="hljs-regexp">//</span>空对象---&gt;原型对象（显式原型对象)<br><span class="hljs-regexp">//</span>Person.prototype.constructor = 函数本身 声明当前的构造器是谁<br><br>var person1 = new Person(); <span class="hljs-regexp">//</span>生成实例对象<br><br><br><span class="hljs-regexp">//</span><span class="hljs-number">2</span>．每一个实例对象身上都有一个属性_proto_，该属性指向当前实例对象的原型对象(隐式原型对象) 带下划线的叫隐式原型对象△<br><span class="hljs-regexp">//</span><span class="hljs-number">3</span>．构造函数的显式原型对象 === 当前构造函数实例对象 的隐式原型对象<br>console.log(Person.prototype  ===  person1._proto_); <span class="hljs-regexp">//</span> true<br></code></pre></td></tr></table></figure></li></ul><ol start="2"><li>给原型对象添加属性(一般都是方法)</li></ol><ul><li>作用：函数的所有实例对象 都能有原型中的方法（或属性，属性更少因为它一般不公共），即它是公共的</li><li>好处：节省内存</li></ul><h2 id="1-所有函数都有一个特别的属性"><a href="#1-所有函数都有一个特别的属性" class="headerlink" title="1). 所有函数都有一个特别的属性:"></a>1). 所有函数都有一个特别的属性:</h2><pre><code>`prototype` : 显式原型属性</code></pre><h2 id="2-所有实例对象都有一个特别的属性"><a href="#2-所有实例对象都有一个特别的属性" class="headerlink" title="2). 所有实例对象都有一个特别的属性:"></a>2). 所有实例对象都有一个特别的属性:</h2><pre><code>`__proto__` : 隐式原型属性另外：带下划线的是内置方法 以前不可以改动，ES6中可以改了。</code></pre><h2 id="3-显式原型与隐式原型的关系"><a href="#3-显式原型与隐式原型的关系" class="headerlink" title="3). 显式原型与隐式原型的关系"></a>3). 显式原型与隐式原型的关系</h2><pre><code>函数的prototype: 定义函数时被自动赋值, 值默认为&#123;&#125;, 即用为原型对象实例对象的__proto__: 在创建实例对象时被自动添加, 并赋值为构造函数的prototype值原型对象即为当前实例对象的父对象</code></pre><h2 id="4-原型链"><a href="#4-原型链" class="headerlink" title="4). 原型链"></a>4). 原型链</h2><p><img src="/2021/08/29/JSadvance02/img1.png"></p><p>原型链：△</p><p>当使用对象.属性(方法)的时候， </p><p>1.在自身 属性(方法)找</p><p>2.在自身的原型（是一个实例对象） 的属性(方法) 找</p><p>3.Object的原型的 属性(方法) 再原型对象就 = null了。真没有。<br>    Object是个函数对象（就是个函数，但它也是个对象）不是实例对象，Object的原型是实例对象，它有一个toString()方法。</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">a</span><span class="hljs-selector-class">.b</span> <br><br>找<span class="hljs-selector-tag">a</span>(变量)会沿着作用域链找，找<span class="hljs-selector-tag">b</span>(对象的属性)会沿着原型链找<br></code></pre></td></tr></table></figure><p>再上课举例：</p><p><img src="/2021/08/29/JSadvance02/img2.png" alt="image-20210815161200572"></p><pre><code>所有的实例对象都有__proto__属性, 它指向的就是原型对象这样通过__proto__属性就形成了一个链的结构----&gt;原型链当查找对象内部的属性/方法时, js引擎自动沿着这个原型链查找当给对象属性赋值时不会使用原型链, 而只是在当前对象中进行操作</code></pre><p>另外，新建一个变量，也就是new一个实例。</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">var</span> obj = &#123;&#125;;  与  <span class="hljs-keyword">var</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-type">Object</span>() 一样<br><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">12</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]  与  arr = <span class="hljs-keyword">new</span> <span class="hljs-type">Array</span>() 一样<br></code></pre></td></tr></table></figure><h2 id="函数对象-与-对象"><a href="#函数对象-与-对象" class="headerlink" title="函数对象  与 对象"></a>函数对象  与 对象</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Fun</span>(<span class="hljs-params"> </span>) </span>&#123;<br><br>&#125;<br><br><span class="hljs-comment">//Fun() || Fun .xxx ---&gt;函数对象</span><br>Fun.xxx = <span class="hljs-string">&#x27;123&#x27;</span>;<br><br><span class="hljs-built_in">console</span>.log ( Fun) ;<span class="hljs-comment">//函数性质：打印函数本身 没有123</span><br><span class="hljs-built_in">console</span>.log( Fun. xxx);<span class="hljs-comment">//对象性质：打印123</span><br>------------------------------------------<br><span class="hljs-keyword">var</span> obj = &#123;&#125;;<br><span class="hljs-built_in">console</span>.log(obj);<br><span class="hljs-comment">// obj = new Object()</span><br>obj.xxx = <span class="hljs-number">123</span><br><span class="hljs-built_in">console</span>.log(obj.xxx); <span class="hljs-comment">//纯 对象</span><br><br></code></pre></td></tr></table></figure><h2 id="所有函数都由Function-和-Object-派生"><a href="#所有函数都由Function-和-Object-派生" class="headerlink" title="所有函数都由Function() 和 Object()派生"></a>所有函数都由Function() 和 Object()派生</h2><p><img src="/2021/08/29/JSadvance02/img3.jpeg" alt="img"></p><p>Function可以new自己，Object</p><p>Object可以new Function</p><p>金字塔：Object类—-Function Array类</p><p>另外：a instanceof b何时返回true（属于某一类、new b 能得到a）：a的隐式原型链上 可以找到 b的显式原型对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Foo</span>(<span class="hljs-params"></span>) </span>&#123;  &#125;<br><span class="hljs-keyword">var</span> f1 = <span class="hljs-keyword">new</span> Foo();<br><span class="hljs-built_in">console</span>.log(f1 <span class="hljs-keyword">instanceof</span> Foo);<span class="hljs-comment">//true</span><br><span class="hljs-built_in">console</span>.log(f1 <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Object</span>);<span class="hljs-comment">//true</span><br><span class="hljs-built_in">console</span>.log(f1 <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Function</span>);<span class="hljs-comment">//false</span><br><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Object</span> <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Function</span>)<br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Object</span> <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Object</span>)<br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Function</span> <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Object</span>)<br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Function</span> <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Function</span>)<br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Object</span> <span class="hljs-keyword">instanceof</span>  Foo);<span class="hljs-comment">//false上面四个都是true</span><br></code></pre></td></tr></table></figure><h2 id="5-详图"><a href="#5-详图" class="headerlink" title="5). 详图"></a>5). 详图</h2><pre><code>function Foo () &#123;&#125;var f1 = new Foo()var f2 = new Foo()var o1 = &#123;&#125;var o2 = &#123;&#125;</code></pre><p><img src="/2021/08/29/JSadvance02/img4.png"></p><h1 id="2-执行上下文与执行上下文栈"><a href="#2-执行上下文与执行上下文栈" class="headerlink" title="2. 执行上下文与执行上下文栈"></a>2. 执行上下文与执行上下文栈</h1><h2 id="1-变量提前声明与函数提前声明"><a href="#1-变量提前声明与函数提前声明" class="headerlink" title="1). 变量提前声明与函数提前声明"></a>1). 变量提前声明与函数提前声明</h2><p>提前声明讲得贼好：</p><p><a href="https://www.cnblogs.com/lvonve/p/9871226.html">https://www.cnblogs.com/lvonve/p/9871226.html</a></p><p>变量提前声明（预解析）: 在变量定义语句之前, 就可以访问到这个变量(undefined)<br>函数提前声明: 在函数定义语句之前, 就执行该函数(函数本身)<br>先有函数提升, 后有变量提升</p><p>原理:<br>js引擎在js代码正式执行之前会做一些预处理工作</p><p>1、找var和function关键字<br>（不带var关键字的变量可以写，但是分两种情况：1.在全局写不会被预解析 2.在函数里写会自动升成全局的  进行更改或定义）<br>2．找到var以后将var后边的变量提前声明但是不赋值var a;<br>3．找到function以后定义该函数</p><figure class="highlight scilab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs scilab">提前声明举例<br>console.<span class="hljs-built_in">log</span>( username);<span class="hljs-comment">//undefined</span><br>aTest();<span class="hljs-comment">//aTest</span><br>var username = <span class="hljs-string">&#x27;kobe&#x27;</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">aTest</span><span class="hljs-params">()</span>&#123;</span><br>console.<span class="hljs-built_in">log</span>( <span class="hljs-string">&quot;aTest&#x27;</span> );<br>&#125;<br><br>-------<br><br>var fun2 = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span>&#123;</span><br><br>&#125;<br><span class="hljs-comment">//这个只是 变 量 的提前声明 fun2 undefined</span><br></code></pre></td></tr></table></figure><p>冷知识：<br>        1全局定义变量不要定义name 因为window对象上本身就有name属性（一般的不定义的函数、属性会报错，而name不报错但是空的）<br>        2函数有个默认的属性name === 函数名</p><h2 id="2-理解执行上下文-是什么？是全局、局部的-预习变量和函数"><a href="#2-理解执行上下文-是什么？是全局、局部的-预习变量和函数" class="headerlink" title="2). 理解执行上下文 是什么？是全局、局部的 预习变量和函数"></a>2). 理解执行上下文 是什么？是全局、局部的 预习变量和函数</h2><p>执行上下文: 由js引擎自动创建的对象, 包含对应作用域中的所有变量属性（函数）。我认为就是提前声明！+ 找作用域链 + 找this？<br>执行上下文栈: 用来管理产生的多个执行上下文。不嵌套<br>                        在source中的 call stack中可查看</p><p>变量被写入对象之后，再遇到还会再读，写入值一遍，函数不会再读一遍了。</p><h2 id="4-执行上下文生命周期"><a href="#4-执行上下文生命周期" class="headerlink" title="4). 执行上下文生命周期"></a>4). 执行上下文生命周期</h2><p>全局 : 准备执行全局代码前产生, 当页面刷新/关闭页面时死亡<br>函数 : 准备调用函数时产生, 函数执行完时死亡。<br>            ？我理解：没等到调用那行呢，就才遍历到了函数名第一行，就产生了</p><p><img src="/2021/08/29/JSadvance02/img5.png" alt="image-20210816213116676"></p><h2 id="5-包含哪些属性"><a href="#5-包含哪些属性" class="headerlink" title="5). 包含哪些属性:"></a>5). 包含哪些属性:</h2><pre><code>全局 :     用var定义的全局变量  ==&gt;undefined    使用function声明的函数   ===&gt;function    this   ===&gt;window函数 :    用var定义的局部变量  ==&gt;undefined    使用function声明的函数   ===&gt;function    this   ===&gt; 调用函数的对象, 如果没有指定就是window     形参变量   ===&gt;对应实参值    arguments ===&gt;实参列表的伪数组</code></pre><h2 id="6-执行上下文创建和初始化的过程"><a href="#6-执行上下文创建和初始化的过程" class="headerlink" title="6). 执行上下文创建和初始化的过程"></a>6). 执行上下文创建和初始化的过程</h2><p>执行上下文:</p><p>原理：</p><p>js引擎在js代码正式执行之前会先创建执行环境，在执行环境中作预处理工作工作内容:</p><p>过程：</p><p>1.创建空对象—-&gt;执行上下文对象<br>2.该空对象用于收集变量，函数，函数的参数（找var和function)<br>3.创建作用域链<br>4.确认this的指向:   全局:window      局部: this —&gt;?</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-comment">//1.创建全局的执行上下文 入栈(anonymous)</span><br><span class="hljs-selector-tag">var</span> <span class="hljs-selector-tag">a</span> = <span class="hljs-number">10</span><br><br><span class="hljs-selector-tag">var</span> bar = function (x) &#123;<span class="hljs-comment">//创建bar的执行上下文 入栈bar</span><br>    <span class="hljs-selector-tag">var</span> <span class="hljs-selector-tag">b</span> = <span class="hljs-number">5</span><br>    foo(x + b)<br>&#125;<br><br><span class="hljs-selector-tag">var</span> foo = function(y) &#123;<span class="hljs-comment">//创建foo的执行上下文 入栈foo</span><br>    <span class="hljs-selector-tag">var</span> c = <span class="hljs-number">5</span><br>    console<span class="hljs-selector-class">.log</span>(<span class="hljs-selector-tag">a</span> +c +y)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-title">bar</span><span class="hljs-params">( <span class="hljs-number">10</span>)</span></span><br><br></code></pre></td></tr></table></figure><p>冷知识：</p><ul><li><p>所有的函数都有返回值，如果不指定返回值，就是undefined</p></li><li><p>嵌套函数的内部函数 没有被引用到（在fun1里面 fun2() ），fun2将不会被上下文。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>. log( <span class="hljs-string">&quot;xxx&quot;</span>);<br><span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fun</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log( <span class="hljs-string">&#x27;-----&#x27;</span> );<br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fun2</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-comment">//空的 本该有fun2的提前声明，结果没有。</span><br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure></li></ul><h2 id="上下文练习题"><a href="#上下文练习题" class="headerlink" title="上下文练习题"></a>上下文练习题</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;global begin: &#x27;</span>+ i)<br><span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span><br>foo(<span class="hljs-number">1</span>);<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params">i</span>) </span>&#123;<br><span class="hljs-keyword">if</span> (i == <span class="hljs-number">4</span>) &#123;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;foo() begin:&#x27;</span> + i);<br>foo(i + <span class="hljs-number">1</span>);<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;foo() end:&#x27;</span> + i);<br>&#125;<br><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;global end: &#x27;</span> + i)<span class="hljs-comment">//函数内部没有修改i 修改了也犯不着全局的i = 1？</span><br><br><span class="hljs-comment">//undefined 1 2 3 3 2 1 1</span><br></code></pre></td></tr></table></figure><h2 id="提前声明易考知识点："><a href="#提前声明易考知识点：" class="headerlink" title="提前声明易考知识点："></a>提前声明易考知识点：</h2><p>1.当有同名function和变量，不管顺序，预解析结果一定是function。<br>    原理：只要看见了function就不再另声明了。（注意仅限提前声明！！！！）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> a) <span class="hljs-comment">//function</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">a</span>(<span class="hljs-params"></span>) </span>&#123;&#125;<br><span class="hljs-keyword">var</span> a;<br></code></pre></td></tr></table></figure><p>2.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">if</span> (!(b <span class="hljs-keyword">in</span> <span class="hljs-built_in">window</span>)) &#123;<span class="hljs-comment">//in：判断b 是否是 window的一个属性</span><br>  <span class="hljs-keyword">var</span> b = <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-built_in">console</span>.log(b)<span class="hljs-comment">//undefined</span><br><br><span class="hljs-comment">//这不是函数，if不是个作用域。所以var b被全局提前声明，window.b if里条件不满足不执行。</span><br></code></pre></td></tr></table></figure><p>3.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//预解析 c = function()&#123;&#125;</span><br><span class="hljs-keyword">var</span> c = <span class="hljs-number">1</span>  <span class="hljs-comment">// c = 1</span><br> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">c</span>(<span class="hljs-params">c</span>) </span>&#123;<span class="hljs-comment">//重点！！！函 数 预解析了就不会再读一遍赋值了 所以c：function  ---&gt;  1</span><br>   <span class="hljs-built_in">console</span>.log(c)<br>   <span class="hljs-keyword">var</span> c = <span class="hljs-number">3</span><br> &#125;<br> c(<span class="hljs-number">2</span>)<br> <span class="hljs-comment">//报错 因为c是一个变量不是一个函数</span><br></code></pre></td></tr></table></figure><h1 id="3-作用域与作用域链"><a href="#3-作用域与作用域链" class="headerlink" title="3. 作用域与作用域链"></a>3. 作用域与作用域链</h1><h2 id="1-定义"><a href="#1-定义" class="headerlink" title="1). 定义:"></a>1). 定义:</h2><p>作用域: 代码执行区域。 在编码时就确定了, 不会再变化<br>作用域链: 多个嵌套的作用域 查找变量时 先找当前的，再找往外的，直到全局作用域。如果还没有，会报错，xxx is not defined </p><h2 id="2-分类"><a href="#2-分类" class="headerlink" title="2). 分类:"></a>2). 分类:</h2><p>全局<br>函数（局部）<br><del>js没有块作用域(在ES6之前)</del></p><h2 id="作用域销毁"><a href="#作用域销毁" class="headerlink" title="作用域销毁"></a>作用域销毁</h2><p>局部销毁：函数执行完毕</p><p>全局销毁：关闭浏览器</p><h2 id="3-作用域作用"><a href="#3-作用域作用" class="headerlink" title="3). 作用域作用"></a>3). 作用域作用</h2><p>作用域: 隔离变量, 可以在不同作用域定义同名的变量不冲突<br>作用域链: 查找变量</p><h2 id="4-作用域-执行上下文-区别"><a href="#4-作用域-执行上下文-区别" class="headerlink" title="4). 作用域 执行上下文 区别"></a>4). 作用域 执行上下文 区别</h2><p>作用域: 静态的, 编码时就确定了(不是在运行时), 一旦确定就不会变化了<br>执行上下文: 动态的, 执行代码时动态创建, 当执行结束消失<br>联系: </p><ul><li>执行上下文环境 是在对应的作用域中的 </li><li>在作用域中查找变量去 当前作用域下的 执行上下文对象中找</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">function <span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">()</span></span> &#123;<br>    <br>    console.log(num);<span class="hljs-comment">// &#123;num: undefined&#125;</span><br>    console.log(b);<span class="hljs-comment">//报错！undefined</span><br>    <span class="hljs-keyword">var</span> num = <span class="hljs-number">123</span>;<br>    b = <span class="hljs-number">234</span>;<span class="hljs-comment">//注意这里！！ 全局提前声明的时候，看不到他，局部提前声明的时候，不带var也看不到。只有执行完这一行，全局就拥有一个b了。所以上面是报错，下面是234</span><br>    console.log(b);<span class="hljs-comment">//234</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">()</span></span>;<br><br></code></pre></td></tr></table></figure><h2 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-number">1</span><br><span class="hljs-comment">//我做错了！</span><br><span class="hljs-keyword">var</span> x = <span class="hljs-number">10</span>;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params"></span>) </span>&#123;<br><span class="hljs-built_in">console</span>.log(x);<span class="hljs-comment">//这自己没运行啊</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">show</span>(<span class="hljs-params">f</span>) </span>&#123;<br><span class="hljs-keyword">var</span> x = <span class="hljs-number">20</span>;<br>f();<br>&#125;<br>show(fn);<span class="hljs-comment">//函数作为参数 - 调用了fn() - fn里面没有x - 去全局找x=10</span><br><br><span class="hljs-comment">//10</span><br><span class="hljs-comment">//这道题！！千万注意！！就是作用域是固定的，两个作用域平行。还是两个函数各自分离的，只是调用了它一下！并不是在show()里调用了fn()，不 像 想象的：</span><br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">show</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-keyword">var</span> x = <span class="hljs-number">20</span>;<br>        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params"></span>)</span>&#123;<span class="hljs-comment">//这里fn的作用域就是show的子作用域了</span><br>        <span class="hljs-built_in">console</span>.log(x);<br>        &#125;<br>        fn();<span class="hljs-comment">//在这里确实是20</span><br>    &#125;<br>  <br>---------------<br><span class="hljs-number">2</span><br><span class="hljs-keyword">var</span> fn = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(fn)<br>  &#125;<br>  fn()<span class="hljs-comment">//log fn本级没有，往外找了，全局找到了 ƒ () &#123;console.log(fn)&#125;。。。</span><br>  <span class="hljs-comment">//注意这里function简写成f了吗？</span><br><br>  <span class="hljs-keyword">var</span> obj = &#123;<br>    <span class="hljs-attr">fn2</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>      <span class="hljs-built_in">console</span>.log(fn2)<span class="hljs-comment">//</span><br>    &#125;<br>  &#125;<br>  obj.fn2()<span class="hljs-comment">//会报错 is not defined。因为本级没有fn2。向上一级（注意obj不算一级！！！！，即全局）也没有fn2，因为只有obj！！！</span><br>    <span class="hljs-comment">// 所以 console.log()里面写obj.fn2 或 this.fn2 才能实现fn2所表示函数的打印。</span><br></code></pre></td></tr></table></figure><h1 id="4-闭包"><a href="#4-闭包" class="headerlink" title="4. 闭包"></a>4. 闭包</h1><p>定义：是一个闭合的容器，可以理解为是一个对象，以键值对形式存在</p><p>特点：闭包在使用的时候通常会将内部的函数return出去</p><ol start="3"><li>产生闭包的条件?</li></ol><ul><li>函数嵌套</li><li>内部函数引用了外部函数的数据(变量/函数)</li><li>外部函数调用</li></ul><h2 id="2-作用"><a href="#2-作用" class="headerlink" title="2). 作用:"></a>2). 作用:</h2><pre><code>延长外部函数 局部变量的 生命周期从外部访问函数内部的局部变量</code></pre><h2 id="3-写一个闭包程序"><a href="#3-写一个闭包程序" class="headerlink" title="3). 写一个闭包程序"></a>3). 写一个闭包程序</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//经典闭包作用：</span><br>&lt;script type=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;<br>  <br>  <br>  <span class="hljs-keyword">var</span> btns = <span class="hljs-built_in">document</span>.getElementsByTagName(<span class="hljs-string">&#x27;button&#x27;</span>)<br>  <span class="hljs-comment">//它是个伪数组：因为它具备数组的一般特征，可以通过下标取值，还有Length属性，但是！！没有数组的一般方法: foreach等等等</span><br><br> <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i=<span class="hljs-number">0</span>,length=btns.length;i&lt;length;i++) &#123;<br>    <span class="hljs-keyword">var</span> btn = btns[i]<br>    <span class="hljs-built_in">console</span>.log(i)<span class="hljs-comment">//0 1 2</span><br>    btn.onclick = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>      <span class="hljs-comment">// console.log(i)</span><br>      <span class="hljs-comment">//回调函数！！在for循环的时候没执行，跳过了。</span><br>      <span class="hljs-comment">// 等它执行的时候，每次都是3。而且本以为是2，但是循环完之后又i++了，所以是3.</span><br>      alert(<span class="hljs-string">&#x27;第&#x27;</span>+(i)+<span class="hljs-string">&#x27;个&#x27;</span>) <span class="hljs-comment">//每次都是3</span><br>    &#125;<br>  &#125;<br>-----------------------------<br><br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i=<span class="hljs-number">0</span>,length=btns.length;i&lt;length;i++) &#123;<br>    <span class="hljs-keyword">var</span> btn = btns[i]<br>    btn.index = i <span class="hljs-comment">//在这里集体都排好队起好属性名，等会对象.属性名就不会混了。通过这里 + this回调对象 实现按钮不同的信息</span><br>    btn.onclick = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>      alert(<span class="hljs-string">&#x27;第&#x27;</span>+(<span class="hljs-built_in">this</span>.index+<span class="hljs-number">1</span>)+<span class="hljs-string">&#x27;个&#x27;</span>)<br>    &#125;<br>  &#125;<br>-----------------------------<br><br>  <span class="hljs-comment">//闭包解决</span><br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i=<span class="hljs-number">0</span>,length=btns.length;i&lt;length;i++) &#123;<br>    (<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">i</span>) </span>&#123;<br>      <span class="hljs-keyword">var</span> btn = btns[i]<br>      btn.onclick = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>        alert(<span class="hljs-string">&#x27;第&#x27;</span>+(i+<span class="hljs-number">1</span>)+<span class="hljs-string">&#x27;个&#x27;</span>)<br>      &#125;<br>    &#125;)(i)<br>  &#125;<br><br><br>----------------------------<br><span class="hljs-comment">//一个简单的闭包，嵌套，引用外面的值了</span><br><span class="hljs-comment">//闭包在此处的作用：从外部访问\操作函数内部的局部变量。???</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn1</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span>;<br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn2</span>(<span class="hljs-params"></span>) </span>&#123;<br>    a++;<br>    <span class="hljs-built_in">console</span>.log(a);<br>  &#125;<br>  <span class="hljs-keyword">return</span> fn2;<br>&#125;<br><span class="hljs-keyword">var</span> f = fn1();<br>f();<br>f();<br></code></pre></td></tr></table></figure><p>外部调用，操作内部变量的操作：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-number">1.</span>在html中<br>&lt;script <span class="hljs-keyword">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span> src=<span class="hljs-string">&quot;05_coolModule.js&quot;</span>&gt;&lt;/script&gt;<br>&lt;!--外部引用跟我在这直接写一个coolModule是一样的--&gt;<br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><span class="javascript"></span></span><br><span class="javascript"><span class="xml">  <span class="hljs-keyword">var</span> <span class="hljs-built_in">module</span> = coolModule()</span></span><br><span class="javascript"><span class="xml">  <span class="hljs-built_in">module</span>.doSomething()<span class="hljs-comment">//如果log 就是ATGUIGU,即用了内部变量。</span></span></span><br><span class="javascript"><span class="xml">  <span class="hljs-built_in">module</span>.doOtherthing()</span></span><br><span class="javascript"><span class="xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><br><br><span class="hljs-number">2.</span>在coolModule.js中<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">coolModule</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-comment">//私有的数据，外部引用了也看不到，但是可以选择向外暴露就能看到了。</span><br>  <span class="hljs-keyword">var</span> msg = <span class="hljs-string">&#x27;atguigu&#x27;</span><br>  <span class="hljs-keyword">var</span> names = [<span class="hljs-string">&#x27;I&#x27;</span>, <span class="hljs-string">&#x27;Love&#x27;</span>, <span class="hljs-string">&#x27;you&#x27;</span>]<br><br>  <span class="hljs-comment">//私有的操作数据的函数</span><br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">doSomething</span>(<span class="hljs-params"></span>) </span>&#123;<span class="hljs-comment">//产生了闭包</span><br>    <span class="hljs-built_in">console</span>.log(msg.toUpperCase())<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">doOtherthing</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(names.join(<span class="hljs-string">&#x27; &#x27;</span>))<br>  &#125;<br>  <br>  <span class="hljs-comment">//向外暴露包含多个方法的对象</span><br>  <span class="hljs-keyword">return</span> &#123;<br>    <span class="hljs-attr">doSomething</span>: doSomething,<br>    <span class="hljs-attr">doOtherthing</span>: doOtherthing<br>  &#125;<br>&#125;<br>-----------------------------<br>用法<span class="hljs-number">2</span><br><span class="hljs-number">1.</span>在html中<br>&lt;script <span class="hljs-keyword">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span> src=<span class="hljs-string">&quot;05_coolModule2.js&quot;</span>&gt;&lt;/script&gt;<br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><span class="javascript"></span></span><br><span class="javascript"><span class="xml">  coolModule2.a()<span class="hljs-comment">//coolModule2是个对象了</span></span></span><br><span class="javascript"><span class="xml">  coolModule2.b()</span></span><br><span class="javascript"><span class="xml">  </span></span><br><span class="javascript"><span class="xml"><span class="hljs-number">2.</span>在js中coolModule2.js</span></span><br><span class="javascript"><span class="xml">(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"><span class="hljs-built_in">window</span></span>) </span>&#123;</span></span><br><span class="javascript"><span class="xml">  <span class="hljs-comment">//私有的数据</span></span></span><br><span class="javascript"><span class="xml">  <span class="hljs-keyword">var</span> msg = <span class="hljs-string">&#x27;atguigu&#x27;</span></span></span><br><span class="javascript"><span class="xml">  <span class="hljs-keyword">var</span> names = [<span class="hljs-string">&#x27;I&#x27;</span>, <span class="hljs-string">&#x27;Love&#x27;</span>, <span class="hljs-string">&#x27;you&#x27;</span>]</span></span><br><span class="javascript"><span class="xml">  <span class="hljs-comment">//操作数据的函数</span></span></span><br><span class="javascript"><span class="xml">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">a</span>(<span class="hljs-params"></span>) </span>&#123;</span></span><br><span class="javascript"><span class="xml">    <span class="hljs-built_in">console</span>.log(msg.toUpperCase())</span></span><br><span class="javascript"><span class="xml">  &#125;</span></span><br><span class="javascript"><span class="xml">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">b</span>(<span class="hljs-params"></span>) </span>&#123;</span></span><br><span class="javascript"><span class="xml">    <span class="hljs-built_in">console</span>.log(names.join(<span class="hljs-string">&#x27; &#x27;</span>))</span></span><br><span class="javascript"><span class="xml">  &#125;</span></span><br><span class="javascript"><span class="xml"></span></span><br><span class="javascript"><span class="xml">  <span class="hljs-built_in">window</span>.coolModule2 =  &#123;<span class="hljs-comment">//这是啥玩意操作？对象.属性 = 对象</span></span></span><br><span class="javascript"><span class="xml">    <span class="hljs-attr">a</span>: a,<span class="hljs-comment">//前面的a可以任意起名，后面是函数名</span></span></span><br><span class="javascript"><span class="xml">    <span class="hljs-attr">b</span>: b</span></span><br><span class="javascript"><span class="xml">  &#125;</span></span><br><span class="javascript"><span class="xml">&#125;)(<span class="hljs-built_in">window</span>)</span></span><br></code></pre></td></tr></table></figure><h2 id="4-闭包应用"><a href="#4-闭包应用" class="headerlink" title="4). 闭包应用:"></a>4). 闭包应用:</h2><pre><code>循环遍历加监听（按钮赋值例子）将内部的函数返出来将函数作为实参传递给另一个函数调用JS框架(jQuery)大量使用了闭包</code></pre><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> 产生: 在嵌套内部函数定义执行完时就产生了(不是在调用)<br><span class="hljs-bullet">2.</span> 死亡: 在嵌套的内部函数成为垃圾对象时<br></code></pre></td></tr></table></figure><h2 id="5-缺点及解决"><a href="#5-缺点及解决" class="headerlink" title="5). 缺点及解决:"></a>5). 缺点及解决:</h2><pre><code>变量占用内存的时间可能会过长可能导致内存泄露解决: 能不用就不用闭包/及时释放 : var f = null; //让内部函数变量 成为垃圾对 象</code></pre><h2 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h2><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">//代码片段一</span><br><span class="hljs-keyword">var</span> name = <span class="hljs-string">&quot;The Window&quot;</span>;<br><span class="hljs-keyword">var</span> <span class="hljs-built_in">object</span> = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;My Object&quot;</span>,<br>  <span class="hljs-attr">getNameFunc</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-comment">//此处this是object</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.name;<br>    &#125;;<br>  &#125;<br>&#125;;<br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">object</span>.getNameFunc()());  <span class="hljs-comment">//? My Object</span><br><span class="hljs-comment">//这个()()是连续执行。相当于</span><br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.name;<br>  &#125;());<br>  <span class="hljs-comment">//这里的this是(),window</span><br><br><span class="hljs-comment">//代码片段二</span><br><span class="hljs-keyword">var</span> name2 = <span class="hljs-string">&quot;The Window&quot;</span>;<br><span class="hljs-keyword">var</span> object2 = &#123;<br>  <span class="hljs-attr">name2</span>: <span class="hljs-string">&quot;My Object&quot;</span>,<br>  <span class="hljs-attr">getNameFunc</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">var</span> that = <span class="hljs-built_in">this</span>;<span class="hljs-comment">//缓存this 保证this的指向不发生改变，即object2</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>      <span class="hljs-keyword">return</span> that.name2;<br>    &#125;;<br>  &#125;<br>&#125;;<br><span class="hljs-built_in">console</span>.log(object2.getNameFunc()()); <span class="hljs-comment">//My Object</span><br></code></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">习题<br><br>  function <span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">()</span></span>&#123;<br>  <span class="hljs-keyword">return</span> console.log(<span class="hljs-number">1</span>);<br>  <span class="hljs-comment">// return alert(1); 也是同样的效果</span><br>  &#125;<br>  console.log(<span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">()</span></span>);<br>  <span class="hljs-comment">//会输出两次，1，undefined。undefined是因为console.log 返回值是undefined</span><br>  <br>  -----------------------<br></code></pre></td></tr></table></figure><h1 id="5-内存溢出与内存泄露"><a href="#5-内存溢出与内存泄露" class="headerlink" title="5. 内存溢出与内存泄露"></a>5. 内存溢出与内存泄露</h1><h2 id="1-内存溢出"><a href="#1-内存溢出" class="headerlink" title="1). 内存溢出"></a>1). 内存溢出</h2><pre><code>一种程序运行出现的错误当程序运行需要的内存超过了剩余的内存时, 就出抛出内存溢出的错误</code></pre><h2 id="2-内存泄露"><a href="#2-内存泄露" class="headerlink" title="2). 内存泄露"></a>2). 内存泄露</h2><pre><code>占用的内存没有及时释放内存泄露积累多了就容易导致内存溢出常见的内存泄露:    意外的全局变量    没有及时清理的计时器或回调函数    闭包</code></pre><h1 id="函数高级补充知识："><a href="#函数高级补充知识：" class="headerlink" title="函数高级补充知识："></a>函数高级补充知识：</h1><h2 id="1-同步与异步"><a href="#1-同步与异步" class="headerlink" title="1.同步与异步"></a>1.同步与异步</h2><p>同步：没有回调。阻塞后续代码执行，一个一个执行。</p><p>异步：一定有回调函数。可能不立马执行，但是非阻塞，同时进行。例如：定时器。</p>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>JS高级01_类型、对象、函数、Git基本操作</title>
    <link href="/2021/08/29/JSadvance01/"/>
    <url>/2021/08/29/JSadvance01/</url>
    
    <content type="html"><![CDATA[<h1 id="1-数据类型的分类和判断"><a href="#1-数据类型的分类和判断" class="headerlink" title="1. 数据类型的分类和判断"></a>1. 数据类型的分类和判断</h1><h2 id="1-基本-值-类型"><a href="#1-基本-值-类型" class="headerlink" title="1). 基本(值)类型"></a>1). 基本(值)类型</h2><pre><code>Number ----- 任意数值 -------- typeofString ----- 任意字符串 ------ typeofBoolean ---- true/false ----- typeofundefined --- undefined ----- typeof/===null -------- null ---------- ===</code></pre><h2 id="2-对象-引用-类型"><a href="#2-对象-引用-类型" class="headerlink" title="2). 对象(引用)类型"></a>2). 对象(引用)类型</h2><pre><code>Object ----- typeof/instanceofArray ------ instanceofFunction ---- typeof/instanceof</code></pre><ol><li><h2 id="数据类型分类-2大类"><a href="#数据类型分类-2大类" class="headerlink" title="数据类型分类(2大类)"></a>数据类型分类(2大类)</h2></li></ol><ul><li><p>基本(值)类型（赋值的时候 值传递）</p><ul><li>Number: 任意数值</li><li>String: 任意文本</li><li>Boolean: true/false</li><li>undefined: undefined</li><li>null: null</li></ul></li><li><p>对象(引用)类型（赋值的时候 引用传递）</p><ul><li><p>Object: 任意对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123;<span class="hljs-attr">name</span> : <span class="hljs-string">&#x27;kobe&#x27;</span>&#125;; <br><span class="hljs-comment">//obj是一个变量在栈里面 指向一个 在堆里的对象的 地址。=后面是一个对象的值</span><br><br><span class="hljs-keyword">var</span> a = <span class="hljs-literal">null</span>;<br>a = <span class="hljs-number">123</span>;<br><span class="hljs-keyword">var</span> b = a;<span class="hljs-comment">//值传递 因为此处把a指向的，即一个值赋值给了b</span><br>b = <span class="hljs-number">234</span>;<span class="hljs-comment">//b就改值了，不关a的事</span><br><span class="hljs-built_in">console</span>. log(a); <span class="hljs-comment">// 123</span><br><br><br><span class="hljs-keyword">var</span> obj = &#123;<span class="hljs-attr">name</span>: <span class="hljs-string">&quot;kobe&quot;</span>&#125;; <br><span class="hljs-keyword">var</span> obj2 = obj;<span class="hljs-comment">//因为是地址的传递 指向堆里面的对象的地址了</span><br>obj2.name = <span class="hljs-string">&#x27;wade&#x27;</span>;<span class="hljs-comment">//然后此处直接指人家里，把人名改了</span><br><span class="hljs-built_in">console</span>.log(obj);<span class="hljs-comment">//wade</span><br><br><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">12</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>];<br><span class="hljs-keyword">var</span> arr2 = arr;<span class="hljs-comment">//引用传 arr2[1]= 234;</span><br><span class="hljs-built_in">console</span>.log(arr); <span class="hljs-comment">// [12，234，4]</span><br><br></code></pre></td></tr></table></figure></li><li><p>Array: 特别的对象类型(下标/内部数据有序)</p></li><li><p>Function: 特别的对象类型(可执行)</p></li></ul></li></ul><ol start="2"><li><h2 id="判断"><a href="#判断" class="headerlink" title="判断"></a>判断</h2></li></ol><ul><li><p>typeof:检测数据类型</p><ul><li>可以区别: string number booLean undefined object（null、array也是o） function</li><li>不能区别: null与对象, 数组与一般对象</li></ul></li><li><p>instanceof</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">A</span> instanceof <span class="hljs-selector-tag">B</span> 判断<span class="hljs-selector-tag">A</span>是否是<span class="hljs-selector-tag">B</span>的实例<br></code></pre></td></tr></table></figure><ul><li>专门用来判断对象数据的类型: Object, Array与Function</li></ul></li><li><p>===</p><ul><li>可以判断: undefined和null</li></ul></li></ul><ol><li><h2 id="undefined与null的区别"><a href="#undefined与null的区别" class="headerlink" title="undefined与null的区别?"></a>undefined与null的区别?</h2></li></ol><ul><li><p>undefined代表没有赋值，未定义</p></li><li><p>null代表赋值了, 只是值为null</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">console</span>.log(<span class="hljs-literal">null</span> == <span class="hljs-literal">undefined</span>); //<span class="hljs-literal">true</span> <span class="hljs-literal">undefined</span>来自于<span class="hljs-literal">null</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-literal">null</span>=== <span class="hljs-literal">undefined</span>); <span class="hljs-regexp">//</span> <span class="hljs-literal">false</span> 类型不一样<br></code></pre></td></tr></table></figure></li></ul><ol start="2"><li><h2 id="什么时候给变量赋值为null呢"><a href="#什么时候给变量赋值为null呢" class="headerlink" title="什么时候给变量赋值为null呢?"></a>什么时候给变量赋值为null呢?</h2></li></ol><ul><li>var a = null //a将指向一个对象, 但对象此时还没有确定</li><li>a = null //让a指向的对象成为垃圾对象</li></ul><ol start="3"><li>严格区别变量类型与数据类型?</li></ol><ul><li>js的变量本身是没有类型的, 变量的类型实际上是变量内存中数据的类型</li><li>变量类型:<ul><li>基本类型: 保存基本类型数据的变量</li><li>引用类型: 保存对象地址值的变量</li></ul></li><li>数据对象<ul><li>基本类型</li><li>对象类型</li></ul></li></ul><h1 id="2-数据-变量-内存的理解"><a href="#2-数据-变量-内存的理解" class="headerlink" title="2. 数据,变量, 内存的理解"></a>2. 数据,变量, 内存的理解</h1><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs stata">问题: JS引擎如何管理内存?<br>  1. 内存生命周期<br>    1). 分配需要的内存<br>    2). 使用分配到的内存<br>    3). 不需要时将其释放/归还<br>  2. 释放内存<br><span class="hljs-comment">    * 为执行函数分配的栈空间内存: 函数执行完自动释放</span><br><span class="hljs-comment">    * 存储对象的堆空间内存: 当内存没有引用指向时, 对象成为垃圾对象, 垃圾回收器后面就会回收释放此内存</span><br></code></pre></td></tr></table></figure><h2 id="1-什么是数据"><a href="#1-什么是数据" class="headerlink" title="1). 什么是数据?"></a>1). 什么是数据?</h2><pre><code>在内存中可读的, 可传递的保存了特定信息的&#39;东东&#39;一切皆数据, 函数也是数据在内存中的所有操作的目标: 数据</code></pre><h2 id="2-什么是变量"><a href="#2-什么是变量" class="headerlink" title="2). 什么是变量?"></a>2). 什么是变量?</h2><pre><code>在程序运行过程中它的值是允许改变的量一个变量对应一块小内存, 它的值保存在此内存中  </code></pre><h2 id="3-什么是内存"><a href="#3-什么是内存" class="headerlink" title="3). 什么是内存?"></a>3). 什么是内存?</h2><pre><code>内存条通电后产生的存储空间(临时的)一块内存包含2个方面的数据    内部存储的数据    地址值数据内存空间的分类    栈空间: 全局变量和局部变量    堆空间: 对象 </code></pre><h2 id="4-内存-数据-变量三者之间的关系"><a href="#4-内存-数据-变量三者之间的关系" class="headerlink" title="4). 内存,数据, 变量三者之间的关系"></a>4). 内存,数据, 变量三者之间的关系</h2><pre><code>内存是容器, 用来存储不同数据变量是内存的标识, 通过变量我们可以操作(读/写)内存中的数据  </code></pre><h1 id="3-对象的理解和使用"><a href="#3-对象的理解和使用" class="headerlink" title="3. 对象的理解和使用"></a>3. 对象的理解和使用</h1><h2 id="1-什么是对象"><a href="#1-什么是对象" class="headerlink" title="1). 什么是对象?"></a>1). 什么是对象?</h2><pre><code>多个数据(对象)的集合用来保存多个数据(对象)的容器</code></pre><h2 id="2-属性组成"><a href="#2-属性组成" class="headerlink" title="2). 属性组成:"></a>2). 属性组成:</h2><pre><code>属性名 : 字符串(标识)属性值 : 任意类型</code></pre><h2 id="3-属性的分类"><a href="#3-属性的分类" class="headerlink" title="3). 属性的分类:"></a>3). 属性的分类:</h2><pre><code>一般 : 属性值不是function  描述对象的状态方法 : 属性值为function的属性  描述对象的行为</code></pre><h2 id="4-特别的对象"><a href="#4-特别的对象" class="headerlink" title="4). 特别的对象"></a>4). 特别的对象</h2><pre><code>数组: 属性名是0,1,2,3之类的索引函数: 可以执行的</code></pre><h2 id="5-如何操作内部属性-方法"><a href="#5-如何操作内部属性-方法" class="headerlink" title="5). 如何操作内部属性(方法)"></a>5). 如何操作内部属性(方法)</h2><pre><code>对象.属性名 = 对象[&#39;属性名&#39;] = 属性名有特殊字符/属性名是一个变量</code></pre><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript">对象[变量] = 此时不加单引号，直接引用了变量的值<br><span class="hljs-keyword">var</span> xxx = <span class="hljs-string">&#x27;sex&#x27;</span>;<br><span class="hljs-keyword">var</span> obj = &#123;<br><span class="hljs-attr">str</span>: <span class="hljs-string">&#x27;abc&#x27;</span>,<br><span class="hljs-attr">num</span>: <span class="hljs-number">123</span>&#125;<br><span class="hljs-built_in">console</span>.log(obj.str);<br><span class="hljs-comment">//对象中的key一定是字符串</span><br>obj[xxx] =<span class="hljs-string">&#x27;男&#x27;</span>;<br><span class="hljs-built_in">console</span>.log(obj);<span class="hljs-comment">// &#123;sex:&#x27;男&#x27;&#125;！</span><br><br><span class="hljs-comment">//对象中的key一定是字符串 也就是a[]框里的就是key，自动调用了toString</span><br><span class="hljs-built_in">console</span>.log(num.toString());<br><span class="hljs-built_in">console</span>.log(obj1.toString());<span class="hljs-comment">//[object Object]</span><br><span class="hljs-keyword">var</span> a = &#123;&#125;<br><span class="hljs-keyword">var</span> obj1 = &#123;<span class="hljs-attr">n</span>: <span class="hljs-number">2</span>&#125;<br><span class="hljs-keyword">var</span> obj2 = &#123;<span class="hljs-attr">m</span>: <span class="hljs-number">3</span>&#125;<br>a[obj1] = <span class="hljs-number">4</span><br><span class="hljs-comment">//调用对象的时候用了toString 相当于两行a[&#x27;[object Object]&#x27;] = 4，5</span><br>a[obj2] = <span class="hljs-number">5</span><br><span class="hljs-built_in">console</span>.log(a[obj1]) <span class="hljs-comment">// 输出多少? 5</span><br></code></pre></td></tr></table></figure><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sqf">var obj =&#123;<span class="hljs-built_in">name</span>: <span class="hljs-string">&#x27;kobe&#x27;</span>&#125;<br>obj = &#123;<span class="hljs-built_in">name</span> : <span class="hljs-string">&#x27;kobe&#x27;</span>&#125; <span class="hljs-comment">//指向了一个新对象（栈里存的 堆内存的地址变了），只不过对象和刚才长得一样。</span><br>obj.<span class="hljs-built_in">name</span> = <span class="hljs-string">&#x27;wade&#x27;</span><span class="hljs-comment">//这个没指向新的，只是在上面的对象属性里修改了。</span><br></code></pre></td></tr></table></figure><h1 id="4-函数的理解和使用"><a href="#4-函数的理解和使用" class="headerlink" title="4. 函数的理解和使用"></a>4. 函数的理解和使用</h1><h2 id="1-什么是函数"><a href="#1-什么是函数" class="headerlink" title="1). 什么是函数?"></a>1). 什么是函数?</h2><pre><code>用来实现特定功能的, n条语句的封装体只有函数类型的数据是可以执行的, 其它的都不可以</code></pre><h2 id="2-为什么要用函数"><a href="#2-为什么要用函数" class="headerlink" title="2). 为什么要用函数?"></a>2). 为什么要用函数?</h2><pre><code>提高复用性便于阅读交流</code></pre><h2 id="3-函数也是对象"><a href="#3-函数也是对象" class="headerlink" title="3). 函数也是对象"></a>3). 函数也是对象</h2><pre><code>instanceof Object===true函数有属性: prototype函数有方法: call()/apply()可以添加新的属性/方法</code></pre><h2 id="4-函数的调用"><a href="#4-函数的调用" class="headerlink" title="4). 函数的调用"></a>4). 函数的调用</h2><p>1一般函数 : 直接调用 函数自调用 === window.函数调用</p><p>2构造函数 : 通过new调用 实例化对象。this指向的当前构造函数的实例对象。<br>构造函数名可以是小写。但是一般构造函数都是首字母大写</p><pre><code>function person(name,age) &#123;    this.name = name;    this.age = age;    this.eat = function () iconsole.log( &#39;吃东西&quot;);&#125;    &#125;        var person1 = new Person( &#39; kobe&#39; ,42);    var person2 = new Person( &quot; wade&#39; ,38);|</code></pre><p>​    3回调函数 : callback 事件的回调 定时器的回调</p><p>​    4call apply 强制改变this，我理解即指定对象调用函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> obj4 = &#123;<span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;kobe&#x27;</span>&#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fun3</span>(<span class="hljs-params"> </span>)</span>&#123;<br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>)<br>&#125;<br>fun3(); \\ <span class="hljs-built_in">this</span> ---&gt; <span class="hljs-built_in">window</span><br>fun3.call(obj4)<br>fun3.apply(obj4)<br></code></pre></td></tr></table></figure><h2 id="5-函数中的this"><a href="#5-函数中的this" class="headerlink" title="5). 函数中的this"></a>5). 函数中的this</h2><p>this是什么?<br>  1 一个关键字, 一个内置的引用变量</p><p>  2 this本身是一个内置的变量 此变量用于指向一个对象</p><p> 3 this有两种：</p><ul><li>全局this = window<br>两种的例子：</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">    function <span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">()</span></span> &#123;<br>    console.log(<span class="hljs-keyword">this</span>);<br>    <span class="hljs-keyword">this</span>.name = <span class="hljs-string">&#x27;kobe&#x27;</span><span class="hljs-comment">//可以不写死</span><br>&#125;<br><br>window.<span class="hljs-keyword">fun</span>();<span class="hljs-comment">//this 是 window</span><br></code></pre></td></tr></table></figure><ul><li> 局部（函数）this = 调用此函数的对象；</li></ul><p>   构造函数this = 当前构造函数的实例对象</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-keyword">new</span> fun();<span class="hljs-regexp">//</span>只要<span class="hljs-keyword">new</span>了，里面的<span class="hljs-built_in">this</span>就一定指的实例对象。这里的<span class="hljs-built_in">this</span>是实例对象，只不过不像下面一行有接收，所以这里<span class="hljs-built_in">this</span>显示为<span class="hljs-literal">undefined</span><br><br>//fun 其实等于var fun1 = <span class="hljs-keyword">new</span> fun();实例对象fun1 上面只不过没定义接收的变量<br></code></pre></td></tr></table></figure><p>​       另：new操作符语法: new function( );<br>​       1．创建空对象<br>​       2．执行函数<br>​       3．确认this 的指向 指向堆中的哪里: this —&gt;创建空对象<br>​       4．返回执行的结果<br>​       可以拿一个构造函数来理解</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span><span class="hljs-params">( name, age)</span> </span>&#123;<br>    <span class="hljs-comment">//1.创建空对象&#123;&#125;</span><br>    <span class="hljs-keyword">this</span>.name = name;<br>    <span class="hljs-keyword">this</span>.age = age;<br>&#125;<br><br><span class="hljs-keyword">var</span> person1 = <span class="hljs-keyword">new</span> Person( <span class="hljs-string">&#x27;KOBE&#x27;</span>， <span class="hljs-number">41</span>)<br><span class="hljs-comment">// &#123;name : &#x27;xxx&#x27; , age: xxx&#125;</span><br></code></pre></td></tr></table></figure><p> 4 特殊this：call apply 强制修改this</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">fun.call(obj);<span class="hljs-regexp">//</span>obj<br></code></pre></td></tr></table></figure><p>​    显式指定谁: obj.xxx()<br>​    通过call/apply指定谁调用: xxx.call(obj)<br>​    不指定谁调用: xxx()  : window<br>​    回调函数: 看背后是通过谁来调用的: window/其它</p><h2 id="6-匿名函数自调用（立即调用）-IIEF"><a href="#6-匿名函数自调用（立即调用）-IIEF" class="headerlink" title="6). 匿名函数自调用（立即调用）:IIEF"></a>6). 匿名函数自调用（立即调用）:IIEF</h2><p>特点：</p><pre><code>特点:1．只执行一次2．什么时候执行:代码执行到函数位置立即执行3．内部的数据是私有的-----------------//内部的数据是私有的(function () &#123;var num = 123;&#125;)()console.Log(num);//报错，num未定义。因为看不到自调用函数里面数据了-----------------(function()&#123;  //实现代码&#125;)()专业术语为: IIFE (Immediately Invoked Function Expression) 立即调用函数表达式                          </code></pre><h2 id="7-回调函数的理解△"><a href="#7-回调函数的理解△" class="headerlink" title="7). 回调函数的理解△"></a>7). 回调函数的理解△</h2><pre><code>1什么函数才是回调函数?    你定义的    你没有调用    但它最终执行了(在一定条件下 或某个时刻) 回头调用!!2常用的回调函数    dom事件回调函数(如按钮)    定时器回调函数    ajax请求回调函数(后面讲解)    生命周期回调函数(后面讲解)</code></pre><h1 id="git管理项目"><a href="#git管理项目" class="headerlink" title="git管理项目"></a>git管理项目</h1><h2 id="1-创建本地仓库"><a href="#1-创建本地仓库" class="headerlink" title="1). 创建本地仓库"></a>1). 创建本地仓库</h2><pre><code>创建.gitignore配置文件git initgit add *git commit -m &quot;xxx&quot;</code></pre><h2 id="2-创建github远程仓库"><a href="#2-创建github远程仓库" class="headerlink" title="2). 创建github远程仓库"></a>2). 创建github远程仓库</h2><pre><code>New Repository指定名称创建</code></pre><h2 id="3-将本地仓库推送到远程仓库"><a href="#3-将本地仓库推送到远程仓库" class="headerlink" title="3). 将本地仓库推送到远程仓库"></a>3). 将本地仓库推送到远程仓库</h2><pre><code>git remote add origin https://github.com/zxfjd3g/170612_JSAdvance.git 关联远程仓库git push origin master</code></pre><h2 id="4-push本地的更新"><a href="#4-push本地的更新" class="headerlink" title="4). push本地的更新"></a>4). push本地的更新</h2><pre><code>git add *git commit -m &quot;xxx&quot;git push origin master</code></pre><h2 id="5-克隆github上的项目"><a href="#5-克隆github上的项目" class="headerlink" title="5). 克隆github上的项目:"></a>5). 克隆github上的项目:</h2><pre><code>git clone https://github.com/zxfjd3g/170612_JSAdvance.git</code></pre><h2 id="6-pull远程的更新"><a href="#6-pull远程的更新" class="headerlink" title="6). pull远程的更新"></a>6). pull远程的更新</h2><pre><code>git pull origin master</code></pre><h2 id="7-撤消本地修改"><a href="#7-撤消本地修改" class="headerlink" title="7). 撤消本地修改"></a>7). 撤消本地修改</h2><pre><code>git status  查看变化git checkout -- xxx文件  撤消指定文件的修改</code></pre>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java各类的常用方法总结</title>
    <link href="/2021/08/29/Java-function/"/>
    <url>/2021/08/29/Java-function/</url>
    
    <content type="html"><![CDATA[<h1 id="1-Collection接口（List、Set）"><a href="#1-Collection接口（List、Set）" class="headerlink" title="1.Collection接口（List、Set）"></a>1.Collection接口（List、Set）</h1><p><a href="https://www.matools.com/api/java8">https://www.matools.com/api/java8</a></p><p><img src="/2021/08/29/Java-function/Collection.png" alt="img"></p><p>常用类：</p><p>ArrayList ，HashSet ， LinkedList ， PriorityQueue， Stack ， TreeSet ， Vector</p><table><thead><tr><th align="left">修饰符和类型</th><th align="left">方法及描述</th></tr></thead><tbody><tr><td align="left"><code>boolean</code></td><td align="left"><code>add(E e)</code>确保此集合包含指定的元素（可选操作）。</td></tr><tr><td align="left"><code>boolean</code></td><td align="left"><code>addAll(Collection&lt;? extends E&gt; c)</code>将指定集合中的所有元素添加到此集合（可选操作）。</td></tr><tr><td align="left"><code>void</code></td><td align="left"><code>clear()</code>从此集合中删除所有元素（可选操作）。</td></tr><tr><td align="left"><code>boolean</code></td><td align="left"><code>contains(Object o)</code>如果此集合包含指定的元素，则返回 <code>true</code> 。</td></tr><tr><td align="left"><code>boolean</code></td><td align="left"><code>containsAll(Collection&lt;?&gt; c)</code>如果此集合包含指定 <code>集合</code>中的所有元素，则返回true。</td></tr><tr><td align="left"><code>boolean</code></td><td align="left"><code>equals(Object o)</code>将指定的对象与此集合进行比较以获得相等性。</td></tr><tr><td align="left"><code>boolean</code></td><td align="left"><code>isEmpty()</code>如果此集合不包含元素，则返回 <code>true</code> 。</td></tr><tr><td align="left"><code>Iterator&lt;E&gt;</code></td><td align="left"><code>iterator()</code>返回此集合中的元素的迭代器。</td></tr><tr><td align="left"><code>boolean</code></td><td align="left"><code>remove(Object o)</code>从该集合中删除指定元素的单个实例（如果存在）（可选操作）。</td></tr><tr><td align="left"><code>boolean</code></td><td align="left"><code>removeAll(Collection&lt;?&gt; c)</code>删除指定集合中包含的所有此集合的元素（可选操作）。</td></tr><tr><td align="left"><code>int</code></td><td align="left"><code>size()</code>返回此集合中的元素数。</td></tr><tr><td align="left"><code>Object[]</code></td><td align="left"><code>toArray()</code>返回一个包含此集合中所有元素的数组。</td></tr></tbody></table><h2 id="1-List"><a href="#1-List" class="headerlink" title="1.List"></a>1.List</h2><table><thead><tr><th><code>void</code></th><th><code>add(int index, E element)</code>将指定的元素插入此列表中的指定位置（可选操作）。</th></tr></thead><tbody><tr><td><code>E</code></td><td><code>get(int index)</code>返回此列表中指定位置的元素。</td></tr><tr><td><code>int</code></td><td><code>indexOf(Object o)</code>返回此列表中指定元素的第一次出现的索引，如果此列表不包含元素，则返回-1。</td></tr><tr><td><code>E</code></td><td><code>set(int index, E element)</code>用指定的元素（可选操作）替换此列表中指定位置的元素。</td></tr><tr><td><code>default void</code></td><td><code>sort(Comparator&lt;? super E&gt; c)</code>使用随附的 <code>Comparator</code>排序此列表来比较元素。</td></tr><tr><td><code>List&lt;E&gt;</code></td><td><code>subList(int fromIndex, int toIndex)</code>返回此列表中指定的 <code>fromIndex</code> （含）和 <code>toIndex</code>之间的视图。</td></tr></tbody></table><h3 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h3><table><thead><tr><th><code>int</code></th><th><code>lastIndexOf(Object o)</code>返回此列表中指定元素的最后一次出现的索引，如果此列表不包含元素，则返回-1。</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><h3 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h3><table><thead><tr><th><code>void</code></th><th><code>addFirst(E e)</code>在该列表开头插入指定的元素。</th></tr></thead><tbody><tr><td><code>void</code></td><td><code>addLast(E e)</code>将指定的元素追加到此列表的末尾。</td></tr><tr><td><code>E</code></td><td><code>getFirst()</code>返回此列表中的第一个元素。</td></tr><tr><td><code>E</code></td><td><code>getLast()</code>返回此列表中的最后一个元素。</td></tr><tr><td><code>int</code></td><td><code>lastIndexOf(Object o)</code>返回此列表中指定元素的最后一次出现的索引，如果此列表不包含元素，则返回-1。</td></tr><tr><td><code>boolean</code></td><td><code>offer(E e)</code>将指定的元素添加为此列表的尾部（最后一个元素）。</td></tr><tr><td><code>boolean</code></td><td><code>offerFirst(E e)</code>在此列表的前面插入指定的元素。</td></tr><tr><td><code>boolean</code></td><td><code>offerLast(E e)</code>在该列表的末尾插入指定的元素。</td></tr><tr><td><code>E</code></td><td><code>peek()</code>检索但不删除此列表的头（第一个元素）。<br>//另有peekFirst()  peekLast()</td></tr><tr><td><code>E</code></td><td><code>poll()</code>检索并删除此列表的头（第一个元素）。<br>//pollFirst() pollLast()</td></tr><tr><td><code>E</code></td><td><code>pop()</code>从此列表表示的堆栈中弹出一个元素。</td></tr><tr><td><code>void</code></td><td><code>push(E e)</code>将元素推送到由此列表表示的堆栈上。</td></tr></tbody></table><h3 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h3><table><thead><tr><th align="left">Modifier and Type</th><th align="left">Method and Description</th></tr></thead><tbody><tr><td align="left"><code>boolean</code></td><td align="left"><code>empty()</code>测试此堆栈是否为空。</td></tr><tr><td align="left"><code>E</code></td><td align="left"><code>peek()</code>查看此堆栈顶部的对象，而不从堆栈中删除它。</td></tr><tr><td align="left"><code>E</code></td><td align="left"><code>pop()</code>删除此堆栈顶部的对象，并将该对象作为此函数的值返回。</td></tr><tr><td align="left"><code>E</code></td><td align="left"><code>push(E item)</code>将项目推送到此堆栈的顶部。</td></tr><tr><td align="left"><code>int</code></td><td align="left"><code>search(Object o)</code>返回一个对象在此堆栈上的基于1的位置。</td></tr></tbody></table><h2 id="2-Set-唯一值，无键-没什么特别的方法"><a href="#2-Set-唯一值，无键-没什么特别的方法" class="headerlink" title="2.Set 唯一值，无键(没什么特别的方法)"></a>2.Set 唯一值，无键(没什么特别的方法)</h2><h3 id="HashSet-没什么特别的方法，它所有的方法："><a href="#HashSet-没什么特别的方法，它所有的方法：" class="headerlink" title="HashSet 没什么特别的方法，它所有的方法："></a>HashSet 没什么特别的方法，它所有的方法：</h3><table><thead><tr><th align="left">Modifier and Type</th><th align="left">Method and Description</th></tr></thead><tbody><tr><td align="left"><code>boolean</code></td><td align="left"><code>add(E e)</code>将指定的元素添加到此集合（如果尚未存在）。</td></tr><tr><td align="left"><code>void</code></td><td align="left"><code>clear()</code>从此集合中删除所有元素。</td></tr><tr><td align="left"><code>Object</code></td><td align="left"><code>clone()</code>返回此 <code>HashSet</code>实例的浅层副本：元素本身不被克隆。</td></tr><tr><td align="left"><code>boolean</code></td><td align="left"><code>contains(Object o)</code>如果此集合包含指定的元素，则返回 <code>true</code> 。</td></tr><tr><td align="left"><code>boolean</code></td><td align="left"><code>isEmpty()</code>如果此集合不包含元素，则返回 <code>true</code> 。</td></tr><tr><td align="left"><code>Iterator&lt;E&gt;</code></td><td align="left"><code>iterator()</code>返回此集合中元素的迭代器。</td></tr><tr><td align="left"><code>boolean</code></td><td align="left"><code>remove(Object o)</code>如果存在，则从该集合中删除指定的元素。</td></tr><tr><td align="left"><code>int</code></td><td align="left"><code>size()</code>返回此集合中的元素数（其基数）。</td></tr></tbody></table><h3 id="TreeSet特别的方法（元素唯一，且按照顺序排序）"><a href="#TreeSet特别的方法（元素唯一，且按照顺序排序）" class="headerlink" title="TreeSet特别的方法（元素唯一，且按照顺序排序）"></a>TreeSet特别的方法（元素唯一，且按照顺序排序）</h3><table><thead><tr><th><code>E</code></th><th><code>first()</code>返回此集合中当前的第一个（最低）元素。</th></tr></thead><tbody><tr><td><code>E</code></td><td><code>floor(E e)</code>返回此集合中最大的元素小于或等于给定元素，如果没有这样的元素，则返回 <code>null</code> 。</td></tr><tr><td><code>E</code></td><td><code>last()</code>返回此集合中当前的最后（最高）元素。</td></tr><tr><td><code>E</code></td><td><code>lower(E e)</code>返回这个集合中最大的元素严格小于给定的元素，如果没有这样的元素，则返回 <code>null</code> 。</td></tr><tr><td><code>E</code></td><td><code>pollFirst()</code>检索并删除第一个（最低）元素，或返回 <code>null</code>如果该集合为空。</td></tr><tr><td><code>E</code></td><td><code>pollLast()</code>检索并删除最后一个（最高）元素，如果此集合为空，则返回 <code>null</code> 。</td></tr><tr><td><code>NavigableSet&lt;E&gt;</code></td><td><code>subSet(E fromElement, boolean fromInclusive, E toElement, boolean toInclusive)</code>返回该集合的部分的视图，其元素的范围从 <code>fromElement</code>到 <code>toElement</code> 。</td></tr><tr><td><code>SortedSet&lt;E&gt;</code></td><td><code>subSet(E fromElement, E toElement)</code>返回此集合的部分的视图，其元素的范围从 <code>fromElement</code> （含）到 <code>toElement</code> ，排他。</td></tr><tr><td><code>SortedSet&lt;E&gt;</code></td><td><code>tailSet(E fromElement)</code>返回此组件的元素大于或等于 <code>fromElement</code>的部分的视图。</td></tr><tr><td><code>NavigableSet&lt;E&gt;</code></td><td><code>tailSet(E fromElement, boolean inclusive)</code>返回此集合的部分的视图，其元素大于（或等于，如果 <code>inclusive</code>为真） <code>fromElement</code> 。</td></tr></tbody></table><h1 id="2-Queue"><a href="#2-Queue" class="headerlink" title="2.Queue"></a>2.Queue</h1><table><thead><tr><th><code>boolean</code></th><th><code>add(E e)</code>将指定的元素插入到此队列中，如果可以立即执行此操作，而不会违反容量限制， <code>true</code>在成功后返回 <code>IllegalStateException</code>如果当前没有可用空间，则抛出IllegalStateException。</th></tr></thead><tbody><tr><td><code>E</code></td><td><code>element()</code>检索，但不删除，这个队列的头。</td></tr><tr><td><code>boolean</code></td><td><code>offer(E e)</code>如果在不违反容量限制的情况下立即执行，则将指定的元素插入到此队列中。</td></tr><tr><td><code>E</code></td><td><code>peek()</code>检索但不删除此队列的头，如果此队列为空，则返回 <code>null</code> 。</td></tr><tr><td><code>E</code></td><td><code>poll()</code>检索并删除此队列的头，如果此队列为空，则返回 <code>null</code> 。</td></tr><tr><td><code>E</code></td><td><code>remove()</code>检索并删除此队列的头。</td></tr></tbody></table><h2 id="1-PriorityQueue"><a href="#1-PriorityQueue" class="headerlink" title="1.PriorityQueue"></a>1.PriorityQueue</h2><table><thead><tr><th><code>boolean</code></th><th><code>add(E e)</code>将指定的元素插入到此优先级队列中。</th></tr></thead><tbody><tr><td><code>void</code></td><td><code>clear()</code>从此优先级队列中删除所有元素。</td></tr><tr><td><code>Comparator&lt;? super E&gt;</code></td><td><code>comparator()</code>返回用于为了在这个队列中的元素，或比较<code>null</code>如果此队列根据所述排序<a href="https://www.matools.com/file/manual/jdk_api_1.8_google/java/lang/Comparable.html">natural ordering</a>的元素。</td></tr><tr><td><code>boolean</code></td><td><code>contains(Object o)</code>如果此队列包含指定的元素，则返回 <code>true</code> 。</td></tr><tr><td><code>Iterator&lt;E&gt;</code></td><td><code>iterator()</code>返回此队列中的元素的迭代器。</td></tr><tr><td><code>boolean</code></td><td><code>offer(E e)</code>将指定的元素插入到此优先级队列中。</td></tr><tr><td><code>int</code></td><td><code>size()</code>返回此集合中的元素数。</td></tr><tr><td><code>Object[]</code></td><td><code>toArray()</code>返回一个包含此队列中所有元素的数组。</td></tr><tr><td><code>&lt;T&gt; T[]</code></td><td><code>toArray(T[] a)</code>返回一个包含此队列中所有元素的数组; 返回的数组的运行时类型是指定数组的运行时类型。</td></tr></tbody></table><h2 id="2-Deque"><a href="#2-Deque" class="headerlink" title="2.Deque"></a>2.Deque</h2><table><thead><tr><th>addLast(E e) / offerLast(E e)</th><th>添加元素到队尾</th></tr></thead><tbody><tr><td>E removeFirst() / E pollFirst()</td><td>取队首元素并删除</td></tr><tr><td>E getFirst() / E peekFirst()</td><td>取队首元素但不删除</td></tr><tr><td>addFirst(E e) / offerFirst(E e)</td><td>添加元素到队首</td></tr><tr><td>E removeLast() / E pollLast()</td><td>取队尾元素并删除</td></tr><tr><td>E getLast() / E peekLast()</td><td>取队尾元素但不删除</td></tr></tbody></table><h1 id="3-Map接口（HashMap、TreeMap）"><a href="#3-Map接口（HashMap、TreeMap）" class="headerlink" title="3.Map接口（HashMap、TreeMap）"></a>3.Map接口（HashMap、TreeMap）</h1><p><img src="/2021/08/29/Java-function/Map.png" alt="img"></p><table><thead><tr><th align="left">Modifier and Type</th><th align="left">Method and Description</th></tr></thead><tbody><tr><td align="left"><code>void</code></td><td align="left"><code>clear()</code>从该地图中删除所有的映射（可选操作）。</td></tr><tr><td align="left"><code>boolean</code></td><td align="left"><code>containsKey(Object key)</code>如果此映射包含指定键的映射，则返回 <code>true</code> 。</td></tr><tr><td align="left"><code>boolean</code></td><td align="left"><code>containsValue(Object value)</code>如果此地图将一个或多个键映射到指定的值，则返回 <code>true</code> 。</td></tr><tr><td align="left"><code>boolean</code></td><td align="left"><code>equals(Object o)</code>将指定的对象与此映射进行比较以获得相等性。</td></tr><tr><td align="left"><code>default void</code></td><td align="left"><code>forEach(BiConsumer&lt;? super K,? super V&gt; action)</code>对此映射中的每个条目执行给定的操作，直到所有条目都被处理或操作引发异常。</td></tr><tr><td align="left"><code>V</code></td><td align="left"><code>get(Object key)</code>返回到指定键所映射的值，或 <code>null</code>如果此映射包含该键的映射。</td></tr><tr><td align="left"><code>default V</code></td><td align="left"><code>getOrDefault(Object key, V defaultValue)</code>返回到指定键所映射的值，或 <code>defaultValue</code>如果此映射包含该键的映射。</td></tr><tr><td align="left"><code>boolean</code></td><td align="left"><code>isEmpty()</code>如果此地图不包含键值映射，则返回 <code>true</code> 。</td></tr><tr><td align="left"><code>V</code></td><td align="left"><code>put(K key, V value)</code>将指定的值与该映射中的指定键相关联（可选操作）。</td></tr><tr><td align="left"><code>void</code></td><td align="left"><code>putAll(Map&lt;? extends K,? extends V&gt; m)</code>将指定地图的所有映射复制到此映射（可选操作）。</td></tr><tr><td align="left"><code>default V</code></td><td align="left"><code>putIfAbsent(K key, V value)</code>如果指定的键尚未与某个值相关联（或映射到 <code>null</code> ）将其与给定值相关联并返回 <code>null</code> ，否则返回当前值。</td></tr><tr><td align="left"><code>V</code></td><td align="left"><code>remove(Object key)</code>如果存在（从可选的操作），从该地图中删除一个键的映射。</td></tr><tr><td align="left"><code>default V</code></td><td align="left"><code>replace(K key, V value)</code>只有当目标映射到某个值时，才能替换指定键的条目。</td></tr><tr><td align="left"><code>default boolean</code></td><td align="left"><code>replace(K key, V oldValue, V newValue)</code>仅当当前映射到指定的值时，才能替换指定键的条目。</td></tr><tr><td align="left"><code>default void</code></td><td align="left"><code>replaceAll(BiFunction&lt;? super K,? super V,? extends V&gt; function)</code>将每个条目的值替换为对该条目调用给定函数的结果，直到所有条目都被处理或该函数抛出异常。</td></tr><tr><td align="left"><code>int</code></td><td align="left"><code>size()</code>返回此地图中键值映射的数量。</td></tr></tbody></table><h2 id="HashMap-没什么特别的方法"><a href="#HashMap-没什么特别的方法" class="headerlink" title="HashMap 没什么特别的方法"></a>HashMap 没什么特别的方法</h2><h2 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h2><table><thead><tr><th align="left">Modifier and Type</th><th align="left">Method and Description</th></tr></thead><tbody><tr><td align="left"><code>Map.Entry&lt;K,V&gt;</code></td><td align="left"><code>ceilingEntry(K key)</code>返回与大于或等于给定键的最小键相关联的键值映射，如果没有此键，则 <code>null</code> 。</td></tr><tr><td align="left"><code>K</code></td><td align="left"><code>ceilingKey(K key)</code>返回大于或等于给定键的 <code>null</code>键，如果没有此键，则返回 <code>null</code> 。</td></tr><tr><td align="left"><code>Comparator&lt;? super K&gt;</code></td><td align="left"><code>comparator()</code>返回用于订购此地图中的键的比较器，或<code>null</code>如果此地图使用其键的<a href="https://www.matools.com/file/manual/jdk_api_1.8_google/java/lang/Comparable.html">natural ordering</a> 。</td></tr><tr><td align="left"><code>NavigableSet&lt;K&gt;</code></td><td align="left"><code>descendingKeySet()</code>返回此地图中包含的键的相反顺序<a href="https://www.matools.com/file/manual/jdk_api_1.8_google/java/util/NavigableSet.html"><code>NavigableSet</code></a> 。</td></tr><tr><td align="left"><code>NavigableMap&lt;K,V&gt;</code></td><td align="left"><code>descendingMap()</code>返回此映射中包含的映射的反向排序视图。</td></tr><tr><td align="left"><code>Map.Entry&lt;K,V&gt;</code></td><td align="left"><code>firstEntry()</code>返回与该地图中的最小键相关联的键值映射，如果地图为空，则返回 <code>null</code> 。</td></tr><tr><td align="left"><code>K</code></td><td align="left"><code>firstKey()</code>返回此地图中当前的第一个（最低）键。</td></tr><tr><td align="left"><code>Map.Entry&lt;K,V&gt;</code></td><td align="left"><code>floorEntry(K key)</code>返回与小于或等于给定键的最大键相关联的键值映射，如果没有此键，则 <code>null</code> 。</td></tr><tr><td align="left"><code>K</code></td><td align="left"><code>floorKey(K key)</code>返回小于或等于给定键的最大键，如果没有这样的键，则返回 <code>null</code> 。</td></tr><tr><td align="left"><code>void</code></td><td align="left"><code>forEach(BiConsumer&lt;? super K,? super V&gt; action)</code>对此映射中的每个条目执行给定的操作，直到所有条目都被处理或操作引发异常。</td></tr><tr><td align="left"><code>V</code></td><td align="left"><code>get(Object key)</code>返回到指定键所映射的值，或 <code>null</code>如果此映射包含该键的映射。</td></tr><tr><td align="left"><code>Map.Entry&lt;K,V&gt;</code></td><td align="left"><code>higherEntry(K key)</code>返回与最小密钥相关联的密钥值映射严格大于给定密钥，如果没有这样的密钥则 <code>null</code> 。</td></tr><tr><td align="left"><code>K</code></td><td align="left"><code>higherKey(K key)</code>返回严格大于给定键的最小键，如果没有这样的键，则返回 <code>null</code> 。</td></tr><tr><td align="left"><code>Map.Entry&lt;K,V&gt;</code></td><td align="left"><code>lastEntry()</code>返回与该地图中最大关键字关联的键值映射，如果地图为空，则返回 <code>null</code> 。</td></tr><tr><td align="left"><code>K</code></td><td align="left"><code>lastKey()</code>返回当前在此地图中的最后（最高）键。</td></tr><tr><td align="left"><code>Map.Entry&lt;K,V&gt;</code></td><td align="left"><code>lowerEntry(K key)</code>返回与最大密钥相关联的密钥值映射严格小于给定密钥，如果没有这样的密钥，则 <code>null</code> 。</td></tr><tr><td align="left"><code>K</code></td><td align="left"><code>lowerKey(K key)</code>返回严格小于给定键的最大键，如果没有这样的键，则返回 <code>null</code> 。</td></tr><tr><td align="left"><code>Map.Entry&lt;K,V&gt;</code></td><td align="left"><code>pollFirstEntry()</code>删除并返回与该地图中的最小键相关联的键值映射，如果地图为空，则返回 <code>null</code> 。</td></tr><tr><td align="left"><code>Map.Entry&lt;K,V&gt;</code></td><td align="left"><code>pollLastEntry()</code>删除并返回与该地图中最大密钥相关联的键值映射，如果地图为空，则返回 <code>null</code> 。</td></tr><tr><td align="left"><code>V</code></td><td align="left"><code>put(K key, V value)</code>将指定的值与此映射中的指定键相关联。</td></tr><tr><td align="left"><code>void</code></td><td align="left"><code>putAll(Map&lt;? extends K,? extends V&gt; map)</code>将指定地图的所有映射复制到此地图。</td></tr><tr><td align="left"><code>V</code></td><td align="left"><code>remove(Object key)</code>从此TreeMap中删除此键的映射（如果存在）。</td></tr><tr><td align="left"><code>V</code></td><td align="left"><code>replace(K key, V value)</code>只有当目标映射到某个值时，才能替换指定键的条目。</td></tr><tr><td align="left"><code>boolean</code></td><td align="left"><code>replace(K key, V oldValue, V newValue)</code>仅当当前映射到指定的值时，才能替换指定键的条目。</td></tr><tr><td align="left"><code>void</code></td><td align="left"><code>replaceAll(BiFunction&lt;? super K,? super V,? extends V&gt; function)</code>将每个条目的值替换为对该条目调用给定函数的结果，直到所有条目都被处理或该函数抛出异常。</td></tr><tr><td align="left"><code>int</code></td><td align="left"><code>size()</code>返回此地图中键值映射的数量。</td></tr><tr><td align="left"><code>NavigableMap&lt;K,V&gt;</code></td><td align="left"><code>subMap(K fromKey, boolean fromInclusive, K toKey, boolean toInclusive)</code>返回此地图部分的视图，其关键范围为 <code>fromKey</code>至 <code>toKey</code> 。</td></tr><tr><td align="left"><code>SortedMap&lt;K,V&gt;</code></td><td align="left"><code>subMap(K fromKey, K toKey)</code>返回此地图部分的视图，其关键字范围从 <code>fromKey</code> （含）到 <code>toKey</code> ，独占。</td></tr><tr><td align="left"><code>SortedMap&lt;K,V&gt;</code></td><td align="left"><code>tailMap(K fromKey)</code>返回此地图部分的视图，其键大于等于 <code>fromKey</code> 。</td></tr><tr><td align="left"><code>NavigableMap&lt;K,V&gt;</code></td><td align="left"><code>tailMap(K fromKey, boolean inclusive)</code>返回此地图部分的视图，其键大于（或等于，如果 <code>inclusive</code>为真） <code>fromKey</code> 。</td></tr></tbody></table><h1 id="4-Object"><a href="#4-Object" class="headerlink" title="4.Object"></a>4.Object</h1><table><thead><tr><th><code>static String</code></th><th><code>toString(xx)</code>返回指定数组的内容的字符串表示形式。</th></tr></thead><tbody><tr><td>以下都有</td><td>这个方法</td></tr></tbody></table><h2 id="Number"><a href="#Number" class="headerlink" title="Number"></a>Number</h2><h3 id="Integer（另有Float、Double…不全写了）"><a href="#Integer（另有Float、Double…不全写了）" class="headerlink" title="Integer（另有Float、Double…不全写了）"></a>Integer（另有Float、Double…不全写了）</h3><table><thead><tr><th><code>static int</code></th><th><code>compare(int x, int y)</code>比较两个 <code>int</code>数字值。</th></tr></thead><tbody><tr><td><code>int</code></td><td><code>compareTo(Integer anotherInteger)</code>数字比较两个 <code>Integer</code>对象。</td></tr><tr><td><code>boolean</code></td><td><code>equals(Object obj)</code>将此对象与指定的对象进行比较。</td></tr><tr><td><code>static int</code></td><td><code>max(int a, int b)</code>返回两个 <code>int</code>的较大值，就像调用 <a href="https://www.matools.com/file/manual/jdk_api_1.8_google/java/lang/Math.html#max-int-int-"><code>Math.max</code>一样</a> 。</td></tr><tr><td><code>static int</code></td><td><code>min(int a, int b)</code>返回两个 <code>int</code>的较小值，就像调用 <a href="https://www.matools.com/file/manual/jdk_api_1.8_google/java/lang/Math.html#min-int-int-"><code>Math.min</code>一样</a> 。</td></tr><tr><td><code>static int</code></td><td><code>parseInt(String s)</code>将字符串参数解析为带符号的十进制整数。</td></tr><tr><td><code>static Integer</code></td><td><code>valueOf(int i)</code>返回一个 <code>Integer</code>指定的 <code>int</code>值的 <code>Integer</code>实例。</td></tr><tr><td><code>static Integer</code></td><td><code>valueOf(String s)</code>返回一个 <code>Integer</code>对象，保存指定的值为 <code>String</code> 。</td></tr></tbody></table><h2 id="Character"><a href="#Character" class="headerlink" title="Character"></a>Character</h2><table><thead><tr><th><code>static char</code></th><th><code>toUpperCase(char ch)</code>将字符参数转换为大写。</th></tr></thead><tbody><tr><td><code>static Character</code></td><td><code>valueOf(char c)</code>返回一个 <code>表示</code>指定的 <code>char</code>值的 <code>Character</code>实例。</td></tr><tr><td><code>int</code></td><td><code>compareTo(Character anotherCharacter)</code>数字比较两个 <code>Character</code>对象。</td></tr><tr><td><code>static int</code></td><td><code>compare(char x, char y)</code>数值比较两个 <code>char</code>数值。</td></tr><tr><td><code>boolean</code></td><td><code>equals(Object obj)</code>将此对象与指定对象进行比较。</td></tr></tbody></table><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><table><thead><tr><th><code>char</code></th><th><code>charAt(int index)</code>返回 <code>char</code>指定索引处的值。</th></tr></thead><tbody><tr><td><code>int</code></td><td><code>compareTo(String anotherString)</code>按字典顺序比较两个字符串。</td></tr><tr><td><code>String</code></td><td><code>concat(String str)</code>将指定的字符串连接到该字符串的末尾。</td></tr><tr><td><code>boolean</code></td><td><code>contains(CharSequence s)</code>当且仅当此字符串包含指定的char值序列时才返回true。（可以检测是否包含字符串）</td></tr><tr><td><code>boolean</code></td><td><code>equals(Object anObject)</code>将此字符串与指定对象进行比较。</td></tr><tr><td><code>int</code></td><td><code>indexOf(int ch)</code>返回指定字符第一次出现的字符串内的索引。</td></tr><tr><td><code>int</code></td><td><code>indexOf(int ch, int fromIndex)</code>返回指定字符第一次出现的字符串内的索引，以指定的索引开始搜索。</td></tr><tr><td><code>boolean</code></td><td><code>isEmpty()</code>返回 <code>true</code>如果，且仅当 <a href="https://www.matools.com/file/manual/jdk_api_1.8_google/java/lang/String.html#length--"><code>length()</code></a>为 <code>0</code> 。</td></tr><tr><td><code>int</code></td><td><code>lastIndexOf(int ch)</code>返回指定字符的最后一次出现的字符串中的索引。</td></tr><tr><td><code>String</code></td><td><code>replace(char oldChar, char newChar)</code>返回从替换所有出现的导致一个字符串 <code>oldChar</code>在此字符串 <code>newChar</code> 。</td></tr><tr><td><code>String</code></td><td><code>replaceAll(String regex, String replacement)</code>用给定的替换替换与给定的 <a href="https://www.matools.com/file/manual/jdk_api_1.8_google/java/util/regex/Pattern.html#sum">regular expression</a>匹配的此字符串的每个子字符串。</td></tr><tr><td><code>String[]</code></td><td><code>split(String regex)</code>将此字符串分割为给定的 <a href="https://www.matools.com/file/manual/jdk_api_1.8_google/java/util/regex/Pattern.html#sum">regular expression的</a>匹配。</td></tr><tr><td><code>char[]</code></td><td><code>toCharArray()</code>将此字符串转换为新的字符数组。</td></tr><tr><td><code>String</code></td><td><code>toLowerCase()</code>将所有在此字符 <code>String</code>使用默认语言环境的规则，以小写。/<strong><a href="https://www.matools.com/file/manual/jdk_api_1.8_google/java/lang/String.html#toUpperCase--">toUpperCase</a></strong>()大写</td></tr><tr><td><code>String</code></td><td><strong><a href="https://www.matools.com/file/manual/jdk_api_1.8_google/java/lang/String.html#valueOf-boolean-">valueOf</a></strong>(boolean b)(char c)….  返回 <code>xx</code>参数的字符串 <code>xx</code>形式。</td></tr><tr><td><code>String</code></td><td><code>substring(int beginIndex, int endIndex)</code>返回一个字符串，该字符串是此字符串的子字符串。endIndex不包括。</td></tr><tr><td><code>CharSequence</code></td><td><code>subSequence(int beginIndex, int endIndex)</code>返回一个字符序列，该序列是该序列的子序列。</td></tr></tbody></table><h2 id="StringBuilder"><a href="#StringBuilder" class="headerlink" title="StringBuilder"></a>StringBuilder</h2><p>比 StringBuffer更常用，后者在安全线程里更常用</p><table><thead><tr><th><code>StringBuilder</code></th><th><code>append()</code>将 各种类型的参数 加到序列中。</th></tr></thead><tbody><tr><td><code>char</code></td><td><code>charAt(int index)</code>返回 <code>char</code>在指定索引在这个序列值。</td></tr><tr><td><code>StringBuilder</code></td><td><code>delete(int start, int end)</code>删除此序列的子字符串中的字符。</td></tr><tr><td><code>StringBuilder</code></td><td><code>deleteCharAt(int index)</code>删除 <code>char</code>在这个序列中的指定位置。</td></tr><tr><td><code>void</code></td><td><code>getChars(int srcBegin, int srcEnd, char[] dst, int dstBegin)</code>字符从该序列复制到目标字符数组 <code>dst</code> 。</td></tr><tr><td><code>int</code></td><td><code>indexOf(String str)</code>返回指定子字符串第一次出现的字符串内的索引。</td></tr><tr><td><code>int</code></td><td><code>indexOf(String str, int fromIndex)</code>返回指定子串的第一次出现的字符串中的索引，从指定的索引开始。</td></tr><tr><td><code>StringBuilder</code></td><td><code>insert(int offset, xx)</code>将 xx参数的字符串表示插入到此序列中。offset 偏移量</td></tr><tr><td><code>int</code></td><td><code>lastIndexOf(String str)</code>返回指定子字符串最右边出现的字符串内的索引。</td></tr><tr><td><code>StringBuilder</code></td><td><code>replace(int start, int end, String str)</code>用指定的String中的字符替换此序列的子字符串中的 <code>String</code> 。</td></tr><tr><td><code>StringBuilder</code></td><td><code>reverse()</code>导致该字符序列被序列的相反代替。</td></tr><tr><td><code>void</code></td><td><code>setCharAt(int index, char ch)</code>指定索引处的字符设置为 <code>ch</code> 。</td></tr><tr><td><code>void</code></td><td><code>setLength(int newLength)</code>设置字符序列的长度。</td></tr><tr><td><code>CharSequence</code></td><td><code>subSequence(int start, int end)</code>返回一个新的字符序列，该序列是该序列的子序列。</td></tr><tr><td><code>String</code></td><td><code>substring(int start, int end)</code>返回一个新的 <code>String</code> ，其中包含此序列中当前包含的字符的子序列。</td></tr><tr><td><code>String</code></td><td><code>toString()</code>返回表示此顺序中的数据的字符串。</td></tr></tbody></table><h2 id="Array数组"><a href="#Array数组" class="headerlink" title="Array数组"></a>Array数组</h2><p><code>Array</code>类提供静态方法来动态创建和访问Java数组。</p><table><thead><tr><th>4</th><th><strong>public static void sort(Object[] a)</strong> （？？？有无此方法？）<br>对指定对象数组根据其元素的自然顺序进行升序排列。同样的方法适用于所有的其他基本数据类型（Byte，short，Int等）。</th></tr></thead><tbody><tr><td><code>static Object</code></td><td><code>get(Object array, int index)</code>返回指定数组对象中的索引组件的值。</td></tr><tr><td><code>static void</code></td><td><code>set(Object array, int index, Object value)</code>将指定数组对象的索引组件的值设置为指定的新值。</td></tr></tbody></table><h2 id="Arrays"><a href="#Arrays" class="headerlink" title="Arrays"></a>Arrays</h2><p>该类包含用于操作数组的各种方法（如排序和搜索）。</p><table><thead><tr><th><code>static &lt;T&gt; List&lt;T&gt;</code></th><th><code>asList(T... a)</code>返回由指定数组支持的固定大小的列表。</th></tr></thead><tbody><tr><td><code>static boolean</code></td><td><code>equals(xx, xx)</code>如果两个指定的xx数组彼此 <em>相等</em> ，则返回 <code>true</code> 。</td></tr><tr><td><code>static void</code></td><td><code>fill(xx, xxxx)</code>将指定的xxxx值分配给指定的xx数组的每个元素。</td></tr><tr><td><code>static void</code></td><td><code>sort(xx)</code>按照xx顺序排列指定的数组。xx：一些基本数据类型</td></tr></tbody></table><h2 id="Scanner"><a href="#Scanner" class="headerlink" title="Scanner"></a>Scanner</h2><table><thead><tr><th>String nextLine()</th><th>返回一行字符串</th></tr></thead><tbody><tr><td>next()</td><td>返回一字符串，以空格结束</td></tr><tr><td>int NextInt()</td><td>读下一个（行）整数</td></tr><tr><td>NextFloat()</td><td></td></tr><tr><td>NextDouble()</td><td></td></tr><tr><td>hasnext()</td><td>返回是否还有下一个</td></tr><tr><td>hasnextLine()</td><td>返回是否还有下一行</td></tr><tr><td>hasNextInt()</td><td></td></tr><tr><td>hasNextFloat()</td><td></td></tr><tr><td>hasNextDouble()</td><td></td></tr><tr><td><code>void</code></td><td><code>close()</code>关闭此扫描仪。</td></tr></tbody></table><h2 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h2><table><thead><tr><th><code>static int</code></th><th><code>abs(int a)</code>返回值为 <code>int</code>绝对值。</th></tr></thead><tbody><tr><td><code>static double</code></td><td><code>exp(double a)</code>返回欧拉的数字 <em>e</em>提高到一个 <code>double</code>价值。</td></tr><tr><td><code>static double</code></td><td><code>floor(double a)</code>返回小于或等于参数的最大（最接近正无穷大） <code>double</code>值，等于一个数学整数。</td></tr><tr><td><code>static int</code></td><td><code>max(int a, int b)</code>返回两个 <code>int</code>值中的较大值。</td></tr><tr><td><code>static int</code></td><td><code>min(int a, int b)</code>返回两个 <code>int</code>的较小值。</td></tr><tr><td><code>static double</code></td><td><code>pow(double a, double b)</code>将第一个参数的值返回到第二个参数的幂。</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>常用 Git 命令清单</title>
    <link href="/2021/08/07/Git/"/>
    <url>/2021/08/07/Git/</url>
    
    <content type="html"><![CDATA[<p>一般来说，日常使用只要记住下图6个命令，就可以了。但是熟练使用，恐怕要记住60～100个命令。</p><p><img src="https://www.ruanyifeng.com/blogimg/asset/2015/bg2015120901.png" alt="img"><br>下面是常用 Git 命令清单。几个专用名词的译名如下。</p><p>Workspace：工作区<br>Index / Stage：暂存区<br>Repository：仓库区（或本地仓库）<br>Remote：远程仓库</p><p>一、新建代码库</p><h1 id="在当前目录新建一个Git代码库"><a href="#在当前目录新建一个Git代码库" class="headerlink" title="在当前目录新建一个Git代码库"></a>在当前目录新建一个Git代码库</h1><p>$ git init</p><h1 id="新建一个目录，将其初始化为Git代码库"><a href="#新建一个目录，将其初始化为Git代码库" class="headerlink" title="新建一个目录，将其初始化为Git代码库"></a>新建一个目录，将其初始化为Git代码库</h1><p>$ git init [project-name]</p><h1 id="下载一个项目和它的整个代码历史"><a href="#下载一个项目和它的整个代码历史" class="headerlink" title="下载一个项目和它的整个代码历史"></a>下载一个项目和它的整个代码历史</h1><p>$ git clone [url]<br>二、配置<br>Git的设置文件为.gitconfig，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。</p><h1 id="显示当前的Git配置"><a href="#显示当前的Git配置" class="headerlink" title="显示当前的Git配置"></a>显示当前的Git配置</h1><p>$ git config –list</p><h1 id="编辑Git配置文件"><a href="#编辑Git配置文件" class="headerlink" title="编辑Git配置文件"></a>编辑Git配置文件</h1><p>$ git config -e [–global]</p><h1 id="设置提交代码时的用户信息"><a href="#设置提交代码时的用户信息" class="headerlink" title="设置提交代码时的用户信息"></a>设置提交代码时的用户信息</h1><p>$ git config [–global] user.name “[name]”<br>$ git config [–global] user.email “[email address]”<br>三、增加/删除文件</p><h1 id="添加指定文件到暂存区"><a href="#添加指定文件到暂存区" class="headerlink" title="添加指定文件到暂存区"></a>添加指定文件到暂存区</h1><p>$ git add [file1] [file2] …</p><h1 id="添加指定目录到暂存区，包括子目录"><a href="#添加指定目录到暂存区，包括子目录" class="headerlink" title="添加指定目录到暂存区，包括子目录"></a>添加指定目录到暂存区，包括子目录</h1><p>$ git add [dir]</p><h1 id="添加当前目录的所有文件到暂存区"><a href="#添加当前目录的所有文件到暂存区" class="headerlink" title="添加当前目录的所有文件到暂存区"></a>添加当前目录的所有文件到暂存区</h1><p>$ git add .</p><h1 id="添加每个变化前，都会要求确认"><a href="#添加每个变化前，都会要求确认" class="headerlink" title="添加每个变化前，都会要求确认"></a>添加每个变化前，都会要求确认</h1><h1 id="对于同一个文件的多处变化，可以实现分次提交"><a href="#对于同一个文件的多处变化，可以实现分次提交" class="headerlink" title="对于同一个文件的多处变化，可以实现分次提交"></a>对于同一个文件的多处变化，可以实现分次提交</h1><p>$ git add -p</p><h1 id="删除工作区文件，并且将这次删除放入暂存区"><a href="#删除工作区文件，并且将这次删除放入暂存区" class="headerlink" title="删除工作区文件，并且将这次删除放入暂存区"></a>删除工作区文件，并且将这次删除放入暂存区</h1><p>$ git rm [file1] [file2] …</p><h1 id="停止追踪指定文件，但该文件会保留在工作区"><a href="#停止追踪指定文件，但该文件会保留在工作区" class="headerlink" title="停止追踪指定文件，但该文件会保留在工作区"></a>停止追踪指定文件，但该文件会保留在工作区</h1><p>$ git rm –cached [file]</p><h1 id="改名文件，并且将这个改名放入暂存区"><a href="#改名文件，并且将这个改名放入暂存区" class="headerlink" title="改名文件，并且将这个改名放入暂存区"></a>改名文件，并且将这个改名放入暂存区</h1><p>$ git mv [file-original] [file-renamed]<br>四、代码提交</p><h1 id="提交暂存区到仓库区"><a href="#提交暂存区到仓库区" class="headerlink" title="提交暂存区到仓库区"></a>提交暂存区到仓库区</h1><p>$ git commit -m [message]</p><h1 id="提交暂存区的指定文件到仓库区"><a href="#提交暂存区的指定文件到仓库区" class="headerlink" title="提交暂存区的指定文件到仓库区"></a>提交暂存区的指定文件到仓库区</h1><p>$ git commit [file1] [file2] … -m [message]</p><h1 id="提交工作区自上次commit之后的变化，直接到仓库区"><a href="#提交工作区自上次commit之后的变化，直接到仓库区" class="headerlink" title="提交工作区自上次commit之后的变化，直接到仓库区"></a>提交工作区自上次commit之后的变化，直接到仓库区</h1><p>$ git commit -a</p><h1 id="提交时显示所有diff信息"><a href="#提交时显示所有diff信息" class="headerlink" title="提交时显示所有diff信息"></a>提交时显示所有diff信息</h1><p>$ git commit -v</p><h1 id="使用一次新的commit，替代上一次提交"><a href="#使用一次新的commit，替代上一次提交" class="headerlink" title="使用一次新的commit，替代上一次提交"></a>使用一次新的commit，替代上一次提交</h1><h1 id="如果代码没有任何新变化，则用来改写上一次commit的提交信息"><a href="#如果代码没有任何新变化，则用来改写上一次commit的提交信息" class="headerlink" title="如果代码没有任何新变化，则用来改写上一次commit的提交信息"></a>如果代码没有任何新变化，则用来改写上一次commit的提交信息</h1><p>$ git commit –amend -m [message]</p><h1 id="重做上一次commit，并包括指定文件的新变化"><a href="#重做上一次commit，并包括指定文件的新变化" class="headerlink" title="重做上一次commit，并包括指定文件的新变化"></a>重做上一次commit，并包括指定文件的新变化</h1><p>$ git commit –amend [file1] [file2] …<br>五、分支</p><h1 id="列出所有本地分支"><a href="#列出所有本地分支" class="headerlink" title="列出所有本地分支"></a>列出所有本地分支</h1><p>$ git branch</p><h1 id="列出所有远程分支"><a href="#列出所有远程分支" class="headerlink" title="列出所有远程分支"></a>列出所有远程分支</h1><p>$ git branch -r</p><h1 id="列出所有本地分支和远程分支"><a href="#列出所有本地分支和远程分支" class="headerlink" title="列出所有本地分支和远程分支"></a>列出所有本地分支和远程分支</h1><p>$ git branch -a</p><h1 id="新建一个分支，但依然停留在当前分支"><a href="#新建一个分支，但依然停留在当前分支" class="headerlink" title="新建一个分支，但依然停留在当前分支"></a>新建一个分支，但依然停留在当前分支</h1><p>$ git branch [branch-name]</p><h1 id="新建一个分支，并切换到该分支"><a href="#新建一个分支，并切换到该分支" class="headerlink" title="新建一个分支，并切换到该分支"></a>新建一个分支，并切换到该分支</h1><p>$ git checkout -b [branch]</p><h1 id="新建一个分支，指向指定commit"><a href="#新建一个分支，指向指定commit" class="headerlink" title="新建一个分支，指向指定commit"></a>新建一个分支，指向指定commit</h1><p>$ git branch [branch] [commit]</p><h1 id="新建一个分支，与指定的远程分支建立追踪关系"><a href="#新建一个分支，与指定的远程分支建立追踪关系" class="headerlink" title="新建一个分支，与指定的远程分支建立追踪关系"></a>新建一个分支，与指定的远程分支建立追踪关系</h1><p>$ git branch –track [branch] [remote-branch]</p><h1 id="切换到指定分支，并更新工作区"><a href="#切换到指定分支，并更新工作区" class="headerlink" title="切换到指定分支，并更新工作区"></a>切换到指定分支，并更新工作区</h1><p>$ git checkout [branch-name]</p><h1 id="切换到上一个分支"><a href="#切换到上一个分支" class="headerlink" title="切换到上一个分支"></a>切换到上一个分支</h1><p>$ git checkout -</p><h1 id="建立追踪关系，在现有分支与指定的远程分支之间"><a href="#建立追踪关系，在现有分支与指定的远程分支之间" class="headerlink" title="建立追踪关系，在现有分支与指定的远程分支之间"></a>建立追踪关系，在现有分支与指定的远程分支之间</h1><p>$ git branch –set-upstream [branch] [remote-branch]</p><h1 id="合并指定分支到当前分支"><a href="#合并指定分支到当前分支" class="headerlink" title="合并指定分支到当前分支"></a>合并指定分支到当前分支</h1><p>$ git merge [branch]</p><h1 id="选择一个commit，合并进当前分支"><a href="#选择一个commit，合并进当前分支" class="headerlink" title="选择一个commit，合并进当前分支"></a>选择一个commit，合并进当前分支</h1><p>$ git cherry-pick [commit]</p><h1 id="删除分支"><a href="#删除分支" class="headerlink" title="删除分支"></a>删除分支</h1><p>$ git branch -d [branch-name]</p><h1 id="删除远程分支"><a href="#删除远程分支" class="headerlink" title="删除远程分支"></a>删除远程分支</h1><p>$ git push origin –delete [branch-name]<br>$ git branch -dr [remote/branch]<br>六、标签</p><h1 id="列出所有tag"><a href="#列出所有tag" class="headerlink" title="列出所有tag"></a>列出所有tag</h1><p>$ git tag</p><h1 id="新建一个tag在当前commit"><a href="#新建一个tag在当前commit" class="headerlink" title="新建一个tag在当前commit"></a>新建一个tag在当前commit</h1><p>$ git tag [tag]</p><h1 id="新建一个tag在指定commit"><a href="#新建一个tag在指定commit" class="headerlink" title="新建一个tag在指定commit"></a>新建一个tag在指定commit</h1><p>$ git tag [tag] [commit]</p><h1 id="删除本地tag"><a href="#删除本地tag" class="headerlink" title="删除本地tag"></a>删除本地tag</h1><p>$ git tag -d [tag]</p><h1 id="删除远程tag"><a href="#删除远程tag" class="headerlink" title="删除远程tag"></a>删除远程tag</h1><p>$ git push origin :refs/tags/[tagName]</p><h1 id="查看tag信息"><a href="#查看tag信息" class="headerlink" title="查看tag信息"></a>查看tag信息</h1><p>$ git show [tag]</p><h1 id="提交指定tag"><a href="#提交指定tag" class="headerlink" title="提交指定tag"></a>提交指定tag</h1><p>$ git push [remote] [tag]</p><h1 id="提交所有tag"><a href="#提交所有tag" class="headerlink" title="提交所有tag"></a>提交所有tag</h1><p>$ git push [remote] –tags</p><h1 id="新建一个分支，指向某个tag"><a href="#新建一个分支，指向某个tag" class="headerlink" title="新建一个分支，指向某个tag"></a>新建一个分支，指向某个tag</h1><p>$ git checkout -b [branch] [tag]<br>七、查看信息</p><h1 id="显示有变更的文件"><a href="#显示有变更的文件" class="headerlink" title="显示有变更的文件"></a>显示有变更的文件</h1><p>$ git status</p><h1 id="显示当前分支的版本历史"><a href="#显示当前分支的版本历史" class="headerlink" title="显示当前分支的版本历史"></a>显示当前分支的版本历史</h1><p>$ git log</p><h1 id="显示commit历史，以及每次commit发生变更的文件"><a href="#显示commit历史，以及每次commit发生变更的文件" class="headerlink" title="显示commit历史，以及每次commit发生变更的文件"></a>显示commit历史，以及每次commit发生变更的文件</h1><p>$ git log –stat</p><h1 id="搜索提交历史，根据关键词"><a href="#搜索提交历史，根据关键词" class="headerlink" title="搜索提交历史，根据关键词"></a>搜索提交历史，根据关键词</h1><p>$ git log -S [keyword]</p><h1 id="显示某个commit之后的所有变动，每个commit占据一行"><a href="#显示某个commit之后的所有变动，每个commit占据一行" class="headerlink" title="显示某个commit之后的所有变动，每个commit占据一行"></a>显示某个commit之后的所有变动，每个commit占据一行</h1><p>$ git log [tag] HEAD –pretty=format:%s</p><h1 id="显示某个commit之后的所有变动，其”提交说明”必须符合搜索条件"><a href="#显示某个commit之后的所有变动，其”提交说明”必须符合搜索条件" class="headerlink" title="显示某个commit之后的所有变动，其”提交说明”必须符合搜索条件"></a>显示某个commit之后的所有变动，其”提交说明”必须符合搜索条件</h1><p>$ git log [tag] HEAD –grep feature</p><h1 id="显示某个文件的版本历史，包括文件改名"><a href="#显示某个文件的版本历史，包括文件改名" class="headerlink" title="显示某个文件的版本历史，包括文件改名"></a>显示某个文件的版本历史，包括文件改名</h1><p>$ git log –follow [file]<br>$ git whatchanged [file]</p><h1 id="显示指定文件相关的每一次diff"><a href="#显示指定文件相关的每一次diff" class="headerlink" title="显示指定文件相关的每一次diff"></a>显示指定文件相关的每一次diff</h1><p>$ git log -p [file]</p><h1 id="显示过去5次提交"><a href="#显示过去5次提交" class="headerlink" title="显示过去5次提交"></a>显示过去5次提交</h1><p>$ git log -5 –pretty –oneline</p><h1 id="显示所有提交过的用户，按提交次数排序"><a href="#显示所有提交过的用户，按提交次数排序" class="headerlink" title="显示所有提交过的用户，按提交次数排序"></a>显示所有提交过的用户，按提交次数排序</h1><p>$ git shortlog -sn</p><h1 id="显示指定文件是什么人在什么时间修改过"><a href="#显示指定文件是什么人在什么时间修改过" class="headerlink" title="显示指定文件是什么人在什么时间修改过"></a>显示指定文件是什么人在什么时间修改过</h1><p>$ git blame [file]</p><h1 id="显示暂存区和工作区的差异"><a href="#显示暂存区和工作区的差异" class="headerlink" title="显示暂存区和工作区的差异"></a>显示暂存区和工作区的差异</h1><p>$ git diff</p><h1 id="显示暂存区和上一个commit的差异"><a href="#显示暂存区和上一个commit的差异" class="headerlink" title="显示暂存区和上一个commit的差异"></a>显示暂存区和上一个commit的差异</h1><p>$ git diff –cached [file]</p><h1 id="显示工作区与当前分支最新commit之间的差异"><a href="#显示工作区与当前分支最新commit之间的差异" class="headerlink" title="显示工作区与当前分支最新commit之间的差异"></a>显示工作区与当前分支最新commit之间的差异</h1><p>$ git diff HEAD</p><h1 id="显示两次提交之间的差异"><a href="#显示两次提交之间的差异" class="headerlink" title="显示两次提交之间的差异"></a>显示两次提交之间的差异</h1><p>$ git diff [first-branch]…[second-branch]</p><h1 id="显示今天你写了多少行代码"><a href="#显示今天你写了多少行代码" class="headerlink" title="显示今天你写了多少行代码"></a>显示今天你写了多少行代码</h1><p>$ git diff –shortstat “@{0 day ago}”</p><h1 id="显示某次提交的元数据和内容变化"><a href="#显示某次提交的元数据和内容变化" class="headerlink" title="显示某次提交的元数据和内容变化"></a>显示某次提交的元数据和内容变化</h1><p>$ git show [commit]</p><h1 id="显示某次提交发生变化的文件"><a href="#显示某次提交发生变化的文件" class="headerlink" title="显示某次提交发生变化的文件"></a>显示某次提交发生变化的文件</h1><p>$ git show –name-only [commit]</p><h1 id="显示某次提交时，某个文件的内容"><a href="#显示某次提交时，某个文件的内容" class="headerlink" title="显示某次提交时，某个文件的内容"></a>显示某次提交时，某个文件的内容</h1><p>$ git show [commit]:[filename]</p><h1 id="显示当前分支的最近几次提交"><a href="#显示当前分支的最近几次提交" class="headerlink" title="显示当前分支的最近几次提交"></a>显示当前分支的最近几次提交</h1><p>$ git reflog<br>八、远程同步</p><h1 id="下载远程仓库的所有变动"><a href="#下载远程仓库的所有变动" class="headerlink" title="下载远程仓库的所有变动"></a>下载远程仓库的所有变动</h1><p>$ git fetch [remote]</p><h1 id="显示所有远程仓库"><a href="#显示所有远程仓库" class="headerlink" title="显示所有远程仓库"></a>显示所有远程仓库</h1><p>$ git remote -v</p><h1 id="显示某个远程仓库的信息"><a href="#显示某个远程仓库的信息" class="headerlink" title="显示某个远程仓库的信息"></a>显示某个远程仓库的信息</h1><p>$ git remote show [remote]</p><h1 id="增加一个新的远程仓库，并命名"><a href="#增加一个新的远程仓库，并命名" class="headerlink" title="增加一个新的远程仓库，并命名"></a>增加一个新的远程仓库，并命名</h1><p>$ git remote add [shortname] [url]</p><h1 id="取回远程仓库的变化，并与本地分支合并"><a href="#取回远程仓库的变化，并与本地分支合并" class="headerlink" title="取回远程仓库的变化，并与本地分支合并"></a>取回远程仓库的变化，并与本地分支合并</h1><p>$ git pull [remote] [branch]</p><h1 id="上传本地指定分支到远程仓库"><a href="#上传本地指定分支到远程仓库" class="headerlink" title="上传本地指定分支到远程仓库"></a>上传本地指定分支到远程仓库</h1><p>$ git push [remote] [branch]</p><h1 id="强行推送当前分支到远程仓库，即使有冲突"><a href="#强行推送当前分支到远程仓库，即使有冲突" class="headerlink" title="强行推送当前分支到远程仓库，即使有冲突"></a>强行推送当前分支到远程仓库，即使有冲突</h1><p>$ git push [remote] –force</p><h1 id="推送所有分支到远程仓库"><a href="#推送所有分支到远程仓库" class="headerlink" title="推送所有分支到远程仓库"></a>推送所有分支到远程仓库</h1><p>$ git push [remote] –all<br>九、撤销</p><h1 id="恢复暂存区的指定文件到工作区"><a href="#恢复暂存区的指定文件到工作区" class="headerlink" title="恢复暂存区的指定文件到工作区"></a>恢复暂存区的指定文件到工作区</h1><p>$ git checkout [file]</p><h1 id="恢复某个commit的指定文件到暂存区和工作区"><a href="#恢复某个commit的指定文件到暂存区和工作区" class="headerlink" title="恢复某个commit的指定文件到暂存区和工作区"></a>恢复某个commit的指定文件到暂存区和工作区</h1><p>$ git checkout [commit] [file]</p><h1 id="恢复暂存区的所有文件到工作区"><a href="#恢复暂存区的所有文件到工作区" class="headerlink" title="恢复暂存区的所有文件到工作区"></a>恢复暂存区的所有文件到工作区</h1><p>$ git checkout .</p><h1 id="重置暂存区的指定文件，与上一次commit保持一致，但工作区不变"><a href="#重置暂存区的指定文件，与上一次commit保持一致，但工作区不变" class="headerlink" title="重置暂存区的指定文件，与上一次commit保持一致，但工作区不变"></a>重置暂存区的指定文件，与上一次commit保持一致，但工作区不变</h1><p>$ git reset [file]</p><h1 id="重置暂存区与工作区，与上一次commit保持一致"><a href="#重置暂存区与工作区，与上一次commit保持一致" class="headerlink" title="重置暂存区与工作区，与上一次commit保持一致"></a>重置暂存区与工作区，与上一次commit保持一致</h1><p>$ git reset –hard</p><h1 id="重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变"><a href="#重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变" class="headerlink" title="重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变"></a>重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变</h1><p>$ git reset [commit]</p><h1 id="重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致"><a href="#重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致" class="headerlink" title="重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致"></a>重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致</h1><p>$ git reset –hard [commit]</p><h1 id="重置当前HEAD为指定commit，但保持暂存区和工作区不变"><a href="#重置当前HEAD为指定commit，但保持暂存区和工作区不变" class="headerlink" title="重置当前HEAD为指定commit，但保持暂存区和工作区不变"></a>重置当前HEAD为指定commit，但保持暂存区和工作区不变</h1><p>$ git reset –keep [commit]</p><h1 id="新建一个commit，用来撤销指定commit"><a href="#新建一个commit，用来撤销指定commit" class="headerlink" title="新建一个commit，用来撤销指定commit"></a>新建一个commit，用来撤销指定commit</h1><h1 id="后者的所有变化都将被前者抵消，并且应用到当前分支"><a href="#后者的所有变化都将被前者抵消，并且应用到当前分支" class="headerlink" title="后者的所有变化都将被前者抵消，并且应用到当前分支"></a>后者的所有变化都将被前者抵消，并且应用到当前分支</h1><p>$ git revert [commit]</p><h1 id="暂时将未提交的变化移除，稍后再移入"><a href="#暂时将未提交的变化移除，稍后再移入" class="headerlink" title="暂时将未提交的变化移除，稍后再移入"></a>暂时将未提交的变化移除，稍后再移入</h1><p>$ git stash<br>$ git stash pop<br>十、其他</p><h1 id="生成一个可供发布的压缩包"><a href="#生成一个可供发布的压缩包" class="headerlink" title="生成一个可供发布的压缩包"></a>生成一个可供发布的压缩包</h1><p>$ git archive</p>]]></content>
    
    
    <categories>
      
      <category>Git</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript基础</title>
    <link href="/2021/07/06/JavaScript-base/"/>
    <url>/2021/07/06/JavaScript-base/</url>
    
    <content type="html"><![CDATA[<h1 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h1><p>JavaScript负责页面中的的行为。  </p><p>它是一门运行在浏览器端的脚本语言。  </p><h2 id="JS的编写的位置"><a href="#JS的编写的位置" class="headerlink" title="JS的编写的位置"></a>JS的编写的位置</h2><p>1.可以编写到标签的指定属性中  </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;alert(&#x27;hello&#x27;);&quot;</span>&gt;</span>我是按钮<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>  <br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;javascript:alert(&#x27;aaa&#x27;);&quot;</span>&gt;</span>超链接<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>  <br></code></pre></td></tr></table></figure><p>2.可以编写到script标签中  </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><span class="javascript">  </span><br><span class="javascript"><span class="hljs-comment">//编写js代码  </span></span><br><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>  <br></code></pre></td></tr></table></figure><p>3.可以将代码编写到外部的js文件中，然后通过标签将其引入  </p><p>script标签一旦用于引入外部文件了，就不能再编写代码了，即使编写了浏览器也会忽略</p><p>如果需要则可以再创建一个新的script标签用于编写内部代码 </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;文件路径&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>  <br></code></pre></td></tr></table></figure><h2 id="输出语句"><a href="#输出语句" class="headerlink" title="输出语句"></a>输出语句</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">alert(<span class="hljs-string">&quot;要输出的内容&quot;</span>);  <br></code></pre></td></tr></table></figure><p>该语句会在浏览器窗口中弹出一个警告框 。括号里加引号表示字符串，不加引号表示变量名。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">document</span>.write(<span class="hljs-string">&quot;要输出的内容&quot;</span>);  <br></code></pre></td></tr></table></figure><p>该内容将会被写到body标签中，并在页面中显示  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;要输出的内容&quot;</span>);  <br></code></pre></td></tr></table></figure><p>该内容会被写到开发者工具的控制台中  </p><h2 id="基本的语法"><a href="#基本的语法" class="headerlink" title="基本的语法"></a>基本的语法</h2><p>js函数声明不需要；分号，但是赋值语句要加；分号  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">functionName</span>(<span class="hljs-params">arg0,arg1,arg2</span>)</span>&#123;  <br><span class="hljs-comment">//函数声明  </span><br>&#125;  <br><span class="hljs-keyword">var</span> functionName=<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">arg0,arg1,arg2</span>)</span>&#123;  <br><span class="hljs-comment">//函数表达式  </span><br>&#125;;(注意分号)  <br></code></pre></td></tr></table></figure><p>注释  </p><p>单行注释  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//注释内容  </span><br></code></pre></td></tr></table></figure><p>多行注释  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/*  </span><br><span class="hljs-comment">注释内容  </span><br><span class="hljs-comment">*/</span>  <br></code></pre></td></tr></table></figure><p>JS严格区分大小写      </p><p>JS中每条语句以分号(;)结尾如果不写分号，浏览器会自动添加，但是会消耗一些系统资源，  而且有些时候，浏览器会加错分号，所以在开发中分号必须写  </p><p>JS中会自动忽略多个空格和换行，所以我们可以利用空格和换行对代码进行格式化。  </p><h2 id="字面量和变量"><a href="#字面量和变量" class="headerlink" title="字面量和变量"></a>字面量和变量</h2><h3 id="字面量"><a href="#字面量" class="headerlink" title="字面量"></a>字面量</h3><p>字面量实际上就是一些固定的值，比如 1 2 3 4 true false null NaN “hello”<br><strong>字面量都是不可以改变的。</strong>  </p><p>由于字面量不是很方便使用，所以在JS中很少直接使用字面量  </p><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>变量可以用来保存字面量，并且可以保存任意的字面量  </p><p>一般都是通过变量来使用字面量，而不直接使用字面量，而且也可以通过变量来对字面量进行一个描述  </p><p>声明变量  </p><p>使用var关键字来声明一个变量  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a;  <br></code></pre></td></tr></table></figure><p>为变量赋值 </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">a = <span class="hljs-number">1</span>; <br></code></pre></td></tr></table></figure><p>声明和赋值同时进行 </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = <span class="hljs-number">456</span>;   <br></code></pre></td></tr></table></figure><h3 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h3><p>在JS中所有的可以自主命名的内容，都可以认为是一个标识符，<br>是标识符就应该遵守标识符的规范。  </p><p>比如：变量名、函数名、属性名  </p><p>规范：<br>1.标识符中可以含有字母、数字、_、$<br>2.标识符不能以数字开头<br>3.标识符不能是JS中的关键字和保留字<br>4.标识符一般采用驼峰命名法<br>xxxYyyZzz  </p><h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><h2 id="六种数据类型"><a href="#六种数据类型" class="headerlink" title="六种数据类型"></a>六种数据类型</h2><p> <strong>JS中一共分成六种数据类型 5个基本数据类型+object</strong><br> String 字符串<br> Number 数值<br> Boolean 布尔值<br> Null 空值<br> Undefined 未定义<br> Object 对象  </p><p> 其中基本数据类型前5个</p><p>引用数据类型 Object  </p><p><strong>typeof运算符检查数据类型</strong>  </p><h3 id="1-String-字符串"><a href="#1-String-字符串" class="headerlink" title="1.String 字符串"></a>1.String 字符串</h3><p>JS中的字符串需要使用引号引起来双引号或单引号都行<br> 在字符串中使用\作为转义字符  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript">\<span class="hljs-string">&#x27;  ==&gt; &#x27;</span>  <br>\<span class="hljs-string">&quot;  ==&gt; &quot;</span>  <br>\n  ==&gt; 换行  <br>\t  ==&gt; 制表符  <br>\\  ==&gt; \  <br>\u十六进制 ==&gt; 输出Unicode  <span class="hljs-comment">//（另，在html中，用&amp;#十进制 输出特殊符号）</span><br></code></pre></td></tr></table></figure><p> 使用typeof运算符检查字符串时，会返回”string”      </p><h3 id="2-Number-数值"><a href="#2-Number-数值" class="headerlink" title="2.Number 数值"></a>2.Number 数值</h3><p> <strong>JS中所有的整数和浮点数都是Number类型</strong>  </p><p>var a = “123”;</p><p>加引号的时候a是一个字符串 不加引号的时候是一个数字。</p><p>最大最小能表示的值：Number.MAX_VALUE=    1.7976931348623157e+308  </p><p>​                                Number.MIN_VALUE = 5e-324</p><p> 特殊的数字：能赋值给变量<br>    Infinity 正无穷 a = Infinity ,能赋值<br>    -Infinity 负无穷<br>    NaN 非法数字（Not A Number）<br> 其他进制的数字的表示：<br>0b 开头表示二进制，但是不是所有的浏览器都支持<br>0 开头表示八进制<br>0x 开头表示十六进制  </p><p> 使用typeof检查一个Number类型的数据时（包括NaN 和 Infinity） ，会返回”number”<br> 就是返回上面几种类型里面的</p><p>如果使用JS进行浮点运算，可能得到一个不精确的结果，所以千万不要使用JS进行对精确度要求比较高的运算。</p><h3 id="3-Boolean-布尔值"><a href="#3-Boolean-布尔值" class="headerlink" title="3.Boolean 布尔值"></a>3.Boolean 布尔值</h3><p> 布尔值主要用来进行逻辑判断，布尔值只有两个<br> true 逻辑的真<br> false 逻辑的假<br> 使用typeof检查一个布尔值时，会返回”boolean”      </p><h3 id="4-Null-空值"><a href="#4-Null-空值" class="headerlink" title="4.Null 空值"></a>4.Null 空值</h3><p> 空值专门用来表示为空的对象，Null类型的值只有一个<br> null<br> 使用typeof检查一个Null类型的值时会返回”object”  空对象</p><h3 id="5-Undefined-未定义"><a href="#5-Undefined-未定义" class="headerlink" title="5.Undefined 未定义"></a>5.Undefined 未定义</h3><p> <strong>如果声明一个变量但是没有为变量赋值此时变量的值就是undefined</strong><br> 该类型的值只有一个 undefined<br> 使用typeof检查一个Undefined类型的值时，会返回”undefined”  </p><h3 id="引用数据类型"><a href="#引用数据类型" class="headerlink" title="引用数据类型"></a>引用数据类型</h3><p> Object 对象  </p><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p> 类型转换就是指将其他的数据类型，转换为String Number Boolean  </p><h3 id="转换为String"><a href="#转换为String" class="headerlink" title="转换为String"></a>转换为String</h3><h4 id="方式一（强制类型转换）："><a href="#方式一（强制类型转换）：" class="headerlink" title="方式一（强制类型转换）："></a>方式一（强制类型转换）：</h4><p> <strong>调用被转换数据的toString()==方法==</strong>  需要用x.来调用<br> 例子：<br>var a = 123;<br>a = a.toString();  </p><p>注意：<strong>这个方法不适用于null和undefined</strong><br>由于这两个类型的数据中没有方法，所以调用toString()时会报错  </p><h4 id="方式二（强制类型转换）："><a href="#方式二（强制类型转换）：" class="headerlink" title="方式二（强制类型转换）："></a>方式二（强制类型转换）：</h4><p> <strong>调用String()==函数==</strong>  直接调用<br> 例子：  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = <span class="hljs-number">123</span>;  <br>a = <span class="hljs-built_in">String</span>(a);  <br></code></pre></td></tr></table></figure><p> 原理：<strong>对于Number Boolean String都会调用他们的toString()方法来将其转换为字符串，对于null值，直接转换为字符串”null”。对于undefined直接转换为字符串”undefined”</strong>  </p><h4 id="方式三（隐式的类型转换）"><a href="#方式三（隐式的类型转换）" class="headerlink" title="方式三（隐式的类型转换）:"></a>方式三（隐式的类型转换）:</h4><p> <strong>为任意的数据类型 +””</strong>  沾字符串，变字符串<br> 例子：  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = <span class="hljs-literal">true</span>;  <br>a = a + <span class="hljs-string">&quot;&quot;</span>; <br><br>result = <span class="hljs-number">1</span> + <span class="hljs-number">2</span> + <span class="hljs-string">&quot;3&quot;</span>; <span class="hljs-comment">//33</span><br></code></pre></td></tr></table></figure><p> 原理：和String()函数一样      </p><h3 id="转换为Number"><a href="#转换为Number" class="headerlink" title="转换为Number"></a>转换为Number</h3><h4 id="方式一（强制类型转换）：-1"><a href="#方式一（强制类型转换）：-1" class="headerlink" title="方式一（强制类型转换）："></a>方式一（强制类型转换）：</h4><p> <strong>调用Number()函数</strong><br> 例子： </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> s = <span class="hljs-string">&quot;123&quot;</span>;  <br>s = <span class="hljs-built_in">Number</span>(s); <br></code></pre></td></tr></table></figure><p> 转换的情况：  </p><ol><li>字符串 &gt; 数字<br>如果字符串是一个合法的数字，则直接转换为对应的数字<br> 如果字符串是一个非法的数字，则转换为NaN<br> 如果是一个空串或纯空格的字符串，则转换为0  </li><li>布尔值 &gt; 数字<br>true转换为1<br> false转换为0  </li><li>空值 &gt; 数字<br>null转换为0  </li><li>未定义 &gt; 数字<br>undefined 转换为NaN  </li></ol><h4 id="方式二（强制类型转换）：-1"><a href="#方式二（强制类型转换）：-1" class="headerlink" title="方式二（强制类型转换）："></a>方式二（强制类型转换）：</h4><p> 调用parseInt()或parseFloat()  解析<br> 这两个函数专门用来将一个字符串转换为数字的 </p><p>如果对非String使用parseInt()或parseFloat()，它会<strong>先将其转换为String</strong>然后在操作 parseInt()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">a = <span class="hljs-keyword">true</span>;<br>a=parseInt(a) ; <span class="hljs-comment">//--&gt; &quot;true &quot;number类型 NaN</span><br></code></pre></td></tr></table></figure><p> 可以将<strong>一个字符串中的有效的整数位</strong>提取出来，并转换为Number  比上一个方法更智能<br> 例子：  </p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = <span class="hljs-string">&quot;123.456px&quot;</span>;  <br>a = <span class="hljs-built_in">parseInt</span>(a); <span class="hljs-comment">//123  </span><br><br>123a456 --&gt; <span class="hljs-number">123</span><br></code></pre></td></tr></table></figure><p> 如果需要可以在parseInt()中指定一个第二个参数，来指定进制parseFloat()可以将一个<strong>字符串中的有效的小数位</strong>提取出来，并转换为Number<br> 例子：  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = <span class="hljs-string">&quot;123.456px&quot;</span>;  <br>a = <span class="hljs-built_in">parseFloat</span>(a); <span class="hljs-comment">//123.456  </span><br></code></pre></td></tr></table></figure><p>可以在parseInt()中传递一个第二个参数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">a = <span class="hljs-built_in">parseInt</span>(a,<span class="hljs-number">10</span>);<span class="hljs-comment">//认成10进制，再转换成int，防止070这样的认成8进制</span><br></code></pre></td></tr></table></figure><h4 id="方式三（隐式的类型转换）："><a href="#方式三（隐式的类型转换）：" class="headerlink" title="方式三（隐式的类型转换）："></a>方式三（隐式的类型转换）：</h4><p> 使用一元的+来进行隐式的类型转换<br> 例子：  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = <span class="hljs-string">&quot;123&quot;</span>;  <br>a = +a;  <br>a = a - <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure><p> <strong>原理：和Number()函数一样</strong>  </p><h3 id="转换为布尔值"><a href="#转换为布尔值" class="headerlink" title="转换为布尔值"></a>转换为布尔值</h3><h4 id="方式一（强制类型转换）：-2"><a href="#方式一（强制类型转换）：-2" class="headerlink" title="方式一（强制类型转换）："></a>方式一（强制类型转换）：</h4><p> 使用Boolean()函数<br> 例子：  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> s = <span class="hljs-string">&quot;false&quot;</span>;  <br>s = <span class="hljs-built_in">Boolean</span>(s); <span class="hljs-comment">//true </span><br></code></pre></td></tr></table></figure><p> 转换的情况<br>1.字符串 &gt; 布尔<br>     除了空串其余全是true  </p><p>2.数值 &gt; 布尔<br>     除了0和NaN其余的全是true  </p><p>3.null、undefined &gt; 布尔<br>     都是false  </p><p>4.对象 &gt; 布尔<br>     都是true  </p><h4 id="方式二（隐式类型转换）："><a href="#方式二（隐式类型转换）：" class="headerlink" title="方式二（隐式类型转换）："></a>方式二（隐式类型转换）：</h4><p> <strong>为任意的数据类型做两次非运算，即可将其转换为布尔值</strong><br> 例子：  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = <span class="hljs-string">&quot;hello&quot;</span>;  <br>a = !!a; <span class="hljs-comment">//true  </span><br></code></pre></td></tr></table></figure><h1 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h1><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><p> 运算符也称为操作符<br> 通过运算符可以对一个或多个值进行运算或操作  </p><h3 id="typeof运算符"><a href="#typeof运算符" class="headerlink" title="typeof运算符"></a>typeof运算符</h3><p> 用来检查一个变量的数据类型<br> 语法：typeof 变量<br> 它会返回一个用于描述类型的字符串string作为结果  </p><h3 id="算数运算符"><a href="#算数运算符" class="headerlink" title="算数运算符"></a>算数运算符</h3><p>+&ensp;对两个值进行加法运算并返回结果，字符串会拼串<br>-&ensp;对两个值进行减法运算并返回结果<br>*&ensp;对两个值进行乘法运算并返回结果<br>/&ensp;对两个值进行除法运算并返回结果<br>%&ensp;对两个值进行取余运算并返回结果  </p><p> 而做加法运算时，如果是两个字符串进行相加，则会做拼串操作，将两个字符连接为一个字符串。 </p><p> <strong>除了加法以外，对非Number类型的值进行运算时，都会先转换为Number然后在做运算。</strong>  </p><p> 任何值和字符串做加法，都会先转换为字符串，然后再拼串  </p><h3 id="一元运算符"><a href="#一元运算符" class="headerlink" title="一元运算符"></a>一元运算符</h3><p> 一元运算符只需要一个操作数  </p><h4 id="一元的"><a href="#一元的" class="headerlink" title="一元的+"></a>一元的+</h4><p> 就是正号，不会对值产生任何影响，但是可以将一个非数字转换为数字<br> 例子：    </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = <span class="hljs-literal">true</span>;  <br>a = +a;  <br><br><span class="hljs-keyword">var</span> result = <span class="hljs-number">1</span> + +<span class="hljs-string">&quot;2”+3; //123？</span><br><span class="hljs-string"></span><br></code></pre></td></tr></table></figure><h4 id="一元的-1"><a href="#一元的-1" class="headerlink" title="一元的-"></a>一元的-</h4><p> 就是负号，可以对一个数字进行符号位取反  它会将先转换为Number，然后再运算<br> 例子：  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = <span class="hljs-number">10</span>;  <br>a = a;  <br></code></pre></td></tr></table></figure><h4 id="自增"><a href="#自增" class="headerlink" title="自增"></a>自增</h4><p> 自增可以使变量在原值的基础上自增1<br> 自增使用 ++<br> 自增可以使用 前++（++a）后++(a++)<br> 无论是++a 还是 a++都会立即使原变量自增1<br>不同的是++a和a++的值是不同的，<br>    ++a的值是变量的新值（自增后的值）<br>    a++的值是变量的原值（自增前的值）  </p><h4 id="自减"><a href="#自减" class="headerlink" title="自减"></a>自减</h4><p> 自减可以使变量在原值的基础上自减1<br> 自减使用<br> 自减可以使用 前（a）后(a)<br> 无论是a 还是 a都会立即使原变量自减1<br>不同的是a和a的值是不同的，<br>    a的值是变量的新值（自减后的值）<br>    a的值是变量的原值（自减前的值）  </p><h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><p>!<br>     非运算可以对一个布尔值进行取反，true变false false边true<br>     当对非布尔值使用!时，会先将其转换为布尔值然后再取反<br>     我们可以利用!来将其他的数据类型转换为布尔值  </p><p>&amp;&amp;<br>     &amp;&amp;可以对符号两侧的值进行与运算<br>     只有两端的值都为true时，才会返回true。只要有一个false就会返回false。<br>     与是一个短路的与，如果第一个值是false，则不再检查第二个值  懒与<br>     对于非布尔值，它会将其转换为布尔值然后做运算，并返回原值<br>     规则：<br>            1.如果第一个值为false，则返回第一个值<br>            2.如果第一个值为true，则返回第二个值  </p><p>||<br>     ||可以对符号两侧的值进行或运算<br>     只有两端都是false时，才会返回false。只要有一个true，就会返回true。<br>     或是一个短路的或，如果第一个值是true，则不再检查第二个值  懒或<br>     对于非布尔值，它会将其转换为布尔值然后做运算，并返回原值<br>     规则：<br>            1.如果第一个值为true，则返回第一个值<br>            2.如果第一个值为false，则返回第二个值  </p><h3 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h3><p>=<br>     可以将符号右侧的值赋值给左侧变量<br>+=      </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">a += <span class="hljs-number">5</span> 相当于 a = a+<span class="hljs-number">5</span>    <br><span class="hljs-keyword">var</span> str = <span class="hljs-string">&quot;hello&quot;</span>;  str += <span class="hljs-string">&quot;world&quot;</span>;  <br></code></pre></td></tr></table></figure><p>-=    </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">a -= <span class="hljs-number">5</span>  相当于 a = a-<span class="hljs-number">5</span>  <br></code></pre></td></tr></table></figure><p>*=    </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">a *= <span class="hljs-number">5</span> 相当于 a = a*<span class="hljs-number">5</span>  <br></code></pre></td></tr></table></figure><p>/=    </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">a /= <span class="hljs-number">5</span> 相当于 a = a/<span class="hljs-number">5</span>  <br></code></pre></td></tr></table></figure><p>%=  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">a %= <span class="hljs-number">5</span> 相当于 a = a%<span class="hljs-number">5</span> <br></code></pre></td></tr></table></figure><h3 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h3><p> 关系运算符用来比较两个值之间的大小关系的<br>    &gt;<br>    &gt;=<br>    &lt;<br>    &lt;=  </p><p> 关系运算符的规则和数学中一致，用来比较两个值之间的关系，<br>如果关系成立则返回true，关系不成立则返回false。 </p><p> 如果比较的两个值是非数值，会将其转换为Number然后再比较。</p><p>数值和字符串比较，字符串是NaN，返回false<br> 如果比较的==两个值都是字符串==，此时会比较字符串的Unicode编码，而不会转换为Number。  比较字符编码时是一位一位进行比较，如果两位一样，则比较下一位。所以”11” &lt; “5” //true<br>想让他们比较 就要先转型：+”x”</p><h3 id="相等运算符"><a href="#相等运算符" class="headerlink" title="相等运算符"></a>相等运算符</h3><p> 相等，判断左右两个值是否相等，如果相等返回true，如果不等返回false<br> 相等会自动对两个值进行类型转换，如果<strong>对不同的类型进行比较，会将其转换为相同的类型然后再比较</strong>，转换后相等它也会返回true，null == undifined//true,因为undifined衍生自null  ，null == 0//false<br>NaN不和任何值相等，包括它本身，用’isNaN’函数来判断一个数是否是NaN</p><p>!=<br>     不等，判断左右两个值是否不等，如果不等则返回true，如果相等则返回false<br>     不等也会做自动的类型转换。  </p><p><strong>===</strong><br>     <strong>全等</strong>，判断左右两个值是否全等，它和相等类似，只不过它不会进行自动的类型转换，<br>        如果两个值的类型不同，则直接返回false  </p><p>!==<br>     <strong>不全等</strong>，和不等类似，但是它不会进行自动的类型转换，如果两个值的类型不同，它会直接返回true  </p><p>特殊的值：<br>     null和undefined<br>         由于undefined衍生自null，所以<strong>null == undefined</strong> 会返回true。<br>            但是 null === undefined 会返回false。<br><strong>NaN</strong><br>     NaN不与任何值相等，包括它自身 NaN == NaN //false  </p><p> 判断一个值是否是NaN<br>     使用isNaN()函数  </p><h3 id="三元运算符："><a href="#三元运算符：" class="headerlink" title="三元运算符："></a>三元运算符：</h3><p>?:<br>     语法：条件表达式?语句1:语句2;<br>     执行流程：<br>        先对条件表达式求值判断，<br>            如果判断结果为true，则执行语句1，并返回执行结果<br>            如果判断结果为false，则执行语句2，并返回执行结果  </p><h3 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h3><p> var a=1 , b=2 , c=3;<br>可以同时声明多个变量并赋值。</p><p>和数学中一样，JS中的运算符也是具有优先级的，<br>    比如 先乘除 后加减 先与 后或<br> 具体的优先级可以参考优先级的表格，在表格中越靠上的优先级越高，<br>    优先级越高的越优先计算，优先级相同的，从左往右计算。<br> 优先级不需要记忆，如果越到拿不准的，使用()来改变优先级。  </p><h2 id="流程控制语句"><a href="#流程控制语句" class="headerlink" title="流程控制语句"></a>流程控制语句</h2><p> 程序都是自上向下的顺序执行的，<br>通过流程控制语句可以改变程序执行的顺序，或者反复的执行某一段的程序。</p><p>用{</p><p>}<br>表示代码块，只有分组的作用没有其他作用</p><h3 id="条件分支语句"><a href="#条件分支语句" class="headerlink" title="条件分支语句"></a>条件分支语句</h3><p> 条件判断语句也称为if语句<br> 语法一：  </p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">if</span>(条件表达式)&#123;  <br>语句...  <br>&#125;  <br></code></pre></td></tr></table></figure><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">执行流程：  <br><span class="hljs-keyword">if</span>语句执行时，会先对条件表达式进行求值判断，  <br>如果值为<span class="hljs-literal">true</span>，则执行<span class="hljs-keyword">if</span>后的语句  <br>如果值为<span class="hljs-literal">false</span>，则不执行  <br></code></pre></td></tr></table></figure><p> 语法二：  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">if</span>(条件表达式)&#123;  <br>语句...  <br>&#125;<span class="hljs-keyword">else</span>&#123;  <br>语句...  <br>&#125; <br></code></pre></td></tr></table></figure><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs lasso">执行流程：  <br><span class="hljs-keyword">if</span><span class="hljs-params">...</span><span class="hljs-keyword">else</span>语句执行时，会对条件表达式进行求值判断，  <br>如果值为<span class="hljs-literal">true</span>，则执行<span class="hljs-keyword">if</span>后的语句  <br>如果值为<span class="hljs-literal">false</span>，则执行<span class="hljs-keyword">else</span>后的语句  <br></code></pre></td></tr></table></figure><p> 语法三：  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">if</span>(条件表达式)&#123;  <br>语句...  <br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(条件表达式)&#123;  <br>语句...  <br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(条件表达式)&#123;  <br>语句...  <br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(条件表达式)&#123;  <br>语句...  <br>&#125;<span class="hljs-keyword">else</span>&#123;  <br>语句...  <br>&#125;  <br></code></pre></td></tr></table></figure><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs lasso">执行流程  <br> <span class="hljs-keyword">if</span><span class="hljs-params">...</span><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span><span class="hljs-params">...</span><span class="hljs-keyword">else</span>语句执行时，会自上至下依次对条件表达式进行求值判断，  <br>如果判断结果为<span class="hljs-literal">true</span>，则执行当前<span class="hljs-keyword">if</span>后的语句，执行完成后语句结束。  <br>如果判断结果为<span class="hljs-literal">false</span>，则继续向下判断，直到找到为<span class="hljs-literal">true</span>的为止。  <br>如果所有的条件表达式都是<span class="hljs-literal">false</span>，则执行<span class="hljs-keyword">else</span>后的语句  <br></code></pre></td></tr></table></figure><p>1.条件分支语句<br>switch语句<br>语法:  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">switch</span>(条件表达式)&#123;  <br><span class="hljs-keyword">case</span> 表达式:  <br>语句...  <br><span class="hljs-keyword">break</span>;  <br><span class="hljs-keyword">case</span> 表达式:  <br>语句...  <br><span class="hljs-keyword">break</span>;  <br><span class="hljs-keyword">case</span> 表达式:  <br>语句...  <br><span class="hljs-keyword">break</span>;  <br><span class="hljs-keyword">default</span>:  <br>语句...  <br><span class="hljs-keyword">break</span>;  <br>&#125;  <br></code></pre></td></tr></table></figure><p>执行流程：<br> switch…case…语句在执行时，会依次将case后的表达式的值和switch后的表达式的值进行全等比较，<br>    如果比较结果为false，则继续向下比较。如果比较结果为true，则从当前case处开始向下执行代码。<br>    如果所有的case判断结果都为false，则从default处开始执行代码。  </p><h3 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h3><p>通过循环语句可以反复执行某些语句多次<br>while循环<br> 语法：  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">while</span>(条件表达式)&#123;  <br>    语句...  <br>&#125;  <br></code></pre></td></tr></table></figure><p> 执行流程：<br>    while语句在执行时，会先对条件表达式进行求值判断，<br>        如果判断结果为false，则终止循环<br>        如果判断结果为true，则执行循环体<br>        循环体执行完毕，继续对条件表达式进行求值判断，依此类推  </p><p>do…while循环<br> 语法:  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">do</span>&#123;  <br>语句...  <br>&#125;<span class="hljs-keyword">while</span>(条件表达式)  <br></code></pre></td></tr></table></figure><p> 执行流程<br>    do…while在执行时，会先执行do后的循环体，然后在对条件表达式进行判断，<br>        如果判断判断结果为false，则终止循环。<br>        如果判断结果为true，则继续执行循环体，依此类推  </p><p> 和while的区别：<br>    while：先判断后执行<br>    do…while: 先执行后判断<br>     do…while可以确保循环体至少执行一次。  </p><p>for循环<br> 语法：  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">for</span>(①初始化表达式 ; ②条件表达式 ; ④更新表达式)&#123;  <br>    ③语句...  <br>&#125;  <br></code></pre></td></tr></table></figure><p> 执行流程：<br>    首先执行①初始化表达式，初始化一个变量，<br>    然后对②条件表达式进行求值判断，如果为false则终止循环<br>    如果判断结果为true，则执行③循环体<br>    循环体执行完毕，执行④更新表达式，对变量进行更新。<br>    更新表达式执行完毕重复②  </p><p>死循环  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;  <br><br>&#125;  <br><br><span class="hljs-keyword">for</span>(;;)&#123;  <br><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="对象（Object）"><a href="#对象（Object）" class="headerlink" title="对象（Object）"></a>对象（Object）</h1><p>对象是JS中的引用数据类型<br><strong>对象是一种复合数据类型，塑料袋子，在对象中可以保存多个不同数据类型的属性</strong><br>使用typeof检查一个对象时，会返回object  </p><h2 id="对象的分类："><a href="#对象的分类：" class="headerlink" title="对象的分类："></a>对象的分类：</h2><p>1.内建对象<br>    - 由ES标准中定义的对象，在任何的ES的实现中都可以使用<br>    - 比如：Math String Number Boolean Function Object….  </p><p>2.宿主对象<br>    - 由JS的运行环境提供的对象，目前来讲主要指由浏览器提供的对象<br>    - 比如 BOM DOM  </p><p>3.自定义对象  </p><pre><code>- 由开发人员自己创建的对象（以下）  </code></pre><p>创建对象<br> 方式一：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>();  <br></code></pre></td></tr></table></figure><p> 方式二： </p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123;&#125;; <br></code></pre></td></tr></table></figure><p><strong>向对象中添加属性</strong><br> 语法：<br>    对象.属性名 = 属性值;<br>    <strong>对象[“属性名”] = 属性值;</strong>    //这种方式能够使用特殊的属性名  </p><p> <strong>对象的属性名没有任何要求，不需要遵守标识符的规范，但是在开发中，尽量按照标识符的要求去写。</strong><br>属性值也可以任意的数据类型。甚至可以是对象，袋子套个袋子，本质还是一个值。  </p><p>读取对象中的属性<br> 语法：<br>    对象.属性名  比如说age<br>    对象[“属性名”] //自定义属性名 “属性名”可以是字符串常量，也可以是字符串变量（套娃）<br> 如果读取一个对象中没有的属性，它不会报错，而是返回一个undefined  </p><p><strong>==删除==对象中的属性</strong><br> 语法：  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">delete</span> 对象.属性名  <br><span class="hljs-keyword">delete</span> 对象[<span class="hljs-string">&quot;属性名&quot;</span>]  <br></code></pre></td></tr></table></figure><h2 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h2><p><strong>使用in检查对象中是否含有指定属性</strong><br> 语法：”属性名” in 对象<br>     如果在对象中含有该属性，则返回true<br>        如果没有则返回false  </p><pre><code>  循环遍历对象自身的和继承的可枚举属性(不含Symbol属性).  </code></pre><p><strong>使用对象字面量，在创建对象时直接向对象中添加属性</strong><br>语法： </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123;  <br>    属性名:属性值,  <br>    属性名:属性值,  <br>    属性名:属性值,  <br>    属性名:属性值  <br>&#125; <br><span class="hljs-comment">//-----------------------------</span><br><span class="hljs-keyword">var</span> obj = &#123;<br>    <span class="hljs-string">&#x27;0&#x27;</span>:<span class="hljs-string">&#x27;a&#x27;</span>,<br>    <span class="hljs-string">&#x27;1&#x27;</span>:<span class="hljs-string">&#x27;b&#x27;</span>,<br>    <span class="hljs-string">&#x27;2&#x27;</span>:<span class="hljs-string">&#x27;c&#x27;</span><br>&#125;;  <br>  <br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i <span class="hljs-keyword">in</span> obj) &#123;  <br>     <span class="hljs-built_in">console</span>.log(i,<span class="hljs-string">&quot;:&quot;</span>,obj[i]);  <br>&#125;  <br></code></pre></td></tr></table></figure><p>属性名可以加引号，也可以不加，特殊符号名字必加。<br>名和值之间使用：多个名值对之间使用逗号，如果一个属性之后没有其他的属性了，就不要写逗号。</p><p>基本数据类型和引用数据类型<br> 基本数据类型<br>    String Number Boolean Null Undefined<br> 引用数据类型<br>    Object<br> <strong>基本数据类型的数据，变量在栈内存中直接保存的它的值。</strong><br>    变量与变量之间是互相独立的，修改一个变量不会影响其他的变量。</p><p>​    S中的变量都是保存到栈内存中的,基本数据类型的值直接在栈内存中存储，值与值之间是独立存在，修改一个变量不会影响其他的变量。</p><p> <strong>引用数据类型的数据，变量在栈中保存的对象的引用（内存地址）。</strong><br>    如果多个变量指向的是同一个对象，此时修改一个变量的属性，会影响其他的变量。比如下图中的代码，obj2.name 也变成了 zbj.</p><p>​    共振：对象是保存到堆内存中的，每创建一个新的对象，就会在堆内存中开辟出一个新的对象的空间，而变量保存的是对象的==内存地址==（对象的引用）</p><p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-uctgsaCd-1630937238436)(C:\Users\Fine\Downloads\codeOflI.github.io-dev\source_posts\js-note\javaScript\image-20210609162220424.png)]</p><pre><code> 比较两个变量时，对于基本数据类型，比较的就是值，对于引用数据类型比较的是地址，地址相同才相同（虽然他们属性全相同，但是地址不同，就false）。</code></pre><h2 id="函数（Function）"><a href="#函数（Function）" class="headerlink" title="函数（Function）"></a>函数（Function）</h2><p><strong>函数也是一个对象，也具有普通对象的功能（能有属性，例如name等）</strong> 超级塑料袋<br>函数中可以封装一些代码，在需要的时候可以去调用函数来执行这些代码<br>使用typeof检查一个函数时会返回function<br>创建函数<br> 1.函数声明 （并未执行）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> 函数名(<span class="hljs-params">[形参<span class="hljs-number">1</span>,形参<span class="hljs-number">2.</span>..形参N]</span>)</span>&#123;  <br>语句...  <br>&#125;  <br></code></pre></td></tr></table></figure><p> 2.函数表达式（并未执行）<br>将匿名函数的表达式赋值给变量</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> 变量名 = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">[形参<span class="hljs-number">1</span>,形参<span class="hljs-number">2.</span>..形参N]</span>)</span>&#123;  <br>语句...  <br>&#125;;  （注意变量最后有分号，类似于变量的命名!!!）<br></code></pre></td></tr></table></figure><p>3.调用函数（真正执行）<br> 语法：函数对象([实参1,实参2…实参N]);<br>    变量名(实参1，实参2) ，往后可以输入多余的实参不会管它不会报错<br>    sum() alert() Number() parseInt()<br> 当我们调用函数时，函数中封装的代码会按照编写的顺序执行  </p><p><strong>立即执行函数</strong><br>函数定义完，立即被调用，这种函数叫做立即执行函数<br>立即执行函数往往只会执行一次<br>==函数一定要加括号，不然会报错==</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript">(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">a,b</span>)</span>&#123;  <br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;a = &quot;</span>+a);  <br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;b = &quot;</span>+b);  <br>&#125;)(<span class="hljs-number">123</span>,<span class="hljs-number">456</span>); <br></code></pre></td></tr></table></figure><p>遍历对象  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> v <span class="hljs-keyword">in</span> obj)&#123;  <br>    <span class="hljs-built_in">document</span>.write(<span class="hljs-string">&quot;property：name =&quot;</span>+v+<span class="hljs-string">&quot;value=&quot;</span>+obj[v]+<span class="hljs-string">&quot;&lt;br/&gt;&quot;</span> );  <br>&#125;  <br></code></pre></td></tr></table></figure><p>形参和实参<br> 形参：形式参数<br>     定义函数时，可以在()中定义一个或多个形参，形参之间使用,隔开<br>        定义形参就相当于在函数内声明了对应的变量但是并不赋值，<br>        形参会在调用时才赋值。  </p><p> 实参：实际参数<br>     调用函数时，可以在()传递实参，传递的实参会赋值给对应的形参,<br>        调用函数时JS解析器不会检查实参的类型和个数，可以传递任意数据类型的值。<br>        <strong>如果实参的数量大于形参，多余实参将不会赋值，</strong><br>        <strong>如果实参的数量小于形参，则没有对应实参的形参将会赋值undefined</strong>  </p><p><strong>返回值，就是函数执行的结果。</strong><br> 使用return 来设置函数的返回值。<br> 语法：return 值;<br>     该值就会成为函数的返回值，可以通过一个变量来接收返回值<br> return后边的代码都不会执行，一旦执行到return语句时，函数将会立刻退出。<br> return后可以跟任意类型的值，可以是基本数据类型，也可以是一个对象。<br> <strong>如果return后不跟值，或者是不写return则函数默认返回undefined。</strong><br> break、continue和return<br> break<br>     退出循环<br> continue<br>     跳过当次循环<br> return<br>     退出函数  </p><p><strong>参数，函数的实参也可以是任意的数据类型。</strong>  </p><p>实参可以是一个对象时，它可以实现一兜参数成批传递。</p><p><strong>方法（method）</strong><br> 可以将一个函数设置为一个对象的属性，<br>    当一个对象的属性是一个函数时，<br>        我们称这个函数是该对象的方法。<br> 对象.方法名();<br> 函数名()  </p><h3 id="函数的属性和方法"><a href="#函数的属性和方法" class="headerlink" title="函数的属性和方法"></a>函数的属性和方法</h3><p>call()<br>apply()<br> <strong>这两个方法都是函数对象的方法 需要通过函数对象来调用</strong> </p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">fun</span>.apply();<br><span class="hljs-keyword">fun</span>.call();<br><span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">()</span></span>; <br></code></pre></td></tr></table></figure><p> 通过两个方法可以直接调用函数，并且<strong>可以通过第一个实参来指定函数中this</strong><br> 不同的是call是直接传递函数的实参 而apply需要将实参封装到一个<strong>数组</strong>中传递</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">function <span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">(a,b)</span></span>&#123;<br>    console.log( <span class="hljs-string">&quot;a = &quot;</span>+a);<br>    console.log( <span class="hljs-string">&quot;b = &quot;</span>+b);<br>&#125;<br><br><span class="hljs-keyword">fun</span>.call(obj,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>);<br><span class="hljs-keyword">fun</span>.apply (obj,[<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]);<br><br></code></pre></td></tr></table></figure><p><strong>arguments</strong> 参数<br> arguments和this类似，都是函数中的隐含的参数<br> arguments是一个类（似）数组元素，它用来封装函数执行过程中的实参<br>    所以即使不定义形参，也可以通过arguments来使用实参,不过就是<strong>麻烦</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fun</span>(<span class="hljs-params"></span>)</span>&#123;<br><span class="hljs-built_in">console</span>.log( <span class="hljs-built_in">arguments</span>.length);<span class="hljs-comment">//2</span><br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">arguments</span>[<span class="hljs-number">1</span>]);<span class="hljs-comment">//&quot;hello&quot;</span><br>&#125;<br><br>fun(<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-literal">true</span>);<br><br></code></pre></td></tr></table></figure><p> <strong>arguments中有一个属性callee表示当前执行的函数整个本身</strong>  </p><h3 id="this（调用函数的那个对象）"><a href="#this（调用函数的那个对象）" class="headerlink" title="this（调用函数的那个对象）"></a>this（调用函数的那个对象）</h3><p> this是函数的上下文对象，根据函数的调用方式不同会执向不同的对象<br>    1.以函数的形式调用时，this是window<br>    2.以方法的形式调用时，this是调用方法的对象<br>    3.以构造函数的形式调用时，this是新建的那个对象<br>    4.使用call和apply调用时，this是指定的那个对象<br>    5.在全局作用域中this代表window  </p><h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p>作用域简单来说就是一个变量的作用范围。<br>在JS中作用域分成两种：  </p><p>1.全局作用域  </p><p>直接在script标签中编写的代码都运行在全局作用域中<br><strong>全局作用域在打开页面时创建，在页面关闭时销毁。</strong><br>全局作用域中有一个全局对象window，window对象由浏览器提供，<br>可以在页面中直接使用，它代表的是整个的浏览器的窗口。<br><strong>在全局作用域中创建的变量都会作为window对象的属性保存</strong>  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> b = <span class="hljs-number">20</span>;<br><span class="hljs-built_in">console</span>. log(<span class="hljs-built_in">window</span>.b);<span class="hljs-comment">//&quot;20&quot;</span><br></code></pre></td></tr></table></figure><p>在全局作用域中创建的函数都会作为window对象的方法保存<br><strong>在全局作用域中创建的变量和函数可以在页面的任意位置访问。</strong><br>在函数作用域中也可以访问到全局作用域的变量。<br>尽量不要在全局中创建变量      </p><p>2.函数作用域  </p><p>函数作用域是函数执行时创建的作用域，每次调用函数都会创建一个新的函数作用域。<br>函数作用域在函数执行时创建，在函数执行结束时销毁。<br>在函数作用域中创建的变量，不能在全局中访问。<br>当在函数作用域中使用一个变量时，1.它会先在自身作用域中寻找，如果找到了则直接使用，2.如果没有找到则到上一级作用域中寻找， 如果找到了则使用，3.找不到则继续向上找，一直会找到全局作用域。<br>如果想直接引用全局作用域的，用window.a</p><p> <strong>变量的声明提前</strong><br>     1.在全局作用域中，使用**==var关键字==声明的变量会在所有的代码执行之前被声明，但是==不会赋值,所以显示undefined==，而不是报错（未声明，就会报错）。**<br>        所以我们可以在变量声明前使用变量。但是不使用var关键字声明的变量不会被声明提前。</p><p>​     2.在函数作用域中，也具有该特性</p><p>​        2.1使用var关键字声明的变量会在==函数所有的代码==执行前被声明，<br>​        2.2如果在函数作用域中==没有使用var关键字==声明变量，则变量会变成全局变量<br>​        2.3定义了形参就相当于在函数作用域中声明了变量</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> e = <span class="hljs-number">23</span>;<span class="hljs-comment">//全局的</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fun6</span>(<span class="hljs-params">e</span>)</span>&#123;<br>alert(e);<span class="hljs-comment">//undefined</span><br>&#125;<br></code></pre></td></tr></table></figure><p> <strong>函数的声明提前</strong><br>     1.在全局作用域中，使用<strong>函数声明创建的函数（function fun(){}）,会在所有的代码执行之前被创建</strong>，<br>        也就是我们可以在函数声明前去调用函数，但是使用函数表达式(var fun = function(){})创建的函数没有该特性<br>     2.在函数作用域中，使用函数声明创建的函数，会在所有的函数中的代码执行之前就被创建好了。  </p><h2 id="this（上下文对象）"><a href="#this（上下文对象）" class="headerlink" title="this（上下文对象）"></a>this（上下文对象）</h2><p>我们每次调用函数时如 console.log(this); ，解析器都会将一个上下文对象作为隐含的参数传递进函数。<br>使用this来引用上下文对象，根据函数的调用形式不同，this的值也不同。  </p><p>指向当前对象  </p><p>this的不同的情况：<br>1.以函数的形式调用时，this是window      sayName(); 不写谁调的就是全局window调的呗<br>2.以方法的形式调用时，this就是调用方法的对象        obj.sayName();<br>3.以构造函数的形式调用时，this就是新创建的对象</p><h2 id="4-构造函数"><a href="#4-构造函数" class="headerlink" title="4.构造函数"></a>4.构造函数</h2><p>构造函数是==专门用来创建对象==的函数<br><strong>一个构造函数我们也可以称为一个类</strong><br>通过一个构造函数创建的对象，我们称该对象时这个构造函数的实例<br>通过同一个构造函数创建的对象，我们称为一类对象<br>构造函数就是一个普通的函数，只是他的调用方式不同，<br>如果直接调用，它就是一个普通函数<br>如果使用new来调用，则它就是一个构造函数，类名大写  </p><p>例子：  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params">name , age , gender</span>)</span>&#123;  <br>    <span class="hljs-built_in">this</span>.name = name;  <span class="hljs-comment">//必须写this 不然找不到本次的对象了，找成全局的了</span><br>    <span class="hljs-built_in">this</span>.age = age;  <br>    <span class="hljs-built_in">this</span>.gender = gender;  <br>    <span class="hljs-built_in">this</span>.sayName = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;  <br>        alert(<span class="hljs-built_in">this</span>.name);  <br>    &#125;;  <br>&#125;  <br></code></pre></td></tr></table></figure><p>另外sayName每次被调用都会是一个新的函数，可以<strong>另写一个函数</strong>，不在构造函数里写。</p><p>构造函数的执行流程：<br>1.创建一个新的对象<br>2.将新的对象作为函数的上下文对象（this）<br>3.执行函数中的代码（我们要做的）<br>4.将新建的对象返回  </p><p><strong>instanceof 实例是否属于某类</strong><br>用来检查一个对象是否是一个类(构造函数)的实例（通过构造函数创造的实例）<br> 语法：对象名 instanceof 构造函数<br>     如果该对象是构造函数的实例，则返回true，否则返回false<br>     <strong>Object是所有对象的父类，所以任何对象和Object做instanceof都会返回true</strong>  </p><p><strong>枚举对象中的属性名</strong><br>for…in<br>语法：        </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> n <span class="hljs-keyword">in</span> 对象)&#123;  <br>  <br>&#125;  <br><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> n <span class="hljs-keyword">in</span> obj)&#123;<br><span class="hljs-built_in">console</span>. log(<span class="hljs-string">&quot;属性名: &quot;</span>+n);<span class="hljs-comment">//输出属性名</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;属性值:&quot;</span>+obj[n]);<br>    <span class="hljs-comment">//输出属性值，一定是[n]的才行 .n不管用因为obj里没n这个名字的属性</span><br>&#125;<br><br></code></pre></td></tr></table></figure><p>for…in语句的循环体会执行多次，对象中有几个属性就会执行几次，<br>    每次将一个属性名赋值给我们定义的变量，我们可以通过它来获取对象中的属性        </p><h2 id="原型（prototype）"><a href="#原型（prototype）" class="headerlink" title="原型（prototype）"></a>原型（prototype）</h2><p> 创建一个函数以后，<strong>解析器都会默认在函数中添加一个函数prototype</strong><br>    prototype属性指向的是一个==对象==，这个对象我们称为原型对象。套娃<br> 当函数作为构造函数使用，<strong>它所创建的对象中都会有一个隐含的属性执行该原型对象。</strong>  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">这个隐含的属性可以通过对象.__proto__来访问。  <br></code></pre></td></tr></table></figure><img src="/2021/07/06/JavaScript-base/Users\Fine\Downloads\codeOflI.github.io-dev\source\_posts\js-note\javaScript\image-20210609203645969.png" alt="image-20210609203645969" style="zoom: 50%;"><p><strong>原型对象就相当于一个公共的区域，凡是通过同一个构造函数创建的对象他们通常都可以访问到相同的原型对象。</strong><br>我们可以将对象中==共有的属性和方法==统一添加到原型对象中，<br>        这样我们只需要添加一次，就可以使所有的对象都可以使用。  </p><p>调用顺序：<br>当我们去访问对象的一个属性或调用对象的一个方法时，它会先自身中寻找，<br>    如果在自身中找到了，则直接使用。<br>    如果没有找到，则去原型对象中寻找，如果找到了则使用，<br>    <strong>如果没有找到，则去原型的原型中寻找（原型对象也是对象，所以它也有自己的原型对象），</strong>依此类推。直到找到Object的原型为止，Object的原型的原型为null，<br>    如果依然没有找到则返回undefined？</p><p><strong>本身是否有某属性</strong><br> <strong>hasOwnProperty()</strong><br>     这个方法可以用来检查<strong>对象自身中</strong>是否含有某个属性，==不包括原型对象中的==。<br>     语法：对象.hasOwnProperty(“属性名”)  </p><h2 id="toString方法"><a href="#toString方法" class="headerlink" title="toString方法"></a>toString方法</h2><p>当我们直接在页面中打印一个对象时console.log()，实际上是输出的对象的toString()方法的返回值 (不同的浏览器可能不是调用这个方法) </p><p>如果我们希望在输出对象时不输出[object Object]，可以为对象添加一个toString()方法      </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//修改Person原型的toString，如果只修改Person.toString，那就写死了只有那一个Person</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-built_in">this</span>.name = name;<br>    ...<br>&#125;;<br>    <span class="hljs-keyword">var</span> per = <span class="hljs-keyword">new</span> Person(实参<span class="hljs-number">1</span>，实参<span class="hljs-number">2</span>);<br>    <br>Person.prototype.toString = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;  <br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Person[name=&quot;</span>+<span class="hljs-built_in">this</span>.name+<span class="hljs-string">&quot;,age=&quot;</span>+<span class="hljs-built_in">this</span>.age+<span class="hljs-string">&quot;,gender=&quot;</span>+<span class="hljs-built_in">this</span>.gender+<span class="hljs-string">&quot;]&quot;</span>;  <br>&#125;;  <br></code></pre></td></tr></table></figure><h2 id="垃圾回收（GC）garbage-collection"><a href="#垃圾回收（GC）garbage-collection" class="headerlink" title="垃圾回收（GC）garbage collection"></a>垃圾回收（GC）garbage collection</h2><p>就像人生活的时间长了会产生垃圾一样，程序运行过程中也会产生垃圾<br>这些垃圾积攒过多以后，会导致程序运行的速度过慢，<br>所以我们需要一个垃圾回收的机制，来处理程序运行过程中产生垃圾<br>当一个对象没有任何的变量或属性对它进行引用，此时我们将永远无法操作该对象，<br>此时这种对象就是一个垃圾，这种对象过多会占用大量的内存空间，导致程序运行变慢，<br>所以这种垃圾必须进行清理。<br>在JS中拥有自动的垃圾回收机制，会自动将这些垃圾对象从内存中销毁，<br>我们不需要也不能进行垃圾回收的操作<br>我们需要做的只是要将不再使用的对象设置null即可  </p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">obj</span> = null<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><h1 id="数组（Array）"><a href="#数组（Array）" class="headerlink" title="数组（Array）"></a>数组（Array）</h1><p> 数组也是一个对象，是一个用来存储数据的对象和Object类似，但是它的存储效率比普通对象要高<br> 数组中保存的内容我们称为元素<br> 数组使用索引（index）来操作元素<br> 索引指由0开始的整数  </p><h2 id="数组的操作："><a href="#数组的操作：" class="headerlink" title="数组的操作："></a>数组的操作：</h2><p> 创建数组  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> arr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>();  <br><span class="hljs-keyword">var</span> arr = [];  <span class="hljs-comment">//（这个好）</span><br></code></pre></td></tr></table></figure><p>向数组中添加元素<br>语法；<br>数组对象[索引] = 值;  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">arr[<span class="hljs-number">0</span>] = <span class="hljs-number">123</span>;  <br>arr[<span class="hljs-number">1</span>] = <span class="hljs-string">&quot;hello&quot;</span>;  <br></code></pre></td></tr></table></figure><p> 创建数组时直接添加元素<br> 语法：  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> arr = [元素<span class="hljs-number">1</span>,元素<span class="hljs-number">2.</span>...元素N]; <br></code></pre></td></tr></table></figure><p> 同一个数组里可以包括不同类型的元素：太神奇了，甚至可以是对象、函数、数组（此时是二维数组）,可改变长度。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">123</span>,<span class="hljs-string">&quot;hello&quot;</span>,<span class="hljs-literal">true</span>,<span class="hljs-literal">null</span>];  <br></code></pre></td></tr></table></figure><p>不同：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">arr2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(<span class="hljs-number">10</span>);<span class="hljs-comment">//创建一个数组，长度为10的空数组。</span><br>arr = [<span class="hljs-number">10</span>];<span class="hljs-comment">//创建一个数组，长度为1，是10</span><br></code></pre></td></tr></table></figure><p>​     <strong>使用length属性来操作数组的长度</strong><br>1.获取长度：<br>语法：数组.length<br>length获取到的是数组的最大索引+1<br>对于连续的数组，length获取到的就是数组中元素的个数；<br>对于非连续的数组，会获取到最大索引+1，中间占位了。尽量不要创建非连续的数组。</p><p>2.修改数组的长度：<br>数组.length = 新长度<br>如果修改后的length大于原长度，则多出的部分会空出来<br>如果修改后的length小于原长度，则原数组中多出的元素会被删除</p><p>向数组的最后新添加元素<br>数组[数组.length] = 值;  </p><h2 id="数组的方法"><a href="#数组的方法" class="headerlink" title="数组的方法"></a>数组的方法</h2><table><thead><tr><th>functionName</th><th>function</th><th>usage</th></tr></thead><tbody><tr><td>push()</td><td>用来向数组的末尾添加一个或多个元素，并返回数组新的长度</td><td>语法：数组.push(元素1,元素2,元素N)pop()</td></tr><tr><td>pop()</td><td>用来删除数组的最后一个元素，并返回被删除的元素</td><td></td></tr><tr><td>unshift()</td><td>向数组的开头添加一个或多个元素，并返回数组的新的长度</td><td></td></tr><tr><td>shift()</td><td>删除数组的开头的一个元素，并返回被删除的元素</td><td></td></tr><tr><td>reverse()</td><td>可以用来反转一个数组，它会对原数组产生影响</td><td></td></tr><tr><td>concat()</td><td>可以连接两个或多个数组，它不会影响原数组，而是新数组作为返回值返回</td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr></tbody></table><h3 id="forEach-IE8以上兼容"><a href="#forEach-IE8以上兼容" class="headerlink" title="forEach( ) IE8以上兼容"></a>forEach( ) IE8以上兼容</h3><p>方法需要一个函数作为参数<br>-像这种函数，由我们创建但是不由我们调用的，我们称为回调函数<br>-数组中有几个元素函数就会执行几次，每次执行时，浏览器会将遍历到的元素<br>以实参的形式传递进来，我们可以来定义形参，来读取这些内容</p><p>value:当前索引对应元素<br>index:当前索引<br>object:当前整个数组</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript">arr.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value，index,object</span>)</span>&#123;<br><span class="hljs-built_in">console</span>. log( <span class="hljs-string">&quot;a = &quot;</span>+a);&#125;);<br><br></code></pre></td></tr></table></figure><h3 id="slice-start-end"><a href="#slice-start-end" class="headerlink" title="slice(start,end)"></a>slice(start,end)</h3><pre><code> 可以从一个数组中截取指定的元素   该方法不会影响原数组，而是将截取到的内容封装为一个新的数组并返回   参数：      1.截取开始位置的索引（包括开始位置）      2.截取结束位置的索引（不包括结束位置）  第二个参数可以省略不写，如果不写则一直截取到最后参数可以传递一个负值，如果是负值，则从后往前数，也遵循左闭右开       var result =arr.slice(0,2); //不会影响原数组，写一个变量保存它</code></pre><h3 id="splice"><a href="#splice" class="headerlink" title="splice()"></a>splice()</h3><pre><code> 可以用来删除数组中指定元素，并使用新的元素替换      该方法会将删除的元素封装到新数组中返回   参数：      1.删除开始位置的索引      2.删除的个数      3.三个以后，都是替换的元素，这些元素将会插入到开始位置索引的前边,可以直接splice(1,0,&quot;xx&quot;)用来插入 </code></pre><h3 id="join-splitor"><a href="#join-splitor" class="headerlink" title="join([splitor])"></a>join([splitor])</h3><p> 可以将一个数组连接并转换为一个字符串,不影响原数组，将转换后的字符串作为结果返回</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">result</span> = arr.join(“连接符”)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p> 参数：<br>    需要一个字符串作为参数，这个字符串将会作为连接符来连接数组中的元素<br>    原本会被逗号连起来，连接符替代逗号将他们连起来  </p><h3 id="sort"><a href="#sort" class="headerlink" title="sort()"></a>sort()</h3><p> 可以对一个数组中的内容进行排序，默认是按照Unicode编码进行排序（会出现11&gt;5的情况）<br>    调用以后，会直接修改原数组。<br> 可以自己指定排序的规则，需要一个回调函数作为参数：  </p><p>我们可以自己来指定排序的规则<br>我们可以在sort()添加一个回调函数，来指定排序规则，<br>    回调函数中需要定义两个形参,<br>    浏览器将会分别使用数组中的元素作为实参去调用回调函数<br>    使用哪个元素调用不确定，但是肯定的是在数组中a一定在b前边  </p><ul><li><p>浏览器会根据回调函数的返回值来决定元素的顺序，<br>如果返回一个大于0的值，则元素会交换位置<br>如果返回一个小于0的值，则元素位置不变<br>如果返回一个0，则认为两个元素相等，也不交换位置  </p></li><li><p>如果需要升序排列，则返回 a-b<br>如果需要降序排列，则返回b-a  </p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">a,b</span>)</span>&#123;  <br><span class="hljs-comment">//升序排列  </span><br><span class="hljs-comment">//return a-b;  </span><br>  <br><span class="hljs-comment">//降序排列  </span><br><span class="hljs-keyword">return</span> b-a;  <br>&#125;  <br></code></pre></td></tr></table></figure><h2 id="遍历数组"><a href="#遍历数组" class="headerlink" title="遍历数组"></a>遍历数组</h2><p> 遍历数组就是将数组中元素都获取到<br> 一般情况我们都是使用for循环来遍历数组</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i=<span class="hljs-number">0</span> ; i&lt;数组.length ; i++)&#123;  <br>    <span class="hljs-comment">//数组[i]  </span><br>&#125;  <br></code></pre></td></tr></table></figure><p> 使用forEach()方法来遍历数组（不兼容IE8）  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript">数组.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value , index , obj</span>)</span>&#123;  <br>  <br>&#125;);  <br></code></pre></td></tr></table></figure><p>forEach()方法需要一个回调函数作为参数，<br>数组中有几个元素，回调函数就会被调用几次，<br>每次调用时，都会将遍历到的信息以实参的形式传递进来，<br>我们可以定义形参来获取这些信息。<br>value:正在遍历的元素<br>index:正在遍历元素的索引<br>obj:被遍历对象    </p><h1 id="常用类和方法"><a href="#常用类和方法" class="headerlink" title="常用类和方法"></a>常用类和方法</h1><h2 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h2><p>在JS中为我们提供了<strong>三个包装类：</strong><br>String() Boolean() Number()<br> 通过这三个包装类可以转化为基本数据类型的==对象==，他的功能比基本数据类型更加强大<br>例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> num = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Number</span>(<span class="hljs-number">2</span>);  <br><span class="hljs-keyword">var</span> str = <span class="hljs-keyword">new</span> <span class="hljs-built_in">String</span>(<span class="hljs-string">&quot;hello&quot;</span>);  <br><span class="hljs-keyword">var</span> bool = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Boolean</span>(<span class="hljs-literal">true</span>); <br></code></pre></td></tr></table></figure><p>但是在实际应用中千万不要这么用！！！↑  比如创建一个false的布尔对象，它在用的时候会当true用，有歧义。</p><p>事实上，解析器可以将基本数据类型自动转换成基本数据类型对象：<br>当我们去对一个基本数据类型调用属性和方法时，<br><strong>解析器会临时将其转换为对应的包装类，然后再去操作属性和方法，</strong><br>操作完成以后再将这个临时对象进行销毁。  所以如果再读的时候，也会undefined，因为虽然读的时候又临时转换了，但它是另一个了，上一个已经被销毁了。</p><h2 id="Date"><a href="#Date" class="headerlink" title="Date"></a>Date</h2><p>日期的对象，在JS中通过Date对象来表示一个时间<br>创建对象<br> 创建一个当前的时间对象  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> d = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();  <br></code></pre></td></tr></table></figure><p> 创建一个指定的时间对象  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> d = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-string">&quot;月/日/年 时:分:秒&quot;</span>);  <span class="hljs-comment">//&quot;12/03/2016 11:10:30&quot;</span><br></code></pre></td></tr></table></figure><h3 id="方法："><a href="#方法：" class="headerlink" title="方法："></a>方法：</h3><table><thead><tr><th>name</th><th></th></tr></thead><tbody><tr><td>getDate()</td><td>当前日期对象是几日（1-31）</td></tr><tr><td>getDay()</td><td>返回当前日期对象时周几（0-6）<br>         0 周日<br>         1 周一 。。。</td></tr><tr><td>getMonth()</td><td>返回当前日期对象的月份（0-11）<br>     0 一月 1 二月 。。。</td></tr><tr><td>getFullYear()</td><td>从 Date 对象以四位数字返回年份。</td></tr><tr><td>getHours()</td><td>返回 Date 对象的小时 (0 ~ 23)。</td></tr><tr><td>getMinutes()</td><td>返回 Date 对象的分钟 (0 ~ 59)。</td></tr><tr><td>getSeconds()</td><td>返回 Date 对象的秒数 (0 ~ 59)。</td></tr><tr><td>getMilliseconds()</td><td>返回 Date 对象的毫秒(0 ~ 999)。</td></tr><tr><td>getTime()</td><td>返回当前日期对象的时间戳<br>     时间戳，指的是从1970年月1日 0时0分0秒，<strong>到现在时间的毫秒数</strong><br>        计算机底层保存时间都是以时间戳的形式保存的。</td></tr><tr><td>Date.now()</td><td>可以获取当前代码执行时的时间戳</td></tr></tbody></table><h2 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h2><p>Math属于一个工具类，它不需要我们创建对象，它里边封装了属性运算相关的常量和方法<br>我们可以直接使用它来进行数学运算相关的操作<br>方法：<br>Math.PI<br>     常量，圆周率<br>Math.abs()<br>     绝对值运算<br>Math.ceil()<br>     向上取整<br>Math.floor()<br>     向下取整<br>Math.round()<br>     四舍五入取整<br>Math.random()<br>     生成一个01之间的随机数<br>     生成一个xy之间的随机数<br>        Math.round(Math.random()*(y-x)+x);<br>Math.pow(x,y)<br>     求x的y次幂<br>Math.sqrt()<br>     对一个数进行开方<br>Math.max()<br>     求多个数中最大值<br>Math.min()<br>     求多个数中的最小值  </p><h2 id="字符串的相关的方法"><a href="#字符串的相关的方法" class="headerlink" title="字符串的相关的方法"></a>字符串的相关的方法</h2><p>使用ES6中的字符串新方法  </p><p> <strong>String.prototype.padStart(maxLength, fillString=’’)</strong> 或 **String.prototype.padEnd(maxLength, fillString=’’)**来填充字符串；  </p><p>length<br> 获取字符串的长度</p><p>charAt()<br> 根据索引获取指定的字符</p><p>charCodeAt()<br> 根据索引获取指定的Unicode字符编码</p><p><strong>String.fromCharCode()</strong><br> <strong>根据Unicode字符编码获取字符</strong></p><p>indexOf()<br>result = str.indexOf(“h”)返回字符串里的某字符的第一次出现的索引，没找到的话返回-1。<br>result = str.indexOf(“h”, 1);指定从索引1开始查找h</p><p>lastIndexOf()<br>返回字符串里的某字符的从后往前找 第一次出现的索引（还是正序的那个），没找到的话返回-1。<br> 可以指定一个第二个参数，来表示开始查找的位置。</p><p>slice(start,[end])<br> 可以从一个字符串中截取指定的内容，并将截取到内容返回，不会影响原变量<br> 参数：<br>    第一个：截取开始的位置（包括开始）<br>    第二个：截取结束的位置<strong>（不包括结束）</strong><br>         可以省略第二个参数，如果省略则一直截取到最后<br>     可以传负数，如果是负数则从后往前数</p><p>substring()<br> 和slice()基本一致，不同的是它不能接受负值作为参数，如果设置一个负值，则会自动修正为0，<br>    <strong>substring()中 参数会自动调整位置 为从小到大</strong>  </p><p>substr()<br> 和slice()基本一致，不同的是它第二个参数不是索引，而是截取的数量  </p><p>toLowerCase()<br> 将字符串转换为小写并返回  </p><p>toUpperCase()<br> 将字符串转换为大写并返回  </p><h3 id="正则表达相关方法"><a href="#正则表达相关方法" class="headerlink" title="正则表达相关方法"></a>正则表达相关方法</h3><p><strong>split()</strong><br> 可以根据指定内容将一个字符串拆分为一个数组Array<br> 参数：<br>     需要一个字符串作为参数，将会根据字符串去拆分数组<br>    可以接收一个正则表达式，此时会根据正则表达式去拆分数组<br>    这个方法不指定全局匹配的话，也一样==是全局匹配==的。</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">var</span> result = str.split( <span class="hljs-regexp">/[A-z]/</span>);<span class="hljs-comment">//逢字母拆</span><br></code></pre></td></tr></table></figure><pre><code>  如果空参数，就将每个字符都分开，各成数组</code></pre><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">str</span> = <span class="hljs-string">&quot;abc ,bcd ,efg,hij&quot;</span><span class="hljs-comment">;</span><br><span class="hljs-attr">result</span> = str.split( <span class="hljs-string">&quot;d &quot;</span>)<span class="hljs-comment">;//&quot;abc,bc,,efg,hij&quot; 数组长度为2 没有d</span><br></code></pre></td></tr></table></figure><p><strong>match()</strong><br>     可以根据正则表达式，从一个字符串中将符合条件的内容提取出来，提取为数组<br>     默认情况下我们的match只会找到==第一个==符合要求的内容，找到以后就停止检索<br>        我们可以设置正则表达式为全局匹配模式，这样就会匹配到==所有==的内容：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">result = str.match(<span class="hljs-regexp">/[a-z]/gi</span>);<span class="hljs-regexp">//</span>找出所有字母<br></code></pre></td></tr></table></figure><p>​        可以为一个正则表达式设置多个匹配模式，且顺序无所谓<br>​     match()会将匹配到的内容封装到一个数组中返回，即使只查询到一个结果  </p><p><strong>replace()</strong><br>     可以将字符串中指定内容替换为新的内容<br>    参数：<br>        1.被替换的内容，可以接受一个正则表达式作为参数<br>        <strong>2.新的内容</strong>  空串则为删除””<br>    默认只会替换第一个</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">result</span> = str.replace( <span class="hljs-string">&quot;a&quot;</span> , <span class="hljs-string">&quot;@_@&quot;</span>)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p><strong>search()</strong><br>     可以搜索字符串中是否含有指定内容<br>     如果搜索到指定内容，则会返回第一次出现的索引，如果没有搜索到返回1<br>     它可以接受一个正则表达式作为参数，然后会根据正则表达式去检索字符串<br>    即使全局匹配了，它也==只会查找第一个==</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">result</span> = str.search( /a[bef]c/ )<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>​     serach()只会查找第一个，即使设置全局匹配也没用              </p><h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h1><p>正则用来定义一些字符串的规则，程序可以根据这些规则来判断一个字符串是否符合规则，<br>也可以将一个字符串中符合规则的内容提取出来。比如说一个邮箱名格式是否正确。<br><strong>创建正则表达式</strong>  </p><p>第一种(更灵活，表达式可以是变量)：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">var</span> reg = <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(<span class="hljs-string">&quot;正则表达式&quot;</span>,<span class="hljs-string">&quot;匹配模式&quot;</span>);     <span class="hljs-comment">//（Regular expression 它是个对象）</span><br></code></pre></td></tr></table></figure><p>比如，var reg = new RegExp(“a”); 检查字符串是否含有小写a</p><p>匹配模式：<br>    i 忽略大小写<br>    g 全局匹配模式</p><p>注意：使用构造函数时，由于它的参数是一个字符串，而\是字符串中转义字符，如果要使用\则需要使用\来代替  </p><p>第二种（更方便）：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">var</span> reg = <span class="hljs-regexp">/正则表达式/</span>匹配模式 （匹配模式可以多个一起写：/gi）  <br><br>reg= <span class="hljs-regexp">/a/i</span>;<br></code></pre></td></tr></table></figure><h2 id="语法："><a href="#语法：" class="headerlink" title="语法："></a>语法：</h2><p>匹配模式：<br>    i:忽略大小写（ignore）<br>    g:全局匹配模式（默认为1次）<br>     设置匹配模式时，可以都不设置，也可以设置1个，也可以全设置，设置时没有顺序要求  </p><p>正则语法<br>    | 或<br>    [] 或 （和上面完全一样）<br>    [^ ] 除了  [^ab]: 有a有b都不行</p><pre><code>**[x-y] x的ascii到y的ascii码之间的值**  </code></pre><p>[a-z] 小写字母 <strong>（也可以[e-i])</strong><br>[A-Z] 大写字母    /[A-Z]/i<br>[A-z] 任意字母,<strong>但是还包括了其他ASCII在此之中的</strong><br>[0-9] 任意数字<br>/a[bde]c/      abc adc aec </p><p><strong>元符号</strong>  </p><p>检查一个字符串中是否含有 .<br>. 表示任意字符  在正则表达式中使用\作为转义字符  . 来表示.<br>注意:使用构造函数时，由于它的参数是一个字符串，而\是字符串中转义字符， 所以要多加一个\才能正确识别</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">reg</span> =new RegExp(<span class="hljs-string">&quot;\\.&quot;</span>)<span class="hljs-comment">; </span><br></code></pre></td></tr></table></figure><p>\ . 表示\  </p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">reg</span> =new RegExp( <span class="hljs-string">&quot;\\\\&quot;</span>)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>\w<br>    任意字母、数字、下划线_  [A-z0-9_]<br>  \W<br>    除了字母、数字、_  [ ^A-z0-9_]<br>  \d<br>    任意的数字 [0-9]<br>  \D<br>    除了数字 [ ^0-9]<br>  \s<br>    空格<br>  \S<br>    除了空格<br>  \b<br>    单词边界</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stata"><span class="hljs-keyword">reg</span> = /\bchild\b/;<br>console.<span class="hljs-built_in">log</span>(<span class="hljs-keyword">reg</span>.<span class="hljs-keyword">test</span>(<span class="hljs-string">&quot;hello child&quot;</span>));<br><span class="hljs-comment">//单词是独立的，不能跟其他的连起来比如说child</span><br><br></code></pre></td></tr></table></figure><p>  \B<br>    除了单词边界  </p><p><strong>量词</strong><br>     通过量词可以设置一个内容出现的次数<br>     量词只对它前边的一个内容起作用，如果要好几个的话加括号<br>     {n} 正好出现n次，多了也行？<br>     {m,n} 出现mn次 双闭区间<br>     {m,} m次以上  </p><ul><li>至少一个，相当于{1,}<br>*0个或多个，相当于{0,}<br> ? 0个或1个，相当于{0,1}      </li></ul><p><strong>边界表达式</strong>（不要在java中用，javaScript中用）<br>    ^:正则开始<br>    $:正则结束 ：<strong>注意结束前一个才是结束匹配</strong>  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript">reg = <span class="hljs-regexp">/^a/</span>;  <span class="hljs-comment">//   /[^a]/ 是除了</span><br>reg = <span class="hljs-regexp">/b$/</span>;  <br>reg= <span class="hljs-regexp">/^a$/</span> ; <span class="hljs-comment">//这样的只有a符合 aaa不符合</span><br>reg = <span class="hljs-regexp">/^a|a$/</span> ; <span class="hljs-comment">//这样的才是以a开头和结尾</span><br>str = str.replace( <span class="hljs-regexp">/^\s*│\s*$/g</span>,<span class="hljs-string">&quot;&quot;</span>);<span class="hljs-comment">//去除开头和结尾所有空格的，不去中间的</span><br><br></code></pre></td></tr></table></figure><p><strong>创建一个正则表达式，用来检查一个字符串是否是一个合法手机号</strong><br>手机号的规则:<br>1 3 567890123 (11位)<br>1．以1开头<br>2．第二位3-9任意数字</p><p>三位以后任意数字9个<br>即要求：^1    [3-9]    [0-9] {9}$</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">var</span> phoneStr = <span class="hljs-string">&quot;13067890123&quot;</span>;<br><span class="hljs-attribute">var</span> phoneReg =/^<span class="hljs-number">1</span>[<span class="hljs-number">3</span>-<span class="hljs-number">9</span>][<span class="hljs-number">0</span>-<span class="hljs-number">9</span>]&#123;<span class="hljs-number">9</span>&#125;$/;<br><br></code></pre></td></tr></table></figure><h2 id="方法：-1"><a href="#方法：-1" class="headerlink" title="方法："></a>方法：</h2><p><strong>test()</strong><br>     可以用来检查一个字符串是否符合正则表达式<br>     如果符合返回true，否则返回false </p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stata"><span class="hljs-keyword">reg</span> = /\bchild\b/;<br>console.<span class="hljs-built_in">log</span>(<span class="hljs-keyword">reg</span>.<span class="hljs-keyword">test</span>(<span class="hljs-string">&quot;hello child&quot;</span>));<br></code></pre></td></tr></table></figure><p><strong>去掉两端的空格:</strong>  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> s = <span class="hljs-string">&quot;        f    afa    &quot;</span>;   <br>s = s.replace(<span class="hljs-regexp">/^\s*|\s*$/g</span>,<span class="hljs-string">&quot;&quot;</span>);  <br></code></pre></td></tr></table></figure><h1 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h1><p>Document Object Model<br>文档对象模型，通过DOM可以来任意来修改网页中各个内容<br>1文档<br> 文档指的是网页，一个网页就是一个文档<br>2对象<br> 对象指将网页中的每一个==节点==都转换为对象<br>    转换完对象以后，就可以以一种纯面向对象的形式来操作网页了<br>3模型<br> 模型用来表示节点和节点之间的关系，方便操作页面<br>4节点（Node）<br> 节点是构成网页的最基本的单元，网页中的每一个部分都可以称为是一个节点<br> 虽然都是节点，但是节点的类型却是不同的</p><p> 常用的节点<br>     文档节点 （Document），代表整个网页<br>     元素节点（Element），代表网页中的标签<br>     属性节点（Attribute），代表标签中的属性<br>     文本节点（Text），代表网页中的文本内容  </p><p><img src="https://img-blog.csdnimg.cn/img_convert/8f78b104d22b7df059153d6b9164e83b.gif" alt="img">  </p><h2 id="DOM操作"><a href="#DOM操作" class="headerlink" title="DOM操作"></a>DOM操作</h2><p> DOM查询<br> 在网页中浏览器已经为我们提供了<strong>document对象</strong>，<br>    <strong>它代表的是整个网页，它是window对象的属性，可以在页面中直接使用。</strong><br> document查询方法：<br>     根据元素的id属性查询一个元素节点对象：<br>         document.getElementById(“id属性值”);<br>     根据元素的name属性值查询一组元素节点对象:<br>         document.getElementsByName(“name属性值”);<br>     根据标签名来查询一组元素节点对象：<br>         document.getElementsByTagName(“标签名”);  </p><p> 元素的属性：<br>     <strong>读取元素的属性：</strong><br>        语法：元素.属性名<br>        例子：ele.name<br>              ele.id<br>              ele.value<br>              ele.className<br>            注意：class属性不能采用这种方式，<br>            <strong>读取class属性时需要使用 元素.className</strong>       </p><p>修改元素的属性：<br>    语法：元素.属性名 = 属性值  </p><p> innerHTML<br>     使用该属性可以获取或设置元素内部的HTML代码  </p><h2 id="事件（Event）"><a href="#事件（Event）" class="headerlink" title="事件（Event）"></a>事件（Event）</h2><p> 事件指的是用户和浏览器之间的交互行为。比如：点击按钮、关闭窗口、鼠标移动。。。<br> 我们可以为事件来绑定回调函数来响应事件。<br>W3S : DOM Event<br> 绑定事件的方式：<br>    1.可以在标签的事件属性中设置相应的JS代码，但是结构和行为耦合了，不方便维护，不推荐使用<br>        例子：  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;button onclick=<span class="hljs-string">&quot;js代码。。。&quot;</span>&gt;按钮&lt;/button&gt;  <br></code></pre></td></tr></table></figure><p>2.可以通过为对象的指定事件属性设置回调函数的形式来处理事件<br>    例子：  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;button id=<span class="hljs-string">&quot;btn&quot;</span>&gt;按钮&lt;/button&gt;  <br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">  </span></span><br><span class="javascript"><span class="xml">    <span class="hljs-keyword">var</span> btn = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;btn&quot;</span>);  </span></span><br><span class="javascript"><span class="xml">    btn.onclick = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;  </span></span><br><span class="javascript"><span class="xml">  </span></span><br><span class="javascript"><span class="xml">    &#125;;  </span></span><br><span class="javascript"><span class="xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span>  <br></code></pre></td></tr></table></figure><p>文档的加载<br> 浏览器在加载一个页面时，是按照自上向下的顺序加载的，加载一行执行一行。<br> 如果将js代码编写到页面的上边，当代码执行时，页面中的DOM对象还没有加载，<br>    此时将会无法正常获取到DOM对象，导致DOM操作失败。<br> 解决方式一：<br>     可以将js代码编写到body里  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;body&gt;  <br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;btn&quot;</span>&gt;</span>按钮<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span>  <br>  <br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">  </span></span><br><span class="javascript"><span class="xml"><span class="hljs-keyword">var</span> btn = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;btn&quot;</span>);  </span></span><br><span class="javascript"><span class="xml">btn.onclick = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;  </span></span><br><span class="javascript"><span class="xml">  </span></span><br><span class="javascript"><span class="xml">&#125;;  </span></span><br><span class="javascript"><span class="xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span>  <br>&lt;/body&gt;  <br></code></pre></td></tr></table></figure><p> 解决方式二：（更优的方法，其实也差不多。）<br>    可以写到前面head标签里<br>     将js代码编写到window.onload = function(){}中<br>     window.onload 对应的回调函数会在==整个页面加载完毕==以后才执行，<br>        所以可以确保代码执行时，DOM对象已经加载完毕了          </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;script&gt;  <br>    <span class="hljs-built_in">window</span>.onload = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;  <br>        <span class="hljs-keyword">var</span> btn = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;btn&quot;</span>);  <br>        btn.onclick = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;  <br>        &#125;;  <br>    &#125;;  <br>&lt;/script&gt;    <br></code></pre></td></tr></table></figure><h2 id="DOM查询"><a href="#DOM查询" class="headerlink" title="DOM查询"></a>DOM查询</h2><p>通过具体的元素节点来查询<br>元素.getElementsByTagName()<br>通过标签名查询当前元素的指定后代元素  </p><p><strong>子节点包括便签元素中的文本，子元素自包含标签元素</strong>  </p><p>元素.childNodes<br> 获取当前元素的<strong>所有子节点</strong><br> <strong>会获取到空白的文本子节点</strong><br>childNodes属性会获取包括文本节点在内的所有节点：根据DOM标签标签间空白也会当成文本节点<br> 注意：在IE8及以下的浏览器中，不会将空白文本当成子节点，所以该属性在IE8中会返回4个子元素而其他浏览器是9个  </p><p>元素.children（推荐使用）<br> 获取当前元素的<strong>所有子元素</strong>  </p><p>元素.firstChild<br> 获取当前元素的<strong>第一个子节点</strong>，会获取到空白的文本子节点  </p><p>元素.lastChild<br> 获取当前元素的<strong>最后一个子节点</strong>  </p><p>元素.parentNode<br> 获取当前元素的父元素  </p><p>元素.previousSibling<br> 获取当前元素的前一个兄弟节点，会获取空白  </p><p>previousElementSibling获取前一个兄弟元素，不包括空白，IE8及以下不支持  </p><p>元素.nextSibling<br> 获取当前元素的后一个兄弟节点  </p><p>firstElementChild获取当前元素的第一个子元素（不包括空白）<br> firstElementChild不支持IE8及以下的浏览器，如果需要兼容他们尽量不要使用  </p><p>innerHTML和innerText<br>这两个属性并没有在DOM标准定义，但是大部分浏览器都支持这两个属性<br>两个属性作用类似，都可以获取到标签内部的内容，<br><strong>不同是innerHTML会获取到html标签，而innerText会自动去除标签</strong><br>如果使用这两个属性来设置标签内部的内容时，没有任何区别的<br>对于自结束标签，innerHTML没有意义，获取不到东西。可以直接元素对象.属性名name\value等：但是class不行它是保留字，需要用className。      </p><p><strong>读取标签内部的文本内容</strong>  </p>h1中的文本内容  <p>元素.firstChild.nodeValue  </p><h2 id="document对象的其他的属性和方法"><a href="#document对象的其他的属性和方法" class="headerlink" title="document对象的其他的属性和方法"></a>document对象的其他的属性和方法</h2><p>document.all<br> <strong>获取页面中的所有元素</strong>，相当于document.getElementsByTagName(“*”);  </p><p>document.documentElement<br> <strong>获取页面中html根元素</strong>  </p><p>document.body<br> 获取页面中的body元素  </p><p>document.getElementsByClassName()<br> <strong>根据元素的class属性值查询一组元素节点对象</strong><br> 这个方法不支持IE8及以下的浏览器  </p><p>document.querySelector()<br> <strong>根据CSS选择器去页面中查询一个元素</strong><br> 如果匹配到的元素有多个，则它会返回查询到的第一个元素      </p><p>document.querySelectorAll()<br> 根据CSS选择器去页面中查询一组元素，很强大！！！<br> 会将匹配到所有元素封装到一个数组中返回，即使只匹配到一个  </p><h2 id="DOM修改"><a href="#DOM修改" class="headerlink" title="DOM修改"></a>DOM修改</h2><p>document.createElement(“TagName”)<br>    可以用于创建一个元素节点对象，<br>    它需要一个标签名作为参数，将会根据该标签名创建元素节点对象，<br>    并将创建好的对象作为返回值返回<br>document.createTextNode(“textContent”)<br>可以根据文本内容创建一个文本节点对象  </p><p><strong>父节点.appendChild(子节点)</strong><br>  向父节点中添加指定的子节点，如把文本插入到li。<br><strong>父节点.insertBefore(新节点,旧节点)</strong><br> 将一个新的节点插入到旧节点的前边<br>父节点.replaceChild(新节点,旧节点)<br> 使用一个新的节点去替换旧节点  </p><p><strong>父节点.removeChild(子节点)</strong><br> 删除指定的子节点<br>  推荐方式：<strong>子节点.parentNode.removeChild(子节点)</strong>   bj.parentNode.removeChild(bj);</p><p><strong>以上方法，也可以==改变了相应元素（标签）的=nnerHTML==的值。两种方式结合使用更好，只改变广州自己</strong>   没看103-106增删改查 练习。 </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript">myClick(<span class="hljs-string">&quot;btn07&quot;</span>,<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;  <br>    <span class="hljs-comment">//向city中添加广州  </span><br>    <span class="hljs-keyword">var</span> city = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;city&quot;</span>);  <br>  <br>    <span class="hljs-comment">/*  </span><br><span class="hljs-comment">* 使用innerHTML也可以完成DOM的增删改的相关操作  </span><br><span class="hljs-comment">* 一般我们会两种方式结合使用  </span><br><span class="hljs-comment">*/</span>  <br>    <span class="hljs-comment">//city.innerHTML += &quot;&lt;li&gt;广州&lt;/li&gt;&quot;;  </span><br>  <br>    <span class="hljs-comment">//创建一个li  </span><br>    <span class="hljs-keyword">var</span> li = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&quot;li&quot;</span>);  <br>    <span class="hljs-comment">//向li中设置文本  </span><br>    li.innerHTML = <span class="hljs-string">&quot;广州&quot;</span>;  <br>    <span class="hljs-comment">//将li添加到city中  </span><br>    city.appendChild(li);  <br>  <br>&#125;);  <br></code></pre></td></tr></table></figure><h2 id="DOM对CSS的操作"><a href="#DOM对CSS的操作" class="headerlink" title="DOM对CSS的操作"></a>DOM对CSS的操作</h2><h3 id="读取和修改内联样式"><a href="#读取和修改内联样式" class="headerlink" title="读取和修改内联样式"></a>读取和修改内联样式</h3><p>使用style属性来操作元素的内联样式<br>    1只能读取==内联==样式,无法读取样式表中的样式：<br>    语法：元素.style.样式名<br>例子：<br>    元素.style.width<br>    元素.style.height<br>    注意：<strong>如果样式名中带有-（在JS中不合法，会被认成减号），则需要将样式名修改为驼峰命名法将-去掉，然后后的字母改大写</strong><br>    比如：backgroundcolor &gt; backgroundColor<br>    borderwidth &gt; borderWidth</p><p>2修改内联样式：<br>语法：元素.style.样式名 = ‘’样式值’’<br>W3S手册-CSS-js语法 可以查看所有样式名</p><p> <strong>通过style修改和读取的样式都是内联样式</strong>，由于内联样式的优先级比较高，<br>    所以我们通过JS来修改的样式，往往会立即生效，<br>    <strong>但是如果样式中设置了!important，则内联样式将不会生效。不要用它</strong>  </p><h3 id="读取元素的当前样式"><a href="#读取元素的当前样式" class="headerlink" title="读取元素的当前样式"></a>读取元素的当前样式</h3><p>正常浏览器（不支持IE8以下的）<br>1 <strong>使用getComputedStyle(要获取的样式，伪元素)</strong><br> 这个方法是window对象的方法，返回一个对象：这个对象中保存着当前元素生效样式。<br>此样式如果没有设置，则会获得真实值。（例如没设置宽度，不会获取到auto 而是一个确定的长度）<br> 参数：<br>    1.要获取样式的元素<br>    2.可以传递一个伪元素，一般传null<br> 例子：<br>    获取元素的宽度<br>        getComputedStyle(box , null)[“width”];<br> 通过该方法读取到样式都是只读的不能修改  </p><p> 2<strong>（只有IE支持！！！！）使用currentStyle读取当前的样式，是啥就读啥</strong><br> 语法：<br>    元素.currentStyle.样式名<br> 例子：<br>    box.currentStyle[“width”]<br> 通过这个属性读取到的样式是只读的不能修改  </p><p>3<strong>实现兼容性</strong>  </p><p>//对象.属性不存在，不会报错，如果直接寻找对象，（当前作用域到全局作用域）找不到会报错  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/*  </span><br><span class="hljs-comment">* 定义一个函数，用来获取指定元素的当前的样式  </span><br><span class="hljs-comment">* 参数：  </span><br><span class="hljs-comment">* obj 要获取样式的元素  </span><br><span class="hljs-comment">* name 要获取的样式名  </span><br><span class="hljs-comment">*/</span>  <br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getStyle</span>(<span class="hljs-params">obj , name</span>)</span>&#123;  <br><span class="hljs-comment">//对象.属性不存在，不会报错undefined --&gt; 布尔；如果不加window直接寻找对象，（当前作用域到全局作用域）找不到会报错  </span><br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">window</span>.getComputedStyle)&#123;  <br>        <span class="hljs-comment">//正常浏览器的方式，具有getComputedStyle()方法  </span><br>        <span class="hljs-keyword">return</span> getComputedStyle(obj , <span class="hljs-literal">null</span>)[name]; <span class="hljs-comment">//这样的name取得是可变的name，没写死 </span><br>    &#125;<span class="hljs-keyword">else</span>&#123;  <br>        <span class="hljs-comment">//IE8的方式，没有getComputedStyle()方法  </span><br>        <span class="hljs-keyword">return</span> obj.currentStyle[name];  <br>    &#125;  <br>    <span class="hljs-comment">//return window.getComputedStyle?getComputedStyle(obj , null)[name]:obj.currentStyle[name];  </span><br>&#125;  <br></code></pre></td></tr></table></figure><h3 id="DOM其他的样式相关的属性"><a href="#DOM其他的样式相关的属性" class="headerlink" title="DOM其他的样式相关的属性"></a>DOM其他的样式相关的属性</h3><p>注意：以下样式都是只读的,未指明偏移量都是相对于当前窗口左上角  </p><p><img src="https://img-blog.csdnimg.cn/img_convert/0ecd1258ba7b071403775a1f35c2b727.png" alt="img"></p><p>clientHeight<br> 元素的可见高度，包括元素的内容区和内边距的高度；不带单位<br>clientWidth<br> 元素的可见宽度，包括元素的内容区和内边距的宽度<br>offsetHeight<br> 整个元素的高度，包括内容区、内边距、边框<br>offfsetWidth<br> 整个元素的宽度，包括内容区、内边距、边框<br>offsetParent<br> 当前元素的==定位==父元素<br> 离他==最近的==开启了==相对定位position==的祖先元素，如果所有的元素都没有开启定位，则返回body<br>offsetLeft<br>offsetTop<br> 当前元素和定位父元素之间的偏移量<br> offsetLeft水平偏移量  offsetTop垂直偏移量  </p><p>scrollHeight<br>scrollWidth<br> 获取元素整个滚动区域的高度和宽度  </p><p>scrollTop<br>scrollLeft<br> 获取元素垂直和水平滚动条滚动的距离  </p><p>判断滚动条是否滚动到底<br> 垂直滚动条（用的较多）<br>    scrollHeight -scrollTop == clientHeight<br> 水平滚动<br>    scrollWidth -scrollLeft == clientWidth      </p><h1 id="事件（Event）-1"><a href="#事件（Event）-1" class="headerlink" title="事件（Event）"></a>事件（Event）</h1><h2 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a>事件对象</h2><p>当响应函数被调用时，浏览器每次都会将一个事件对象作为实参传递进响应函数中，这个事件event是现成的对象，封装了当前事件的相关信息，比如：鼠标的坐标，键盘的按键，鼠标的按键，滚轮的方向。。  </p><p>可以在响应函数中定义一个形参，来使用事件对象，但是在IE8以下浏览器中事件对象没有做完实参传递，而是作为window对象的属性保存  </p><p>例子：  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript">元素.事件 = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>)</span>&#123;  <br>    event = event || <span class="hljs-built_in">window</span>.event;  <span class="hljs-comment">//存在的话直接返回前面的event不看后面的了</span><br>&#125;;  <br>  <br>元素.事件 = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>)</span>&#123;  <br>e = e || event;  <br>  <br>&#125;;  <br></code></pre></td></tr></table></figure><p><strong>获取到鼠标的坐标</strong><br>  clientX和clientY<br>    用于获取鼠标在当前的可见窗口的坐标，就是短的那个窗口</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">var</span> left = <span class="hljs-keyword">event</span>.clientX;  <br><span class="hljs-keyword">var</span>　top = <span class="hljs-keyword">event</span>.clientY;    <br></code></pre></td></tr></table></figure><p>  div的偏移量，是相对于整个页面的  </p><p>  pageX和pageY 可以获取鼠标相对于当前页面的坐标，就是长的那个窗口<br>    但是这个两个属性在IE8中不支持，所以如果需要兼容IE8，则不要使用</p><h2 id="事件的冒泡（Bubble）"><a href="#事件的冒泡（Bubble）" class="headerlink" title="事件的冒泡（Bubble）"></a>事件的冒泡（Bubble）</h2><p> 事件的冒泡指的是事件向上传导，当后代元素上的事件被触发时，将会导致其祖先元素上的同类事件也会触发。</p><p>例如：span在div里，在body里。[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-RHHCEVdV-1630937238442)(C:\Users\Fine\Downloads\codeOflI.github.io-dev\source_posts\js-note\javaScript\image-20210616160206180.png)]<br> 事件的冒泡大部分情况下都是有益的，如果需要取消冒泡，则需要使用事件对象来取消<br> <strong>可以将事件对象的cancelBubble设置为true，即可取消冒泡</strong><br>   例子：  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript">元素.事件 = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>)</span>&#123;  <br>    event = event || <span class="hljs-built_in">window</span>.event;  <br>    event.cancelBubble = <span class="hljs-literal">true</span>;  <br>&#125;;  <br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> s1 = <span class="hljs-built_in">document</span>.getElementById( <span class="hljs-string">&quot;s1&quot;</span>);<br>s1.onclick = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>)</span>&#123;<br>event = event || <span class="hljs-built_in">window</span>.event;<br>    alert(<span class="hljs-string">&quot;我是span的单击响应函数&quot;</span>);<br><span class="hljs-comment">//取消冒泡</span><br><span class="hljs-comment">//可以将事件对象的cancelBubble设置为true，即可取消冒泡</span><br>    event.cancelBubble = <span class="hljs-literal">true</span>;<br>&#125;;<br><br></code></pre></td></tr></table></figure><h2 id="事件的委派"><a href="#事件的委派" class="headerlink" title="事件的委派"></a>事件的委派</h2><p> 指将事件统一绑定给元素的共同的祖先元素，这样当后代元素上的事件触发时，会一直冒泡到祖先元素，从而通过祖先元素的响应函数来处理事件。  </p><p>事件委派是利用了冒泡，通过委派可以减少事件绑定的次数，提高程序的性能          </p><p>==我们希望，只绑定一次事件，即可应用到多个的元素上，即使元素是后添加的<br>我们可以尝试将其绑定给元素的共同的祖先元素==  </p><p>但是可能祖先的范围很大，我们只要进了它的范围，但没点到里面相应子元素，就触发了事件：利用target找准触发对象<br> <strong>target</strong> : event中的target表示的触发事件的对象  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">if</span>(event.target.className == <span class="hljs-string">&quot;link&quot;</span>)&#123;<span class="hljs-comment">//link是子元素的标识，防止点到子元素之外的父元素内的部分也响应了</span><br>alert(<span class="hljs-string">&quot;我是ul的单击响应函数&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="事件的绑定"><a href="#事件的绑定" class="headerlink" title="事件的绑定"></a>事件的绑定</h2><p>背景：使用 ‘对象.event = 函数’ 的形式绑定响应函数，它只能同时为一个元素的一个事件绑定一个响应函，如果绑定了多个，则后边会覆盖掉前边的.</p><p>addEventListener()<br> 通过这个方法也可以为元素绑定响应函数 可以同时为一个元素的相同事件 绑定多个响应函数 这样当事件被触发时，响应函数将会按照函数的绑定顺序执行  </p><p>参数：<br>    1.事件的字符串，不要on<br>    2.回调函数，当事件触发时该函数会被调用<br>    3.是否在捕获阶段触发事件，需要一个布尔值，一般都传false  </p><p>这个方法不支持IE8及以下的浏览器  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript">btn01.addEventListener(<span class="hljs-string">&quot;click&quot;</span>,<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;  <br>alert(<span class="hljs-number">1</span>);  <br>&#125;,<span class="hljs-literal">false</span>);  <br>  <br>btn01.addEventListener(<span class="hljs-string">&quot;click&quot;</span>,<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;  <br>alert(<span class="hljs-number">2</span>);  <br>&#125;,<span class="hljs-literal">false</span>);  <br></code></pre></td></tr></table></figure><p>attachEvent()  </p><p> 在IE8中可以使用attachEvent()来绑定事件<br>参数：<br>    1.事件的字符串，要on<br>    2.回调函数  </p><p>这个方法也可以同时为一个事件绑定多个处理函数，<br>    不同的是它是后绑定的事件先执行，执行顺序和addEventListener()相反  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript">btn01.attachEvent(<span class="hljs-string">&quot;onclick&quot;</span>,<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;  <br>alert(<span class="hljs-number">1</span>);  <br>&#125;);  <br>  <br>btn01.attachEvent(<span class="hljs-string">&quot;onclick&quot;</span>,<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;  <br>alert(<span class="hljs-number">2</span>);  <br>&#125;);  <br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//定义一个函数，用来为指定元素绑定响应函数  </span><br><span class="hljs-comment">/*  </span><br><span class="hljs-comment"> * addEventListener()中的this，是绑定事件的对象  </span><br><span class="hljs-comment"> * attachEvent()中的this，是window  </span><br><span class="hljs-comment"> *  需要统一两个方法this  </span><br><span class="hljs-comment"> */</span>  <br><span class="hljs-comment">/*  </span><br><span class="hljs-comment"> * 参数：  </span><br><span class="hljs-comment"> * obj 要绑定事件的对象  </span><br><span class="hljs-comment"> * eventStr 事件的字符串(不要on)  </span><br><span class="hljs-comment"> *  callback 回调函数  </span><br><span class="hljs-comment"> */</span>  <br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bind</span>(<span class="hljs-params">obj , eventStr , callback</span>)</span>&#123;  <br>    <span class="hljs-keyword">if</span>(obj.addEventListener)&#123;  <br>        <span class="hljs-comment">//大部分浏览器兼容的方式  </span><br>        obj.addEventListener(eventStr , callback , <span class="hljs-literal">false</span>);  <br>    &#125;<span class="hljs-keyword">else</span>&#123;  <br>        <span class="hljs-comment">/*  </span><br><span class="hljs-comment"> * this是谁由调用方式决定  </span><br><span class="hljs-comment"> * callback.call(obj)  </span><br><span class="hljs-comment"> */</span>  <br>        <span class="hljs-comment">//IE8及以下  </span><br>        obj.attachEvent(<span class="hljs-string">&quot;on&quot;</span>+eventStr , <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123; <span class="hljs-comment">//注意这里直接加on </span><br>            <span class="hljs-comment">//在匿名函数中调用回调函数  </span><br>            callback.call(obj);  <br>        &#125;);  <br>    &#125;  <br>&#125;  <br></code></pre></td></tr></table></figure><h2 id="事件的传播"><a href="#事件的传播" class="headerlink" title="事件的传播"></a>事件的传播</h2><p> 不重要：关于事件的传播网景公司和微软公司有不同的理解<br> 微软公司认为事件应该是由内向外传播，也就是当事件触发时，应该先触发当前元素上的事件，<br>    然后再向当前元素的祖先元素上传播，也就说事件应该在冒泡阶段执行。<br> 网景公司认为事件应该是由外向内传播的，也就是当前事件触发时，应该先触发当前元素的最外层的祖先元素的事件，<br>    然后在向内传播给后代元素</p><p> W3C综合了两个公司的方案，将事件传播分成了三个阶段<br>    1.捕获阶段<br>         在捕获阶段时从最外层的祖先元素，向目标元素进行事件的捕获，但是默认此时不会触发事件<br>    2.目标阶段<br>         事件捕获到目标元素，捕获结束开始在目标元素上触发事件<br>    3.冒泡阶段<br>         事件从目标元素向他的祖先元素传递，依次触发祖先元素上的事件  </p><p> 如果希望在捕获阶段就触发事件，可以将addEventListener()的第三个参数设置为true（外→里执行，点了一个子元素的话先执行它的最父元素。有点奇怪。）<br>    一般情况下我们不会希望在捕获阶段触发事件，所以这个参数一般都是false  </p><p> IE8及以下的浏览器中没有捕获阶段  </p><h2 id="常用事件"><a href="#常用事件" class="headerlink" title="常用事件"></a>常用事件</h2><h3 id="鼠标事件（第三集没看完）"><a href="#鼠标事件（第三集没看完）" class="headerlink" title="鼠标事件（第三集没看完）"></a>鼠标事件（第三集没看完）</h3><p>拖拽事件<br>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-J32vzBDZ-1630937238443)(C:\Users\Fine\Downloads\codeOflI.github.io-dev\source_posts\js-note\javaScript\image-20210616195752202.png)]</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;!DOCTYPE html&gt;  <br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span>  </span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>  </span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span>  </span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>  </span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/css&quot;</span>&gt;</span><span class="css">  </span></span><br><span class="css"><span class="xml">  </span></span><br><span class="css"><span class="xml">    <span class="hljs-selector-id">#box1</span>&#123;  </span></span><br><span class="css"><span class="xml"><span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;  </span></span><br><span class="css"><span class="xml"><span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;  </span></span><br><span class="css"><span class="xml"><span class="hljs-attribute">background-color</span>: red;  </span></span><br><span class="css"><span class="xml"><span class="hljs-attribute">position</span>: absolute;  </span></span><br><span class="css"><span class="xml">&#125;  </span></span><br><span class="css"><span class="xml">  </span></span><br><span class="css"><span class="xml"><span class="hljs-selector-id">#box2</span>&#123;  </span></span><br><span class="css"><span class="xml"><span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;  </span></span><br><span class="css"><span class="xml"><span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;  </span></span><br><span class="css"><span class="xml"><span class="hljs-attribute">background-color</span>: yellow;  </span></span><br><span class="css"><span class="xml"><span class="hljs-attribute">position</span>: absolute;  </span></span><br><span class="css"><span class="xml">  </span></span><br><span class="css"><span class="xml"><span class="hljs-attribute">left</span>: <span class="hljs-number">200px</span>;  </span></span><br><span class="css"><span class="xml"><span class="hljs-attribute">top</span>: <span class="hljs-number">200px</span>;  </span></span><br><span class="css"><span class="xml">&#125;  </span></span><br><span class="css"><span class="xml">  </span></span><br><span class="css"><span class="xml">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>  </span><br><span class="xml">  </span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><span class="javascript">  </span></span><br><span class="javascript"><span class="xml">  </span></span><br><span class="javascript"><span class="xml">    <span class="hljs-built_in">window</span>.onload = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;  </span></span><br><span class="javascript"><span class="xml">    <span class="hljs-comment">/*  </span></span></span><br><span class="hljs-comment"><span class="javascript"><span class="xml"> * 拖拽box1元素  </span></span></span><br><span class="hljs-comment"><span class="javascript"><span class="xml"> *  - 拖拽的流程  </span></span></span><br><span class="hljs-comment"><span class="javascript"><span class="xml"> * 1.当鼠标在被拖拽元素上按下时，开始拖拽  onmousedown  </span></span></span><br><span class="hljs-comment"><span class="javascript"><span class="xml"> * 2.当鼠标移动时被拖拽元素跟随鼠标移动 onmousemove  </span></span></span><br><span class="hljs-comment"><span class="javascript"><span class="xml"> * 3.当鼠标松开时，被拖拽元素固定在当前位置onmouseup  </span></span></span><br><span class="hljs-comment"><span class="javascript"><span class="xml"> */</span>  </span></span><br><span class="javascript"><span class="xml">  </span></span><br><span class="javascript"><span class="xml">    <span class="hljs-comment">//获取box1  </span></span></span><br><span class="javascript"><span class="xml">    <span class="hljs-keyword">var</span> box1 = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;box1&quot;</span>);  </span></span><br><span class="javascript"><span class="xml">    <span class="hljs-keyword">var</span> box2 = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;box2&quot;</span>);  </span></span><br><span class="javascript"><span class="xml">    <span class="hljs-keyword">var</span> img1 = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;img1&quot;</span>);  </span></span><br><span class="javascript"><span class="xml">  </span></span><br><span class="javascript"><span class="xml">    <span class="hljs-comment">//开启box1的拖拽  </span></span></span><br><span class="javascript"><span class="xml">    drag(box1);  </span></span><br><span class="javascript"><span class="xml">    <span class="hljs-comment">//开启box2的  </span></span></span><br><span class="javascript"><span class="xml">    drag(box2);  </span></span><br><span class="javascript"><span class="xml">  </span></span><br><span class="javascript"><span class="xml">    drag(img1);  </span></span><br><span class="javascript"><span class="xml">  </span></span><br><span class="javascript"><span class="xml">&#125;;  </span></span><br><span class="javascript"><span class="xml">  </span></span><br><span class="javascript"><span class="xml"><span class="hljs-comment">/*  </span></span></span><br><span class="hljs-comment"><span class="javascript"><span class="xml"> * 提取一个专门用来设置拖拽的函数  </span></span></span><br><span class="hljs-comment"><span class="javascript"><span class="xml"> * 参数：开启拖拽的元素  </span></span></span><br><span class="hljs-comment"><span class="javascript"><span class="xml"> */</span>  </span></span><br><span class="javascript"><span class="xml"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">drag</span>(<span class="hljs-params">obj</span>)</span>&#123;  </span></span><br><span class="javascript"><span class="xml">    <span class="hljs-comment">//当鼠标在被拖拽元素上按下时，开始拖拽  onmousedown  </span></span></span><br><span class="javascript"><span class="xml">    obj.onmousedown = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>)</span>&#123;  </span></span><br><span class="javascript"><span class="xml">  </span></span><br><span class="javascript"><span class="xml">        <span class="hljs-comment">//设置box1捕获所有鼠标按下的事件  </span></span></span><br><span class="javascript"><span class="xml">        <span class="hljs-comment">/*  </span></span></span><br><span class="hljs-comment"><span class="javascript"><span class="xml"> * setCapture()  </span></span></span><br><span class="hljs-comment"><span class="javascript"><span class="xml"> * - 只有IE支持，但是在火狐中调用时不会报错，  </span></span></span><br><span class="hljs-comment"><span class="javascript"><span class="xml"> * 而如果使用chrome调用，会报错  </span></span></span><br><span class="hljs-comment"><span class="javascript"><span class="xml"> */</span>  </span></span><br><span class="javascript"><span class="xml">        <span class="hljs-comment">/*if(box1.setCapture)&#123;  </span></span></span><br><span class="hljs-comment"><span class="javascript"><span class="xml">box1.setCapture();  </span></span></span><br><span class="hljs-comment"><span class="javascript"><span class="xml">&#125;*/</span>  </span></span><br><span class="javascript"><span class="xml">        obj.setCapture &amp;&amp; obj.setCapture();  <span class="hljs-comment">//与上面的句子一样的 简写，如果没这个属性 右边就不执行了</span></span></span><br><span class="javascript"><span class="xml">  </span></span><br><span class="javascript"><span class="xml">  </span></span><br><span class="javascript"><span class="xml">        event = event || <span class="hljs-built_in">window</span>.event;  </span></span><br><span class="javascript"><span class="xml">        <span class="hljs-comment">//div的偏移量 鼠标.clentX - 元素.offsetLeft  </span></span></span><br><span class="javascript"><span class="xml">        <span class="hljs-comment">//div的偏移量 鼠标.clentY - 元素.offsetTop  </span></span></span><br><span class="javascript"><span class="xml">        <span class="hljs-keyword">var</span> ol = event.clientX - obj.offsetLeft;  </span></span><br><span class="javascript"><span class="xml">        <span class="hljs-keyword">var</span> ot = event.clientY - obj.offsetTop;  </span></span><br><span class="javascript"><span class="xml">  </span></span><br><span class="javascript"><span class="xml">  </span></span><br><span class="javascript"><span class="xml">        <span class="hljs-comment">//为document绑定一个onmousemove事件  </span></span></span><br><span class="javascript"><span class="xml">        <span class="hljs-built_in">document</span>.onmousemove = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>)</span>&#123;  </span></span><br><span class="javascript"><span class="xml">            event = event || <span class="hljs-built_in">window</span>.event;  </span></span><br><span class="javascript"><span class="xml">            <span class="hljs-comment">//当鼠标移动时被拖拽元素跟随鼠标移动 onmousemove  </span></span></span><br><span class="javascript"><span class="xml">            <span class="hljs-comment">//获取鼠标的坐标  </span></span></span><br><span class="javascript"><span class="xml">            <span class="hljs-keyword">var</span> left = event.clientX - ol;  </span></span><br><span class="javascript"><span class="xml">            <span class="hljs-keyword">var</span> top = event.clientY - ot;  </span></span><br><span class="javascript"><span class="xml">  </span></span><br><span class="javascript"><span class="xml">            <span class="hljs-comment">//修改box1的位置  </span></span></span><br><span class="javascript"><span class="xml">            obj.style.left = left+<span class="hljs-string">&quot;px&quot;</span>;  <span class="hljs-comment">//实现在图标的固定点不动</span></span></span><br><span class="javascript"><span class="xml">            obj.style.top = top+<span class="hljs-string">&quot;px&quot;</span>;  </span></span><br><span class="javascript"><span class="xml">  </span></span><br><span class="javascript"><span class="xml">        &#125;;  </span></span><br><span class="javascript"><span class="xml">  </span></span><br><span class="javascript"><span class="xml">        <span class="hljs-comment">//为document绑定一个鼠标松开事件  </span></span></span><br><span class="javascript"><span class="xml">        <span class="hljs-built_in">document</span>.onmouseup = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;  </span></span><br><span class="javascript"><span class="xml">            <span class="hljs-comment">//当鼠标松开时，被拖拽元素固定在当前位置onmouseup  </span></span></span><br><span class="javascript"><span class="xml">            <span class="hljs-comment">//取消document的onmousemove事件  </span></span></span><br><span class="javascript"><span class="xml">            <span class="hljs-built_in">document</span>.onmousemove = <span class="hljs-literal">null</span>;  </span></span><br><span class="javascript"><span class="xml">            <span class="hljs-comment">//取消document的onmouseup事件  </span></span></span><br><span class="javascript"><span class="xml">            <span class="hljs-built_in">document</span>.onmouseup = <span class="hljs-literal">null</span>;  </span></span><br><span class="javascript"><span class="xml">            <span class="hljs-comment">//当鼠标松开时，取消对事件的捕获  </span></span></span><br><span class="javascript"><span class="xml">            obj.releaseCapture &amp;&amp; obj.releaseCapture();  </span></span><br><span class="javascript"><span class="xml">        &#125;;  </span></span><br><span class="javascript"><span class="xml">  </span></span><br><span class="javascript"><span class="xml"> <span class="hljs-comment">/*  </span></span></span><br><span class="hljs-comment"><span class="javascript"><span class="xml">* 当我们拖拽一个网页中的内容时，浏览器会默认去搜索引擎中搜索内容，  </span></span></span><br><span class="hljs-comment"><span class="javascript"><span class="xml">* 此时会导致拖拽功能的异常，这个是浏览器提供的默认行为，  </span></span></span><br><span class="hljs-comment"><span class="javascript"><span class="xml">* 如果不希望发生这个行为，则可以通过return false来取消默认行为  </span></span></span><br><span class="hljs-comment"><span class="javascript"><span class="xml">*   </span></span></span><br><span class="hljs-comment"><span class="javascript"><span class="xml">* 但是这招对IE8不起作用  </span></span></span><br><span class="hljs-comment"><span class="javascript"><span class="xml">*/</span>  </span></span><br><span class="javascript"><span class="xml">        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  </span></span><br><span class="javascript"><span class="xml">    &#125;;  </span></span><br><span class="javascript"><span class="xml">&#125;  </span></span><br><span class="javascript"><span class="xml">  </span></span><br><span class="javascript"><span class="xml">  </span></span><br><span class="javascript"><span class="xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>  </span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>  </span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>  </span><br><span class="xml">  </span><br><span class="xml">    我是一段文字  </span><br><span class="xml">  </span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;box1&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>  </span><br><span class="xml">  </span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;box2&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>  </span><br><span class="xml">  </span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;img/an.jpg&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;img1&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;position: absolute;&quot;</span>/&gt;</span>  </span><br><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>  </span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span>  </span><br></code></pre></td></tr></table></figure><h3 id="滚轮事件（火狐没看了）："><a href="#滚轮事件（火狐没看了）：" class="headerlink" title="滚轮事件（火狐没看了）："></a>滚轮事件（火狐没看了）：</h3><p>onwheel都支持  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;!DOCTYPE html&gt;  <br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span>  </span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>  </span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span>  </span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>  </span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/css&quot;</span>&gt;</span><span class="css">  </span></span><br><span class="css"><span class="xml">  </span></span><br><span class="css"><span class="xml">    <span class="hljs-selector-id">#box1</span>&#123;  </span></span><br><span class="css"><span class="xml"><span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;  </span></span><br><span class="css"><span class="xml"><span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;  </span></span><br><span class="css"><span class="xml"><span class="hljs-attribute">background-color</span>: red;  </span></span><br><span class="css"><span class="xml">&#125;  </span></span><br><span class="css"><span class="xml">  </span></span><br><span class="css"><span class="xml">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>  </span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><span class="javascript">  </span></span><br><span class="javascript"><span class="xml">  </span></span><br><span class="javascript"><span class="xml">    <span class="hljs-built_in">window</span>.onload = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;  </span></span><br><span class="javascript"><span class="xml">  </span></span><br><span class="javascript"><span class="xml">  </span></span><br><span class="javascript"><span class="xml">    <span class="hljs-comment">//获取id为box1的div  </span></span></span><br><span class="javascript"><span class="xml">    <span class="hljs-keyword">var</span> box1 = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;box1&quot;</span>);  </span></span><br><span class="javascript"><span class="xml">  </span></span><br><span class="javascript"><span class="xml">    <span class="hljs-comment">//为box1绑定一个鼠标滚轮滚动的事件  </span></span></span><br><span class="javascript"><span class="xml">    <span class="hljs-comment">/*  </span></span></span><br><span class="hljs-comment"><span class="javascript"><span class="xml"> * onmousewheel鼠标滚轮滚动的事件，会在滚轮滚动时触发，  </span></span></span><br><span class="hljs-comment"><span class="javascript"><span class="xml"> * 但是火狐不支持该属性  </span></span></span><br><span class="hljs-comment"><span class="javascript"><span class="xml"> *   </span></span></span><br><span class="hljs-comment"><span class="javascript"><span class="xml"> * 在火狐中需要使用 DOMMouseScroll 来绑定滚动事件  </span></span></span><br><span class="hljs-comment"><span class="javascript"><span class="xml"> * 注意该事件需要通过addEventListener()函数来绑定  </span></span></span><br><span class="hljs-comment"><span class="javascript"><span class="xml"> */</span>  </span></span><br><span class="javascript"><span class="xml">  </span></span><br><span class="javascript"><span class="xml">  </span></span><br><span class="javascript"><span class="xml">    box1.onmousewheel = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>)</span>&#123;  </span></span><br><span class="javascript"><span class="xml">  </span></span><br><span class="javascript"><span class="xml">        event = event || <span class="hljs-built_in">window</span>.event;  </span></span><br><span class="javascript"><span class="xml">  </span></span><br><span class="javascript"><span class="xml">  </span></span><br><span class="javascript"><span class="xml">        <span class="hljs-comment">//event.wheelDelta 可以获取鼠标滚轮滚动的方向  </span></span></span><br><span class="javascript"><span class="xml">        <span class="hljs-comment">//向上滚 120   向下滚 -120  </span></span></span><br><span class="javascript"><span class="xml">        <span class="hljs-comment">//wheelDelta这个值我们不看大小，只看正负  </span></span></span><br><span class="javascript"><span class="xml">  </span></span><br><span class="javascript"><span class="xml">        <span class="hljs-comment">//alert(event.wheelDelta);  </span></span></span><br><span class="javascript"><span class="xml">  </span></span><br><span class="javascript"><span class="xml">        <span class="hljs-comment">//wheelDelta这个属性火狐中不支持  </span></span></span><br><span class="javascript"><span class="xml">        <span class="hljs-comment">//在火狐中使用event.detail来获取滚动的方向  </span></span></span><br><span class="javascript"><span class="xml">        <span class="hljs-comment">//向上滚 -3  向下滚 3  </span></span></span><br><span class="javascript"><span class="xml">        <span class="hljs-comment">//alert(event.detail);  </span></span></span><br><span class="javascript"><span class="xml">  </span></span><br><span class="javascript"><span class="xml">  </span></span><br><span class="javascript"><span class="xml">        <span class="hljs-comment">/*  </span></span></span><br><span class="hljs-comment"><span class="javascript"><span class="xml"> * 当鼠标滚轮向下滚动时，box1变长  </span></span></span><br><span class="hljs-comment"><span class="javascript"><span class="xml"> * 当滚轮向上滚动时，box1变短  </span></span></span><br><span class="hljs-comment"><span class="javascript"><span class="xml"> */</span>  </span></span><br><span class="javascript"><span class="xml">        <span class="hljs-comment">//判断鼠标滚轮滚动的方向  </span></span></span><br><span class="javascript"><span class="xml">        <span class="hljs-keyword">if</span>(event.wheelDelta &gt; <span class="hljs-number">0</span> || event.detail &lt; <span class="hljs-number">0</span>)&#123;  </span></span><br><span class="javascript"><span class="xml">            <span class="hljs-comment">//向上滚，box1变短  </span></span></span><br><span class="javascript"><span class="xml">            box1.style.height = box1.clientHeight - <span class="hljs-number">10</span> + <span class="hljs-string">&quot;px&quot;</span>;  </span></span><br><span class="javascript"><span class="xml">  </span></span><br><span class="javascript"><span class="xml">        &#125;<span class="hljs-keyword">else</span>&#123;  </span></span><br><span class="javascript"><span class="xml">            <span class="hljs-comment">//向下滚，box1变长  </span></span></span><br><span class="javascript"><span class="xml">            box1.style.height = box1.clientHeight + <span class="hljs-number">10</span> + <span class="hljs-string">&quot;px&quot;</span>;  </span></span><br><span class="javascript"><span class="xml">        &#125;  </span></span><br><span class="javascript"><span class="xml">  </span></span><br><span class="javascript"><span class="xml">        <span class="hljs-comment">/*  </span></span></span><br><span class="hljs-comment"><span class="javascript"><span class="xml"> * 使用addEventListener()方法绑定响应函数，取消默认行为时不能使用return false  </span></span></span><br><span class="hljs-comment"><span class="javascript"><span class="xml"> * 需要使用event来取消默认行为event.preventDefault();  </span></span></span><br><span class="hljs-comment"><span class="javascript"><span class="xml"> * 但是IE8不支持event.preventDefault();这个玩意，如果直接调用会报错  </span></span></span><br><span class="hljs-comment"><span class="javascript"><span class="xml"> */</span>  </span></span><br><span class="javascript"><span class="xml">        event.preventDefault &amp;&amp; event.preventDefault();  </span></span><br><span class="javascript"><span class="xml">  </span></span><br><span class="javascript"><span class="xml">  </span></span><br><span class="javascript"><span class="xml">        <span class="hljs-comment">/*  </span></span></span><br><span class="hljs-comment"><span class="javascript"><span class="xml"> * 当滚轮滚动时，如果浏览器有滚动条，滚动条会随之滚动，  </span></span></span><br><span class="hljs-comment"><span class="javascript"><span class="xml"> * 这是浏览器的默认行为，如果不希望发生，则可以取消默认行为  </span></span></span><br><span class="hljs-comment"><span class="javascript"><span class="xml"> */</span>  </span></span><br><span class="javascript"><span class="xml">        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  </span></span><br><span class="javascript"><span class="xml">  </span></span><br><span class="javascript"><span class="xml">  </span></span><br><span class="javascript"><span class="xml">  </span></span><br><span class="javascript"><span class="xml">  </span></span><br><span class="javascript"><span class="xml">    &#125;;  </span></span><br><span class="javascript"><span class="xml">  </span></span><br><span class="javascript"><span class="xml">    <span class="hljs-comment">//为火狐绑定滚轮事件  </span></span></span><br><span class="javascript"><span class="xml">    bind(box1,<span class="hljs-string">&quot;DOMMouseScroll&quot;</span>,box1.onmousewheel);  </span></span><br><span class="javascript"><span class="xml">  </span></span><br><span class="javascript"><span class="xml">  </span></span><br><span class="javascript"><span class="xml">&#125;;  </span></span><br><span class="javascript"><span class="xml">  </span></span><br><span class="javascript"><span class="xml">  </span></span><br><span class="javascript"><span class="xml"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bind</span>(<span class="hljs-params">obj , eventStr , callback</span>)</span>&#123;  </span></span><br><span class="javascript"><span class="xml">    <span class="hljs-keyword">if</span>(obj.addEventListener)&#123;  </span></span><br><span class="javascript"><span class="xml">        <span class="hljs-comment">//大部分浏览器兼容的方式  </span></span></span><br><span class="javascript"><span class="xml">        obj.addEventListener(eventStr , callback , <span class="hljs-literal">false</span>);  </span></span><br><span class="javascript"><span class="xml">    &#125;<span class="hljs-keyword">else</span>&#123;  </span></span><br><span class="javascript"><span class="xml">        <span class="hljs-comment">/*  </span></span></span><br><span class="hljs-comment"><span class="javascript"><span class="xml"> * this是谁由调用方式决定  </span></span></span><br><span class="hljs-comment"><span class="javascript"><span class="xml"> * callback.call(obj)  </span></span></span><br><span class="hljs-comment"><span class="javascript"><span class="xml"> */</span>  </span></span><br><span class="javascript"><span class="xml">        <span class="hljs-comment">//IE8及以下  </span></span></span><br><span class="javascript"><span class="xml">        obj.attachEvent(<span class="hljs-string">&quot;on&quot;</span>+eventStr , <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;  </span></span><br><span class="javascript"><span class="xml">            <span class="hljs-comment">//在匿名函数中调用回调函数  </span></span></span><br><span class="javascript"><span class="xml">            callback.call(obj);  </span></span><br><span class="javascript"><span class="xml">        &#125;);  </span></span><br><span class="javascript"><span class="xml">    &#125;  </span></span><br><span class="javascript"><span class="xml">&#125;  </span></span><br><span class="javascript"><span class="xml">  </span></span><br><span class="javascript"><span class="xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>  </span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>  </span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">body</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;height: 2000px;&quot;</span>&gt;</span>  </span><br><span class="xml">  </span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;box1&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>  </span><br><span class="xml">  </span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>  </span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span>  </span><br><span class="xml">  </span><br></code></pre></td></tr></table></figure><h3 id="键盘事件"><a href="#键盘事件" class="headerlink" title="键盘事件"></a>键盘事件</h3><p>键盘事件：</p><p>onkeydown<br> 按键被按下<br> 对于onkeydown来说如果一直按着某个按键不松手，则事件会一直触发<br> 当onkeydown连续触发时，第一次和第二次之间会间隔稍微长一点，其他的会非常的快，这种设计是为了防止误操作的发生。  </p><p>onkeyup<br> 按键被松开  </p><p>键盘事件一般都会绑定给一些可以获取到焦点的对象或者是document  </p><p>keyCode  </p><p>可以通过keyCode来获取按键的编码<br>通过它可以判断哪个按键被按下<br>除了keyCode，事件对象中还提供了几个属性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">if</span>(event.keyCode === <span class="hljs-number">89</span>)&#123;<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;y被按下了&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>altKey<br>ctrlKey<br>shiftKey<br>这个三个用来判断alt ctrl 和 shift是否被按下<br>如果按下则返回true，否则返回false  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//console.log(event.keyCode);  </span><br>  <br><span class="hljs-comment">//判断一个y是否被按下  </span><br><span class="hljs-comment">//判断y和ctrl是否同时被按下  </span><br><span class="hljs-keyword">if</span>(event.keyCode === <span class="hljs-number">89</span> &amp;&amp; event.ctrlKey)&#123;  <br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;ctrl和y都被按下了&quot;</span>);  <br>&#125;  <br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript">input.onkeydown = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) </span>&#123;  <br>    event = event || <span class="hljs-built_in">window</span>.event;  <br>    <span class="hljs-comment">//数字 48 - 57  </span><br>    <span class="hljs-comment">//使文本框中不能输入数字  </span><br>    <span class="hljs-keyword">if</span>(event.keyCode &gt;= <span class="hljs-number">48</span> &amp;&amp; event.keyCode &lt;= <span class="hljs-number">57</span>) &#123;  <br>        <span class="hljs-comment">//在文本框中输入内容，属于onkeydown的默认行为  </span><br>        <span class="hljs-comment">//如果在onkeydown中取消了默认行为，则输入的内容，不会出现在文本框中  </span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  <br>    &#125;  <br>&#125;;  <br>  <br></code></pre></td></tr></table></figure><h1 id="BOM"><a href="#BOM" class="headerlink" title="BOM"></a>BOM</h1><p>浏览器对象模型(browser object model)<br>BOM可以使我们通过JS来操作浏览器<br>在BOM中为我们提供了一组对象，用来完成对浏览器的操作</p><p>BOM对象<br>Window<br> 代表的是整个浏览器的窗口，同时window也是网页中的全局对象<br>Navigator<br> 代表的当前浏览器的信息，通过该对象可以来识别不同的浏览器<br>Location<br> 代表当前浏览器的地址栏信息，通过Location可以获取地址栏信息，或者操作浏览器跳转页面<br>History<br> 代表浏览器的历史记录，可以通过该对象来操作浏览器的历史记录<br>    由于隐私原因，该对象不能获取到具体的历史记录，只能操作浏览器向前或向后翻页<br>    而且该操作只在当次访问时有效<br>Screen<br> 代表用户的屏幕的信息，通过该对象可以获取到用户的显示器的相关的信息  </p><p>这些BOM对象在浏览器中都是作为window对象的属性保存的，<br>可以通过window对象来使用，也可以直接使用  </p><h2 id="Navigator"><a href="#Navigator" class="headerlink" title="Navigator"></a>Navigator</h2><p> 代表的当前浏览器的信息，通过该对象可以来识别不同的浏览器<br> 由于历史原因，Navigator对象中的大部分属性都已经不能帮助我们识别浏览器了<br> 一般我们只会使用userAgent来判断浏览器的信息，<br>    userAgent是一个字符串，这个字符串中包含有用来描述浏览器信息的内容，<br>    不同的浏览器会有不同的userAgent  </p><p>火狐的userAgent<br>Mozilla5.0 (Windows NT 6.1; WOW64; rv:50.0) Gecko20100101 Firefox50.0  </p><p>Chrome的userAgent<br>Mozilla5.0 (Windows NT 6.1; Win64; x64) AppleWebKit537.36 (KHTML, like Gecko) Chrome52.0.2743.82 Safari537.36  </p><p>IE8<br>Mozilla4.0 (compatible; MSIE 8.0; Windows NT 6.1; WOW64; Trident7.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; .NET4.0C; .NET4.0E)  </p><p>IE9<br>Mozilla5.0 (compatible; MSIE 9.0; Windows NT 6.1; WOW64; Trident7.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; .NET4.0C; .NET4.0E)  </p><p>IE10<br>Mozilla5.0 (compatible; MSIE 10.0; Windows NT 6.1; WOW64; Trident7.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; .NET4.0C; .NET4.0E)  </p><p>IE11<br>Mozilla5.0 (Windows NT 6.1; WOW64; Trident7.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; .NET4.0C; .NET4.0E; rv:11.0) like Gecko<br> 在IE11中已经将微软和IE相关的标识都已经去除了，所以我们基本已经不能通过UserAgent来识别一个浏览器是否是IE了  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript">alert(navigator.appName);  <br>  <br><span class="hljs-keyword">var</span> ua = navigator.userAgent;  <br>  <br><span class="hljs-built_in">console</span>.log(ua);  <br>  <br><span class="hljs-keyword">if</span>(firefoxi.test(ua))&#123;  <br>alert(<span class="hljs-string">&quot;你是火狐！！！&quot;</span>);  <br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(chromei.test(ua))&#123;  <br>alert(<span class="hljs-string">&quot;你是Chrome&quot;</span>);  <br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(msiei.test(ua))&#123;  <br>alert(<span class="hljs-string">&quot;你是IE浏览器~~~&quot;</span>);  <br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-string">&quot;ActiveXObject&quot;</span> <span class="hljs-keyword">in</span> <span class="hljs-built_in">window</span>)&#123;  <span class="hljs-comment">//它有这个属性，用这个判断11</span><br>alert(<span class="hljs-string">&quot;你是IE11，枪毙了你~~~&quot;</span>);  <br>&#125;  <br></code></pre></td></tr></table></figure><h2 id="History"><a href="#History" class="headerlink" title="History"></a>History</h2><p> 对象可以用来操作浏览器向前或向后翻页<br>length<br> 属性，可以获取到当次访问的链接数量 点进子页面就会增加<br>back()<br> 可以用来回退到上一个页面，作用和浏览器的回退按钮一样<br>forward()<br> 可以跳转下一个页面，作用和浏览器的前进按钮一样<br>go()<br> 可以用来跳转到指定的页面<br> 它需要一个整数作为参数<br>    1:表示向前跳转一个页面 相当于forward()<br>    2:表示向前跳转两个页面<br>    -1:表示向后跳转一个页面<br>    -2:表示向后跳转两个页面  </p><h2 id="Location"><a href="#Location" class="headerlink" title="Location"></a>Location</h2><p> 该对象中封装了浏览器的地址栏的信息<br>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-OVUZxci1-1630937238444)(C:\Users\Fine\Downloads\codeOflI.github.io-dev\source_posts\js-note\javaScript\image-20210618201723194.png)]<br>如果直接打印location，则可以获取到地址栏的信息（当前页面的完整路径）<br>alert(location);<br>如果直接将location属性修改为一个完整的路径，或相对路径<br>则我们页面会自动跳转到该路径，并且会生成相应的历史记录<br>location = “http:<a href="http://www.baidu.com&quot;/">www.baidu.com&quot;</a>;<br>location = “01.BOM.html”;  </p><p>方法：</p><p>assign()<br> 用来跳转到其他的页面，作用和直接修改location一样      </p><p>reload()<br> 用于重新加载当前页面，作用和刷新按钮一样<br> 如果在方法中传递一个true，作为参数，则会强制清空缓存刷新页面，就是缓存的信息完全不见了<br>location.reload(true);</p><p>replace()<br> 可以使用一个新的页面替换当前页面，调用完毕也会跳转页面<br>    不会生成历史记录，不能使用回退按钮回退  </p><h2 id="window"><a href="#window" class="headerlink" title="window"></a>window</h2><h3 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h3><p><strong>setInterval()</strong><br> 定时调用<br> 可以将一个函数，每隔一段时间执行一次<br> 参数：<br>    1.回调函数，该函数会每隔一段时间被调用一次<br>    2.每次调用间隔的时间，单位是毫秒  </p><p> 返回值：<br>    返回一个Number类型的数据<br>    这个数字用来作为定时器的唯一标识<br><strong>clearInterval()可以用来关闭一个定时器</strong><br>方法中需要一个定时器的标识作为参数，这样将关闭标识对应的定时器   </p><p>clearInterval()可以接收任意参数，<br>    如果参数是一个有效的定时器的标识，则停止对应的定时器<br>    如果参数不是一个有效的标识，则什么也不做  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> num = <span class="hljs-number">1</span>;  <br><span class="hljs-keyword">var</span> timer = <span class="hljs-built_in">setInterval</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;  <br>count.innerHTML = num++;  <br><span class="hljs-keyword">if</span>(num == <span class="hljs-number">11</span>) &#123;  <br><span class="hljs-comment">//关闭定时器  </span><br><span class="hljs-built_in">clearInterval</span>(timer);  <br>&#125;  <br>&#125;, <span class="hljs-number">1000</span>);  <br></code></pre></td></tr></table></figure><h3 id="延时调用"><a href="#延时调用" class="headerlink" title="延时调用"></a>延时调用</h3><p><strong>setTimeout</strong>  </p><p>延时调用一个函数不马上执行，而是隔一段时间以后在执行，而且只会执行一次<br>延时调用和定时调用的区别，定时调用会执行多次，而延时调用只会执行一次<br>延时调用和定时调用实际上是可以互相代替的，在开发中可以根据自己需要去选择  </p><p>var timer = setTimeout(function(){<br>console.log(num++);<br>},3000);  </p><p>使用clearTimeout()来关闭一个延时调用<br>clearTimeout(timer);  </p><p>#类的操作  </p><p><strong>直接修改元素的类css：</strong>  </p><p>通过style属性来修改元素的样式，每修改一个样式，浏览器就需要重新渲染一次页面。 这样的执行的性能是比较差的，而且这种形式当我们要修改多个样式时，也不太方便 我希望一行代码，可以同时修改多个样式  </p><p>我们可以通过修改元素的class属性来间接的修改样式.这样一来，我们只需要修改一次，即可同时修改多个样式，浏览器只需要重新渲染页面一次，性能比较好，<br>并且这种方式，可以使表现和行为进一步的分离  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">box.className += <span class="hljs-string">&quot; b2&quot;</span>;<span class="hljs-comment">//注意有空格，添加class属性  </span><br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//定义一个函数，用来向一个元素中添加指定的class属性值  </span><br><span class="hljs-comment">/*  </span><br><span class="hljs-comment"> * 参数:  </span><br><span class="hljs-comment"> * obj 要添加class属性的元素  </span><br><span class="hljs-comment"> *  cn 要添加的class值  </span><br><span class="hljs-comment"> *   </span><br><span class="hljs-comment"> */</span>  <br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addClass</span>(<span class="hljs-params">obj, cn</span>) </span>&#123;  <br><span class="hljs-keyword">if</span> (!hasClass(obj, cn)) &#123;  <br>obj.className += <span class="hljs-string">&quot; &quot;</span> + cn;  <br>&#125;  <br>&#125;  <br><span class="hljs-comment">/*  </span><br><span class="hljs-comment"> * 判断一个元素中是否含有指定的class属性值  </span><br><span class="hljs-comment"> * 如果有该class，则返回true，没有则返回false  </span><br><span class="hljs-comment"> *   </span><br><span class="hljs-comment"> */</span>  <br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">hasClass</span>(<span class="hljs-params">obj, cn</span>) </span>&#123;  <br><span class="hljs-keyword">var</span> reg = <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(<span class="hljs-string">&quot;\\b&quot;</span> + cn + <span class="hljs-string">&quot;\\b&quot;</span>);  <br><span class="hljs-keyword">return</span> reg.test(obj.className);  <br>&#125;  <br><span class="hljs-comment">/*  </span><br><span class="hljs-comment"> * 删除一个元素中的指定的class属性  </span><br><span class="hljs-comment"> */</span>  <br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">removeClass</span>(<span class="hljs-params">obj, cn</span>) </span>&#123;  <br><span class="hljs-comment">//创建一个正则表达式  </span><br><span class="hljs-keyword">var</span> reg = <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(<span class="hljs-string">&quot;\\b&quot;</span> + cn + <span class="hljs-string">&quot;\\b&quot;</span>);  <br><span class="hljs-comment">//删除class  </span><br>obj.className = obj.className.replace(reg, <span class="hljs-string">&quot;&quot;</span>);  <br>&#125;  <br><span class="hljs-comment">/*  </span><br><span class="hljs-comment"> * toggleClass可以用来切换一个类  </span><br><span class="hljs-comment"> * 如果元素中具有该类，则删除  </span><br><span class="hljs-comment"> * 如果元素中没有该类，则添加  </span><br><span class="hljs-comment"> */</span>  <br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">toggleClass</span>(<span class="hljs-params">obj , cn</span>)</span>&#123;  <br><span class="hljs-comment">//判断obj中是否含有cn  </span><br><span class="hljs-keyword">if</span>(hasClass(obj , cn))&#123;  <br><span class="hljs-comment">//有，则删除  </span><br>removeClass(obj , cn);  <br>&#125;<span class="hljs-keyword">else</span>&#123;  <br><span class="hljs-comment">//没有，则添加  </span><br>addClass(obj , cn);  <br>&#125;  <br>&#125;  <br></code></pre></td></tr></table></figure><h1 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h1><p> <strong>JavaScript Object Notation</strong> JS对象表示法</p><h2 id="JSON-格式"><a href="#JSON-格式" class="headerlink" title="JSON 格式"></a>JSON 格式</h2><p>  JS中的对象只有JS自己认识，其他的语言都不认识<br><strong>JSON就是一个特殊格式的字符串</strong>，这个字符串可以被任意的语言所识别，<br>并且可以转换为任意语言中的对象，JSON在开发中主要用来数据的交互<br> JSON和JS对象的格式一样，只不过<strong>JSON字符串中的属性名必须加双引号</strong><br>    其他的和JS语法一致  </p><p>规则：</p><ol><li><p>复合类型的值只能是数组或对象，不能是函数、正则表达式对象、日期对象。</p></li><li><p>原始类型的值只有四种：字符串、数值（必须以十进制表示）、布尔值和<code>null</code>（不能使用<code>NaN</code>, <code>Infinity</code>, <code>-Infinity</code>和<code>undefined</code>）。</p></li><li><p>字符串<strong>必须使用双引号表示</strong>，不能使用单引号。</p></li><li><p>对象的键名必须放在双引号里面。</p></li><li><p>数组或对象最后一个成员的后面，不能加逗号。</p></li></ol><p>JSON分类：<br>    1.对象 {}<br>    2.数组 []  </p><p>JSON中允许的值：<br>    1.字符串<br>    2.数值<br>    3.布尔值<br>    4.null<br>    5.对象<br>    6.数组  </p><p>举例：  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> arr = <span class="hljs-string">&#x27;[1,2,3,&quot;hello&quot;,true]&#x27;</span>;  <span class="hljs-comment">//JSOM数组</span><br>  <br><span class="hljs-keyword">var</span> obj2 = <span class="hljs-string">&#x27;&#123;&quot;arr&quot;:[1,2,3]&#125;&#x27;</span>;  <br>  <br><span class="hljs-keyword">var</span> arr2 =<span class="hljs-string">&#x27;[&#123;&quot;name&quot;:&quot;孙悟空&quot;,&quot;age&quot;:18,&quot;gender&quot;:&quot;男&quot;&#125;,&#123;&quot;name&quot;:&quot;孙悟空&quot;,&quot;age&quot;:18,&quot;gender&quot;:&quot;男&quot;&#125;]&#x27;</span>;  <span class="hljs-comment">//JSON数组，数组里是对象</span><br></code></pre></td></tr></table></figure><p>JSON工具类<br>JSON和js对象的互相转化  </p><p>1.json &gt; js对象<br>JSON.parse()<br> 可以将以JSON字符串转换为js对象,在java里可以转换为java的对象？<br> 它需要一个JSON字符串作为参数，会将该字符串转换为JS对象并返回  </p><p>var o = JSON.parse(json);<br>var o2 = JSON.parse(arr);  </p><p>var obj3 = {name:”猪八戒” , age:28 , gender:”男”};  </p><p>2.js对象 &gt; JSON<br>JSON.stringify()                -ify/fy，表示”使……化。<br> 可以将一个JS对象转换为JSON字符串<br> 需要一个js对象作为参数，会返回一个JSON字符串  </p><p>var str = JSON.stringify(obj3);<br>console.log(str);  </p><p>JSON（不是指工具）这个对象在IE7及以下的浏览器中不支持，所以在这些浏览器中调用时会报错<br> 通过引用一个外部js文件来处理，开一个外挂，直接用script的src添加文件名到这个程序，就能用了。</p><p>​          </p><h1 id="other"><a href="#other" class="headerlink" title="other"></a>other</h1><h2 id="localStorage"><a href="#localStorage" class="headerlink" title="localStorage"></a>localStorage</h2><p>只读的<code>localStorage</code> 属性允许你访问一个<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Document"><code>Document</code></a> 源（origin）的对象 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Storage"><code>Storage</code></a>；其存储的数据能在跨浏览器会话保留。<code>localStorage</code> 类似 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/sessionStorage"><code>sessionStorage</code></a>，但其区别在于：存储在 <code>localStorage</code> 的数据可以长期保留；而当页面会话结束——也就是说，当页面被关闭时，存储在 <code>sessionStorage</code> 的数据会被清除 。  </p><h2 id="eval"><a href="#eval" class="headerlink" title="eval()"></a>eval()</h2><p>eval()<br> 这个函数可以用来执行一段字符串形式的JS代码，并将执行结果返回<br> 如果使用eval()执行的字符串中含有{},它会将{}当成是代码块<br>    如果不希望将其当成代码块解析，则需要在字符串前后各加一个()  </p><p> eval()这个函数的功能很强大，可以直接执行一个字符串中的js代码，<br>    但是在开发中尽量不要使用，首先它的执行性能比较差，然后它还具有安全隐患  </p><pre><code>var str = &#39;&#123;&quot;name&quot;:&quot;孙悟空&quot;,&quot;age&quot;:18,&quot;gender&quot;:&quot;男&quot;&#125;&#39;;  var obj = eval(&quot;(&quot;+str+&quot;)&quot;);  </code></pre><p>编码  </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span>  <br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span>  <br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>  <br><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span>  <br><span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>  <br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><span class="javascript">  </span><br><span class="javascript">  </span><br><span class="javascript"><span class="hljs-comment">/*  </span></span><br><span class="hljs-comment"><span class="javascript"> * 在字符串中使用转义字符输入Unicode编码  </span></span><br><span class="hljs-comment"><span class="javascript"> * \u四位编码  </span></span><br><span class="hljs-comment"><span class="javascript"> */</span>  </span><br><span class="javascript"><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;\u2620&quot;</span>);  </span><br><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>  <br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>  <br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>  <br><span class="hljs-comment">&lt;!--在网页中使用Unicode编码  </span><br><span class="hljs-comment">&amp;#编码; 这里的编码需要的是10进制  </span><br><span class="hljs-comment">--&gt;</span>  <br><span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;font-size: 200px;&quot;</span>&gt;</span><span class="hljs-symbol">&amp;#9760;</span><span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>  <br><span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;font-size: 200px;&quot;</span>&gt;</span><span class="hljs-symbol">&amp;#9856;</span><span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>  <br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>  <br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span>  <br>  <br></code></pre></td></tr></table></figure><p>confirm()用于弹出一个带有确认和取消按钮的提示框<br>需要一个字符串作为参数，该字符串将会作为提示文字显示出来<br>如果用户点击确认则会返回true，如果点击取消则返回false<br>var flag = confirm(“确认删除”+name+”吗?”);  </p><h2 id="原生js"><a href="#原生js" class="headerlink" title="# 原生js"></a># 原生js</h2><h2 id="原生js实现复制内容到剪切板"><a href="#原生js实现复制内容到剪切板" class="headerlink" title="原生js实现复制内容到剪切板"></a>原生js实现复制内容到剪切板</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-title">copy</span>(<span class="hljs-params"></span>)</span> &#123;  <br>    <span class="hljs-keyword">const</span> input = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&quot;input&quot;</span>);  <br>    <span class="hljs-built_in">document</span>.body.appendChild(input);  <br>    input.setAttribute(<span class="hljs-string">&quot;value&quot;</span>,<span class="hljs-built_in">this</span>.solution.code);  <br>    input.select();  <br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">document</span>.execCommand(<span class="hljs-string">&quot;copy&quot;</span>)) &#123;  <br>        <span class="hljs-built_in">document</span>.execCommand(<span class="hljs-string">&quot;copy&quot;</span>);  <br>        <span class="hljs-comment">// console.log(&quot;复制成功&quot;);  </span><br>    &#125;  <br>    <span class="hljs-built_in">document</span>.body.removeChild(input);  <br>&#125;  <br></code></pre></td></tr></table></figure><p>  <strong><a href="https://github.com/codeOflI/codeOflI.github.io/blob/dev/source/_posts/js-note/javaScript/javaScript.md">github笔记下载地址</a></strong></p>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>roslaunch找不到包 详细 ros 工作空间 永久添加环境变量</title>
    <link href="/2021/05/27/roslaunch/"/>
    <url>/2021/05/27/roslaunch/</url>
    
    <content type="html"><![CDATA[<p>roslaunch一个包时报错:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">[aaa] is neither a launch file <span class="hljs-keyword">in</span> package [aaaa] nor is [aaaa] a launch file name<br>The traceback <span class="hljs-keyword">for</span> the exception was written to the <span class="hljs-built_in">log</span> file<br></code></pre></td></tr></table></figure><p>ubuntu16.04使用ros包时找不到,需要创建+编译工作空间,设置环境变量解决.</p><p>ros小白看了好多帖子都不可以 去B站上找了一个视频一试即成功,把它整理成文字版.如果还是不懂的话可以去看视频<br><a href="https://www.bilibili.com/video/BV1YK4y1P7jS?from=search&seid=685743644250064773">https://www.bilibili.com/video/BV1YK4y1P7jS?from=search&amp;seid=685743644250064773</a></p><h2 id="一-创建工作空间"><a href="#一-创建工作空间" class="headerlink" title="一.创建工作空间"></a>一.创建工作空间</h2><p>1.创建文件夹,这里可以是任意位置,也可以是任意名称</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">mkdir -p ~/xxx/src<br></code></pre></td></tr></table></figure><p>2.进入文件夹</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> ~/xxx/src<br></code></pre></td></tr></table></figure><p>3.将你的包放到src中,并初始化工作空间.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">catkin_init_workspace<br></code></pre></td></tr></table></figure><h2 id="二-编译工作空间"><a href="#二-编译工作空间" class="headerlink" title="二.编译工作空间"></a>二.编译工作空间</h2><p>1.回到工作空间路径下,从src返回工作空间,即到xxx目录下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span>..<br></code></pre></td></tr></table></figure><p>2.编译工作空间,编译过后就会多出两个文件夹,build和devel</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">catkin_make<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/202105272056222.png" alt="编译工作空间后"><br>编译过后xxx文件夹下如图所示,例此处 xxx 为 tuw_multi_robot.</p><h2 id="三-设置环境变量-告诉系统这是工作空间的一个路径-建议直接跳2永久添加进系统"><a href="#三-设置环境变量-告诉系统这是工作空间的一个路径-建议直接跳2永久添加进系统" class="headerlink" title="三.设置环境变量,告诉系统这是工作空间的一个路径,建议直接跳2永久添加进系统!!"></a>三.设置环境变量,告诉系统这是工作空间的一个路径,<strong>建议直接跳2永久添加进系统!!</strong></h2><p>1.添加环境变量,还是在上面的xxx文件夹下.(建议直接用2)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">source</span> devel/setup.bash<br></code></pre></td></tr></table></figure><p>查看添加是否成功,执行此命令后能看到xxx就是成功了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-variable">$ROS_PACKAGE_PATH</span><br></code></pre></td></tr></table></figure><p>此时,再roslaunch你的包就可以了.<br>不过!!!!当我们重新打开一个终端roslaunch的时候,还是找不到,原因是没有将路径全局地写进系统.</p><p>2.永久添加环境变量</p><p>2.1 写入.bashrc文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">gedit ~/.bashrc<br></code></pre></td></tr></table></figure><p>2.2 在.bashrc最下面加入环境变量,把xxx的文件路径加上devel/setup.bash,source进去.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">source</span> ......./xxx/devel/setup.bash<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210527211106879.png" alt="bashrc加入环境变量"><br>编辑好后点击save</p><p>2.3 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">source</span> devel/setup.bash<br></code></pre></td></tr></table></figure><p>此时roslaunch应该也可以了.</p>]]></content>
    
    
    <categories>
      
      <category>MARL</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>ubuntu16.04启动vrep V4.1.0、使用python API需要的文件</title>
    <link href="/2021/01/19/vrep/"/>
    <url>/2021/01/19/vrep/</url>
    
    <content type="html"><![CDATA[<h2 id="1-ubuntu16-04启动vrep-V4-1-0教育版方法（感觉它更名CoppeliaSim了）"><a href="#1-ubuntu16-04启动vrep-V4-1-0教育版方法（感觉它更名CoppeliaSim了）" class="headerlink" title="1.ubuntu16.04启动vrep V4.1.0教育版方法（感觉它更名CoppeliaSim了）"></a>1.ubuntu16.04启动vrep V4.1.0教育版方法（感觉它更名CoppeliaSim了）</h2><p>打开文件夹位置，输入：./coppeliaSim.sh</p><h2 id="2-要用vrep（coppeliaSim）python脚本的远程API，需要以下三项："><a href="#2-要用vrep（coppeliaSim）python脚本的远程API，需要以下三项：" class="headerlink" title="2.要用vrep（coppeliaSim）python脚本的远程API，需要以下三项："></a>2.要用vrep（coppeliaSim）python脚本的远程API，需要以下三项：</h2><ol><li>sim.py</li><li>simConst.py</li><li>remoteApi.dll, remoteApi.dylib or remoteApi.so (取决于你的操作系统)</li></ol><p>以上第1.2文件在CoppeliaSim的安装位置的：<em>programming/remoteApiBindings/python</em><br><img src="https://img-blog.csdnimg.cn/20210119162441475.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Zhbjk2MDkxOQ==,size_16,color_FFFFFF,t_70"></p><p>第3在<em>programming/remoteApiBindings/lib/lib</em>中<br><img src="https://img-blog.csdnimg.cn/20210119162441412.png"></p><p>CoppeliaSim远程API功能的前缀都是”simx”。</p><h3 id="附python-remote-API使用说明书原文："><a href="#附python-remote-API使用说明书原文：" class="headerlink" title="附python remote API使用说明书原文："></a>附python remote API使用说明书原文：</h3><p><img src="https://img-blog.csdnimg.cn/20210119162441569.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Zhbjk2MDkxOQ==,size_16,color_FFFFFF,t_70"><br>参考：<br>官方说明书 <a href="https://www.coppeliarobotics.com/helpFiles/index.html">https://www.coppeliarobotics.com/helpFiles/index.html</a></p>]]></content>
    
    
    <categories>
      
      <category>MARL</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
