<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>JS高级04_进程与线程、浏览器模块、定时器、时间循环机制</title>
    <link href="/2021/08/29/JSadvance04/"/>
    <url>/2021/08/29/JSadvance04/</url>
    
    <content type="html"><![CDATA[<h1 id="1-线程与进程"><a href="#1-线程与进程" class="headerlink" title="1. 线程与进程"></a>1. 线程与进程</h1><h2 id="1-进程"><a href="#1-进程" class="headerlink" title="1). 进程:"></a>1). 进程:</h2><p>（即打开一个程序）</p><p>程序的一次执行, 它占有一片独有的内存空间<br>可以通过windows任务管理器查看进程</p><h2 id="2-线程"><a href="#2-线程" class="headerlink" title="2). 线程:"></a>2). 线程:</h2><p>（即比如 一个程序里有负责渲染的、网络的 等等线程）</p><p>是进程内的一个独立执行单元<br>是程序执行的一个完整流程<br>是CPU的最小调度单元</p><p>进程 &gt; 线程</p><h2 id="3-关系"><a href="#3-关系" class="headerlink" title="3). 关系"></a>3). 关系</h2><p>一个进程中一般至少有一个运行的线程:主线程<br>一个进程中也可以同时运行多个线程，我们会说程序是多线程运行的<br>一个进程内的数据可以供其中的多个线程直接共享<br>多个进程之间的数据是不能直接共享的</p><h1 id="2-浏览器内核模块组成"><a href="#2-浏览器内核模块组成" class="headerlink" title="2. 浏览器内核模块组成"></a>2. 浏览器内核模块组成</h1><p>内核由很多模块组成：</p><h2 id="1-主线程"><a href="#1-主线程" class="headerlink" title="1). 主线程"></a>1). 主线程</h2><p>js引擎模块 : 负责js程序的编译与运行<br>html,css文档解析模块 : 负责页面文本的解析<br>DOM/CSS模块 : 负责dom/css在内存中的相关处理<br>布局和渲染模块 : 负责页面的布局和效果的绘制(内存中的对象)</p><h2 id="2-分线程"><a href="#2-分线程" class="headerlink" title="2). 分线程"></a>2). 分线程</h2><p>定时器模块 : 负责定时器的管理<br>事件响应模块 : 负责事件的管理<br>网络请求模块 : 负责Ajax请求</p><h2 id="3-js线程"><a href="#3-js线程" class="headerlink" title="3). js线程"></a>3). js线程</h2><p>js是单线程（所以可以叫主线程）执行的(回调函数也是在主线程)</p><p>单线程特点:<br>1．代码从上至下依次执行<br>2．同步&amp;异步同步任务可能会导致阻塞<br>3．同步代表:alert( ) console.log() 赋值语句<br>4.异步代表:定时器，事件的回调</p><p><del>H5提出了实现多线程的方案: Web Workers   —&gt;Worker</del><br><del>只能是主线程更新界面</del></p><h1 id="3-定时器问题"><a href="#3-定时器问题" class="headerlink" title="3. 定时器问题:"></a>3. 定时器问题:</h1><p>定时器并不 真正按照规定时间执行<br>如果在主线程执行了一个长时间的操作, 可能导致延时才处理，所以不要在定时器后放很耗资源的代码段</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> oldTime = <span class="hljs-built_in">Date</span>.now();<br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;花费的时间: &#x27;</span>, <span class="hljs-built_in">Date</span>.now() - oldTime);<br>&#125;,<span class="hljs-number">2000</span>)<br><span class="hljs-comment">//千万要注意不要在定时器的后边放置任务量特别大的代码段,不然花费的时间会很长很长</span><br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000000</span>; i++) i<br><span class="hljs-built_in">console</span>.log(i);<br><br></code></pre></td></tr></table></figure><h1 id="4-事件循环机制"><a href="#4-事件循环机制" class="headerlink" title="4. 事件循环机制"></a>4. 事件循环机制</h1><p>事件循环机制：</p><p>1.js是单线程的<br>2.所有的js代码都会在主线程执行<br>3.同步任务加载即执行<br>4.异步任务不会立即执行，而是会交给对应的管理模块<br>5.管理模块一直在监视异步任务是否满足条件，如果满足条件会将对应的回调放入callback queue(回调队列)<br>6.主线程上的同步任务执行完以后 会通过event loop(事件轮询机制)询问callback queue：</p><ul><li>查看事件是否有可执行的回调函数，如果有将回调钩到主线程上执行</li><li>如果没有待会再来问 </li></ul><p><img src="/2021/08/29/JSadvance04/img1.png" alt="image-20210823173030400"></p><h2 id="1-代码分类"><a href="#1-代码分类" class="headerlink" title="1). 代码分类"></a>1). 代码分类</h2><pre><code>初始化执行代码: 包含绑定dom事件监听, 设置定时器, 发送ajax请求的代码回调执行代码: 处理回调逻辑</code></pre><h2 id="2-js引擎执行代码的基本流程"><a href="#2-js引擎执行代码的基本流程" class="headerlink" title="2). js引擎执行代码的基本流程:"></a>2). js引擎执行代码的基本流程:</h2><pre><code>初始化代码===&gt;回调代码</code></pre><h2 id="3-模型的2个重要组成部分"><a href="#3-模型的2个重要组成部分" class="headerlink" title="3). 模型的2个重要组成部分:"></a>3). 模型的2个重要组成部分:</h2><pre><code>事件管理模块回调队列</code></pre><h2 id="4-模型的运转流程"><a href="#4-模型的运转流程" class="headerlink" title="4). 模型的运转流程"></a>4). 模型的运转流程</h2><pre><code>执行初始化代码, 将事件回调函数交给对应模块管理当事件发生时, 管理模块会将回调函数及其数据添加到回调列队中只有当初始化代码执行完后(可能要一定时间), 才会遍历读取回调队列中的回调函数执行</code></pre>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>JS高级03_对象的创建、继承、GC</title>
    <link href="/2021/08/29/JSadvance03/"/>
    <url>/2021/08/29/JSadvance03/</url>
    
    <content type="html"><![CDATA[<h1 id="1-对象的创建（设计）模式"><a href="#1-对象的创建（设计）模式" class="headerlink" title="1. 对象的创建（设计）模式"></a>1. 对象的创建（设计）模式</h1><h2 id="1-Object构造函数模式"><a href="#1-Object构造函数模式" class="headerlink" title="1). Object构造函数模式"></a>1). Object构造函数模式</h2><p>缺点：语句多，流程繁杂</p><pre><code>var obj = &#123;&#125;obj.name = &#39;Tom&#39;obj.setName = function(name)&#123;this.name=name&#125;</code></pre><h2 id="2-对象字面量模式-一下都定义了"><a href="#2-对象字面量模式-一下都定义了" class="headerlink" title="2). 对象字面量模式 {}一下都定义了"></a>2). 对象字面量模式 {}一下都定义了</h2><p>优点：书写简单，直观。</p><p>缺点：new多个实例对象的时候，重复代码多。</p><pre><code>var obj = &#123;    name : &#39;Tom&#39;,    setName : function(name)&#123;this.name = name&#125;&#125;</code></pre><h2 id="3-构造函数模式"><a href="#3-构造函数模式" class="headerlink" title="3). 构造函数模式"></a>3). 构造函数模式</h2><p>优点：可以大量new，避免重复代码</p><p>缺点：不能明确区分属于哪一类</p><pre><code>function Person(name, age) &#123;    this.name = name    this.age = age    this.setName = function(name)&#123;this.name=name&#125;&#125;new Person(&#39;tom&#39;, 12)</code></pre><h2 id="4-构造函数-原型的组合模式"><a href="#4-构造函数-原型的组合模式" class="headerlink" title="4). 构造函数+原型的组合模式"></a>4). 构造函数+原型的组合模式</h2><p>方法<strong>写在原型</strong>上，可以不用每次new一个实例，都开辟出内存空间，比较省内存。</p><pre><code>function Person(name, age) &#123;    this.name = name    this.age = age&#125;Person.prototype.setName = function(name)&#123;this.name=name&#125;new Person(&#39;tom&#39;, 12) </code></pre><h1 id="2-继承"><a href="#2-继承" class="headerlink" title="2. 继承"></a>2. 继承</h1><h2 id="1-原型链继承-继承方法"><a href="#1-原型链继承-继承方法" class="headerlink" title="1). 原型链继承 : 继承方法"></a>1). 原型链继承 : 继承方法</h2><ul><li><p>子类的原型对象===父类的实例，例如:child.prototype = new Parent();</p></li><li><p>注意点:以上的步骤会导致子类原型的构造器属性丢失，所以需要手动添加构造器属性</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">child.prototype.constructor = child;<br><br><span class="hljs-keyword">function</span> <span class="hljs-constructor">Parent()</span>&#123;&#125;<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Parent</span>.</span></span>prototype.test = <span class="hljs-keyword">function</span><span class="hljs-literal">()</span>&#123;&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-constructor">Child()</span>&#123;&#125;<br><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Child</span>.</span></span>prototype = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Parent()</span> <span class="hljs-comment">//△子类原型指向父类的实例</span><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Child</span>.</span></span>prototype.constructor = Child <span class="hljs-comment">//△然后手动校正 子类的构造器属性重新指向子类（因为上面的操作会新指向一个内存，而丢弃原有的原型对象内存，原有的是有构造器属性的。）</span><br><br>var child = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Child()</span> <br>child.test<span class="hljs-literal">()</span> <span class="hljs-comment">//调用父类型的方法</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="2-借用构造函数-得到属性，无继承关系"><a href="#2-借用构造函数-得到属性，无继承关系" class="headerlink" title="2). 借用构造函数 : 得到属性，无继承关系"></a>2). 借用构造函数 : 得到属性，无继承关系</h2><ul><li><p>在子类的构造函数中调用父类的构造函数-注意点:父类构造函数的this指向问题</p></li><li><p>解决方案:通过call/apply强制修改this的指向 —&gt; 当前子类的实例对象</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">function</span> <span class="hljs-constructor">Parent(<span class="hljs-params">xxx</span>)</span>&#123;this.xxx = xxx&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-constructor">Child(<span class="hljs-params">xxx</span>,<span class="hljs-params">yyy</span>)</span>&#123;<br>  <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Parent</span>.</span></span>call(this, xxx) <span class="hljs-comment">//△借用父类型的构造函数。不写this就window调用了，写半天也没把xxx属性写到子类上。</span><br>  <span class="hljs-comment">//或Parent.apply(this,[xxx]) apply与call用法不同，得是数组。</span><br>&#125;<br>var child = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Child(&#x27;<span class="hljs-params">a</span>&#x27;, &#x27;<span class="hljs-params">b</span>&#x27;)</span>  <span class="hljs-comment">//child.xxx为&#x27;a&#x27;, 但child没有test()</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="3-组合"><a href="#3-组合" class="headerlink" title="3). 组合"></a>3). 组合</h2><pre><code>function Parent(xxx)&#123;this.xxx = xxx&#125;Parent.prototype.test = function()&#123;&#125;function Child(xxx,yyy)&#123;  Parent.call(this, xxx) //借用构造函数   this.Parent(xxx)&#125;Child.prototype = new Parent() //得到test()Child.prototype.constructor = Childvar child = new Child() //child.xxx为&#39;a&#39;, 也有test()</code></pre><h1 id="3-理解"><a href="#3-理解" class="headerlink" title="3. 理解"></a>3. 理解</h1><h2 id="1-定义一个函数背后做了什么"><a href="#1-定义一个函数背后做了什么" class="headerlink" title="1). 定义一个函数背后做了什么?"></a>1). 定义一个函数背后做了什么?</h2><pre><code>创建一个Function的实例对象给对象添加prototype属性, 其值为object空对象(原型对象)给原型对象添加constructor属性, 指向当前函数对象</code></pre><h2 id="2-new一个对象背后做了些什么"><a href="#2-new一个对象背后做了些什么" class="headerlink" title="2). new一个对象背后做了些什么?"></a>2). new一个对象背后做了些什么?</h2><pre><code>创建一个新的空对象给对象设置__proto__, 值为构造函数对象的prototype属性值通过对象执行构造函数体(给对象添加属性/方法)</code></pre><h1 id="垃圾回收GC"><a href="#垃圾回收GC" class="headerlink" title="垃圾回收GC"></a>垃圾回收GC</h1><p>garbage collection<br>垃圾回收机制：循环机制，反复检测环境中的垃圾</p><h2 id="1-计数清除"><a href="#1-计数清除" class="headerlink" title="1.计数清除"></a>1.计数清除</h2><p>IE低版本，老的chrome<br>看内存的地址身上有几个指针指向，当一块内存地址身上指针个数为0，说明这块内存马上要被回收</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs nix">var <span class="hljs-attr">obj</span> = &#123;name : &#x27; kobe &#x27; &#125;<br><span class="hljs-attr">obj</span> = <span class="hljs-literal">null</span>;<br><br>//但是以下互相指的情况不会被GC<br>var <span class="hljs-attr">obj</span> = &#123;<br>a: obj1<br>&#125;<br><br>var <span class="hljs-attr">obj1</span> = &#123;<br>b: obj<br>&#125;<br><br><span class="hljs-attr">obj</span> = <span class="hljs-literal">null</span>;<br><span class="hljs-attr">obj1</span> = <span class="hljs-literal">null</span>;<br></code></pre></td></tr></table></figure><h2 id="2-标记清除"><a href="#2-标记清除" class="headerlink" title="2.标记清除"></a>2.标记清除</h2><p>进入到代码行的环境以后检测到 需要使用的变量 就在其身上加一个进场标记，在代码执行完将return的时候，就会在 之前加标记的变量的身上 再添加一个出场标记</p>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>JS高级02_原型、执行上下文、作用域、闭包</title>
    <link href="/2021/08/29/JSadvance02/"/>
    <url>/2021/08/29/JSadvance02/</url>
    
    <content type="html"><![CDATA[<p>P20 P21没看 +22前11</p><h1 id="1-原型与原型链"><a href="#1-原型与原型链" class="headerlink" title="1. 原型与原型链"></a>1. 原型与原型链</h1><ol><li>函数的prototype属性(图)</li></ol><ul><li><p>每个函数都有一个prototype属性, 它默认指向一个Object空对象(即称为: 原型对象)</p></li><li><p>原型对象中有一个属性constructor, 它指向函数对象</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-keyword">function</span> Person( ) &#123;<br><br>&#125;<br><br><span class="hljs-regexp">//</span><span class="hljs-number">1</span>．每一个函数都有一个属性prototype<br>console.log(Person.prototype);<span class="hljs-regexp">//</span>空对象---&gt;原型对象（显式原型对象)<br><span class="hljs-regexp">//</span>Person.prototype.constructor = 函数本身 声明当前的构造器是谁<br><br>var person1 = new Person(); <span class="hljs-regexp">//</span>生成实例对象<br><br><br><span class="hljs-regexp">//</span><span class="hljs-number">2</span>．每一个实例对象身上都有一个属性_proto_，该属性指向当前实例对象的原型对象(隐式原型对象) 带下划线的叫隐式原型对象△<br><span class="hljs-regexp">//</span><span class="hljs-number">3</span>．构造函数的显式原型对象 === 当前构造函数实例对象 的隐式原型对象<br>console.log(Person.prototype  ===  person1._proto_); <span class="hljs-regexp">//</span> true<br></code></pre></td></tr></table></figure></li></ul><ol start="2"><li>给原型对象添加属性(一般都是方法)</li></ol><ul><li>作用：函数的所有实例对象 都能有原型中的方法（或属性，属性更少因为它一般不公共），即它是公共的</li><li>好处：节省内存</li></ul><h2 id="1-所有函数都有一个特别的属性"><a href="#1-所有函数都有一个特别的属性" class="headerlink" title="1). 所有函数都有一个特别的属性:"></a>1). 所有函数都有一个特别的属性:</h2><pre><code>`prototype` : 显式原型属性</code></pre><h2 id="2-所有实例对象都有一个特别的属性"><a href="#2-所有实例对象都有一个特别的属性" class="headerlink" title="2). 所有实例对象都有一个特别的属性:"></a>2). 所有实例对象都有一个特别的属性:</h2><pre><code>`__proto__` : 隐式原型属性另外：带下划线的是内置方法 以前不可以改动，ES6中可以改了。</code></pre><h2 id="3-显式原型与隐式原型的关系"><a href="#3-显式原型与隐式原型的关系" class="headerlink" title="3). 显式原型与隐式原型的关系"></a>3). 显式原型与隐式原型的关系</h2><pre><code>函数的prototype: 定义函数时被自动赋值, 值默认为&#123;&#125;, 即用为原型对象实例对象的__proto__: 在创建实例对象时被自动添加, 并赋值为构造函数的prototype值原型对象即为当前实例对象的父对象</code></pre><h2 id="4-原型链"><a href="#4-原型链" class="headerlink" title="4). 原型链"></a>4). 原型链</h2><p><img src="/2021/08/29/JSadvance02/img1.png"></p><p>原型链：△</p><p>当使用对象.属性(方法)的时候， </p><p>1.在自身 属性(方法)找</p><p>2.在自身的原型（是一个实例对象） 的属性(方法) 找</p><p>3.Object的原型的 属性(方法) 再原型对象就 = null了。真没有。<br>    Object是个函数对象（就是个函数，但它也是个对象）不是实例对象，Object的原型是实例对象，它有一个toString()方法。</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">a</span><span class="hljs-selector-class">.b</span> <br><br>找<span class="hljs-selector-tag">a</span>(变量)会沿着作用域链找，找<span class="hljs-selector-tag">b</span>(对象的属性)会沿着原型链找<br></code></pre></td></tr></table></figure><p>再上课举例：</p><p><img src="/2021/08/29/JSadvance02/img2.png" alt="image-20210815161200572"></p><pre><code>所有的实例对象都有__proto__属性, 它指向的就是原型对象这样通过__proto__属性就形成了一个链的结构----&gt;原型链当查找对象内部的属性/方法时, js引擎自动沿着这个原型链查找当给对象属性赋值时不会使用原型链, 而只是在当前对象中进行操作</code></pre><p>另外，新建一个变量，也就是new一个实例。</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">var</span> obj = &#123;&#125;;  与  <span class="hljs-keyword">var</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-type">Object</span>() 一样<br><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">12</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]  与  arr = <span class="hljs-keyword">new</span> <span class="hljs-type">Array</span>() 一样<br></code></pre></td></tr></table></figure><h2 id="函数对象-与-对象"><a href="#函数对象-与-对象" class="headerlink" title="函数对象  与 对象"></a>函数对象  与 对象</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Fun</span>(<span class="hljs-params"> </span>) </span>&#123;<br><br>&#125;<br><br><span class="hljs-comment">//Fun() || Fun .xxx ---&gt;函数对象</span><br>Fun.xxx = <span class="hljs-string">&#x27;123&#x27;</span>;<br><br><span class="hljs-built_in">console</span>.log ( Fun) ;<span class="hljs-comment">//函数性质：打印函数本身 没有123</span><br><span class="hljs-built_in">console</span>.log( Fun. xxx);<span class="hljs-comment">//对象性质：打印123</span><br>------------------------------------------<br><span class="hljs-keyword">var</span> obj = &#123;&#125;;<br><span class="hljs-built_in">console</span>.log(obj);<br><span class="hljs-comment">// obj = new Object()</span><br>obj.xxx = <span class="hljs-number">123</span><br><span class="hljs-built_in">console</span>.log(obj.xxx); <span class="hljs-comment">//纯 对象</span><br><br></code></pre></td></tr></table></figure><h2 id="所有函数都由Function-和-Object-派生"><a href="#所有函数都由Function-和-Object-派生" class="headerlink" title="所有函数都由Function() 和 Object()派生"></a>所有函数都由Function() 和 Object()派生</h2><p><img src="/2021/08/29/JSadvance02/img3.jpeg" alt="img"></p><p>Function可以new自己，Object</p><p>Object可以new Function</p><p>金字塔：Object类—-Function Array类</p><p>另外：a instanceof b何时返回true（属于某一类、new b 能得到a）：a的隐式原型链上 可以找到 b的显式原型对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Foo</span>(<span class="hljs-params"></span>) </span>&#123;  &#125;<br><span class="hljs-keyword">var</span> f1 = <span class="hljs-keyword">new</span> Foo();<br><span class="hljs-built_in">console</span>.log(f1 <span class="hljs-keyword">instanceof</span> Foo);<span class="hljs-comment">//true</span><br><span class="hljs-built_in">console</span>.log(f1 <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Object</span>);<span class="hljs-comment">//true</span><br><span class="hljs-built_in">console</span>.log(f1 <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Function</span>);<span class="hljs-comment">//false</span><br><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Object</span> <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Function</span>)<br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Object</span> <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Object</span>)<br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Function</span> <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Object</span>)<br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Function</span> <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Function</span>)<br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Object</span> <span class="hljs-keyword">instanceof</span>  Foo);<span class="hljs-comment">//false上面四个都是true</span><br></code></pre></td></tr></table></figure><h2 id="5-详图"><a href="#5-详图" class="headerlink" title="5). 详图"></a>5). 详图</h2><pre><code>function Foo () &#123;&#125;var f1 = new Foo()var f2 = new Foo()var o1 = &#123;&#125;var o2 = &#123;&#125;</code></pre><p><img src="/2021/08/29/JSadvance02/img4.png"></p><h1 id="2-执行上下文与执行上下文栈"><a href="#2-执行上下文与执行上下文栈" class="headerlink" title="2. 执行上下文与执行上下文栈"></a>2. 执行上下文与执行上下文栈</h1><h2 id="1-变量提前声明与函数提前声明"><a href="#1-变量提前声明与函数提前声明" class="headerlink" title="1). 变量提前声明与函数提前声明"></a>1). 变量提前声明与函数提前声明</h2><p>提前声明讲得贼好：</p><p><a href="https://www.cnblogs.com/lvonve/p/9871226.html">https://www.cnblogs.com/lvonve/p/9871226.html</a></p><p>变量提前声明（预解析）: 在变量定义语句之前, 就可以访问到这个变量(undefined)<br>函数提前声明: 在函数定义语句之前, 就执行该函数(函数本身)<br>先有函数提升, 后有变量提升</p><p>原理:<br>js引擎在js代码正式执行之前会做一些预处理工作</p><p>1、找var和function关键字<br>（不带var关键字的变量可以写，但是分两种情况：1.在全局写不会被预解析 2.在函数里写会自动升成全局的  进行更改或定义）<br>2．找到var以后将var后边的变量提前声明但是不赋值var a;<br>3．找到function以后定义该函数</p><figure class="highlight scilab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs scilab">提前声明举例<br>console.<span class="hljs-built_in">log</span>( username);<span class="hljs-comment">//undefined</span><br>aTest();<span class="hljs-comment">//aTest</span><br>var username = <span class="hljs-string">&#x27;kobe&#x27;</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">aTest</span><span class="hljs-params">()</span>&#123;</span><br>console.<span class="hljs-built_in">log</span>( <span class="hljs-string">&quot;aTest&#x27;</span> );<br>&#125;<br><br>-------<br><br>var fun2 = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span>&#123;</span><br><br>&#125;<br><span class="hljs-comment">//这个只是 变 量 的提前声明 fun2 undefined</span><br></code></pre></td></tr></table></figure><p>冷知识：<br>        1全局定义变量不要定义name 因为window对象上本身就有name属性（一般的不定义的函数、属性会报错，而name不报错但是空的）<br>        2函数有个默认的属性name === 函数名</p><h2 id="2-理解执行上下文-是什么？是全局、局部的-预习变量和函数"><a href="#2-理解执行上下文-是什么？是全局、局部的-预习变量和函数" class="headerlink" title="2). 理解执行上下文 是什么？是全局、局部的 预习变量和函数"></a>2). 理解执行上下文 是什么？是全局、局部的 预习变量和函数</h2><p>执行上下文: 由js引擎自动创建的对象, 包含对应作用域中的所有变量属性（函数）。我认为就是提前声明！+ 找作用域链 + 找this？<br>执行上下文栈: 用来管理产生的多个执行上下文。不嵌套<br>                        在source中的 call stack中可查看</p><p>变量被写入对象之后，再遇到还会再读，写入值一遍，函数不会再读一遍了。</p><h2 id="4-执行上下文生命周期"><a href="#4-执行上下文生命周期" class="headerlink" title="4). 执行上下文生命周期"></a>4). 执行上下文生命周期</h2><p>全局 : 准备执行全局代码前产生, 当页面刷新/关闭页面时死亡<br>函数 : 准备调用函数时产生, 函数执行完时死亡。<br>            ？我理解：没等到调用那行呢，就才遍历到了函数名第一行，就产生了</p><p><img src="/2021/08/29/JSadvance02/img5.png" alt="image-20210816213116676"></p><h2 id="5-包含哪些属性"><a href="#5-包含哪些属性" class="headerlink" title="5). 包含哪些属性:"></a>5). 包含哪些属性:</h2><pre><code>全局 :     用var定义的全局变量  ==&gt;undefined    使用function声明的函数   ===&gt;function    this   ===&gt;window函数 :    用var定义的局部变量  ==&gt;undefined    使用function声明的函数   ===&gt;function    this   ===&gt; 调用函数的对象, 如果没有指定就是window     形参变量   ===&gt;对应实参值    arguments ===&gt;实参列表的伪数组</code></pre><h2 id="6-执行上下文创建和初始化的过程"><a href="#6-执行上下文创建和初始化的过程" class="headerlink" title="6). 执行上下文创建和初始化的过程"></a>6). 执行上下文创建和初始化的过程</h2><p>执行上下文:</p><p>原理：</p><p>js引擎在js代码正式执行之前会先创建执行环境，在执行环境中作预处理工作工作内容:</p><p>过程：</p><p>1.创建空对象—-&gt;执行上下文对象<br>2.该空对象用于收集变量，函数，函数的参数（找var和function)<br>3.创建作用域链<br>4.确认this的指向:   全局:window      局部: this —&gt;?</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-comment">//1.创建全局的执行上下文 入栈(anonymous)</span><br><span class="hljs-selector-tag">var</span> <span class="hljs-selector-tag">a</span> = <span class="hljs-number">10</span><br><br><span class="hljs-selector-tag">var</span> bar = function (x) &#123;<span class="hljs-comment">//创建bar的执行上下文 入栈bar</span><br>    <span class="hljs-selector-tag">var</span> <span class="hljs-selector-tag">b</span> = <span class="hljs-number">5</span><br>    foo(x + b)<br>&#125;<br><br><span class="hljs-selector-tag">var</span> foo = function(y) &#123;<span class="hljs-comment">//创建foo的执行上下文 入栈foo</span><br>    <span class="hljs-selector-tag">var</span> c = <span class="hljs-number">5</span><br>    console<span class="hljs-selector-class">.log</span>(<span class="hljs-selector-tag">a</span> +c +y)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-title">bar</span><span class="hljs-params">( <span class="hljs-number">10</span>)</span></span><br><br></code></pre></td></tr></table></figure><p>冷知识：</p><ul><li><p>所有的函数都有返回值，如果不指定返回值，就是undefined</p></li><li><p>嵌套函数的内部函数 没有被引用到（在fun1里面 fun2() ），fun2将不会被上下文。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>. log( <span class="hljs-string">&quot;xxx&quot;</span>);<br><span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fun</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log( <span class="hljs-string">&#x27;-----&#x27;</span> );<br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fun2</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-comment">//空的 本该有fun2的提前声明，结果没有。</span><br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure></li></ul><h2 id="上下文练习题"><a href="#上下文练习题" class="headerlink" title="上下文练习题"></a>上下文练习题</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;global begin: &#x27;</span>+ i)<br><span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span><br>foo(<span class="hljs-number">1</span>);<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params">i</span>) </span>&#123;<br><span class="hljs-keyword">if</span> (i == <span class="hljs-number">4</span>) &#123;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;foo() begin:&#x27;</span> + i);<br>foo(i + <span class="hljs-number">1</span>);<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;foo() end:&#x27;</span> + i);<br>&#125;<br><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;global end: &#x27;</span> + i)<span class="hljs-comment">//函数内部没有修改i 修改了也犯不着全局的i = 1？</span><br><br><span class="hljs-comment">//undefined 1 2 3 3 2 1 1</span><br></code></pre></td></tr></table></figure><h2 id="提前声明易考知识点："><a href="#提前声明易考知识点：" class="headerlink" title="提前声明易考知识点："></a>提前声明易考知识点：</h2><p>1.当有同名function和变量，不管顺序，预解析结果一定是function。<br>    原理：只要看见了function就不再另声明了。（注意仅限提前声明！！！！）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> a) <span class="hljs-comment">//function</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">a</span>(<span class="hljs-params"></span>) </span>&#123;&#125;<br><span class="hljs-keyword">var</span> a;<br></code></pre></td></tr></table></figure><p>2.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">if</span> (!(b <span class="hljs-keyword">in</span> <span class="hljs-built_in">window</span>)) &#123;<span class="hljs-comment">//in：判断b 是否是 window的一个属性</span><br>  <span class="hljs-keyword">var</span> b = <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-built_in">console</span>.log(b)<span class="hljs-comment">//undefined</span><br><br><span class="hljs-comment">//这不是函数，if不是个作用域。所以var b被全局提前声明，window.b if里条件不满足不执行。</span><br></code></pre></td></tr></table></figure><p>3.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//预解析 c = function()&#123;&#125;</span><br><span class="hljs-keyword">var</span> c = <span class="hljs-number">1</span>  <span class="hljs-comment">// c = 1</span><br> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">c</span>(<span class="hljs-params">c</span>) </span>&#123;<span class="hljs-comment">//重点！！！函 数 预解析了就不会再读一遍赋值了 所以c：function  ---&gt;  1</span><br>   <span class="hljs-built_in">console</span>.log(c)<br>   <span class="hljs-keyword">var</span> c = <span class="hljs-number">3</span><br> &#125;<br> c(<span class="hljs-number">2</span>)<br> <span class="hljs-comment">//报错 因为c是一个变量不是一个函数</span><br></code></pre></td></tr></table></figure><h1 id="3-作用域与作用域链"><a href="#3-作用域与作用域链" class="headerlink" title="3. 作用域与作用域链"></a>3. 作用域与作用域链</h1><h2 id="1-定义"><a href="#1-定义" class="headerlink" title="1). 定义:"></a>1). 定义:</h2><p>作用域: 代码执行区域。 在编码时就确定了, 不会再变化<br>作用域链: 多个嵌套的作用域 查找变量时 先找当前的，再找往外的，直到全局作用域。如果还没有，会报错，xxx is not defined </p><h2 id="2-分类"><a href="#2-分类" class="headerlink" title="2). 分类:"></a>2). 分类:</h2><p>全局<br>函数（局部）<br><del>js没有块作用域(在ES6之前)</del></p><h2 id="作用域销毁"><a href="#作用域销毁" class="headerlink" title="作用域销毁"></a>作用域销毁</h2><p>局部销毁：函数执行完毕</p><p>全局销毁：关闭浏览器</p><h2 id="3-作用域作用"><a href="#3-作用域作用" class="headerlink" title="3). 作用域作用"></a>3). 作用域作用</h2><p>作用域: 隔离变量, 可以在不同作用域定义同名的变量不冲突<br>作用域链: 查找变量</p><h2 id="4-作用域-执行上下文-区别"><a href="#4-作用域-执行上下文-区别" class="headerlink" title="4). 作用域 执行上下文 区别"></a>4). 作用域 执行上下文 区别</h2><p>作用域: 静态的, 编码时就确定了(不是在运行时), 一旦确定就不会变化了<br>执行上下文: 动态的, 执行代码时动态创建, 当执行结束消失<br>联系: </p><ul><li>执行上下文环境 是在对应的作用域中的 </li><li>在作用域中查找变量去 当前作用域下的 执行上下文对象中找</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">function <span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">()</span></span> &#123;<br>    <br>    console.log(num);<span class="hljs-comment">// &#123;num: undefined&#125;</span><br>    console.log(b);<span class="hljs-comment">//报错！undefined</span><br>    <span class="hljs-keyword">var</span> num = <span class="hljs-number">123</span>;<br>    b = <span class="hljs-number">234</span>;<span class="hljs-comment">//注意这里！！ 全局提前声明的时候，看不到他，局部提前声明的时候，不带var也看不到。只有执行完这一行，全局就拥有一个b了。所以上面是报错，下面是234</span><br>    console.log(b);<span class="hljs-comment">//234</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">()</span></span>;<br><br></code></pre></td></tr></table></figure><h2 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-number">1</span><br><span class="hljs-comment">//我做错了！</span><br><span class="hljs-keyword">var</span> x = <span class="hljs-number">10</span>;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params"></span>) </span>&#123;<br><span class="hljs-built_in">console</span>.log(x);<span class="hljs-comment">//这自己没运行啊</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">show</span>(<span class="hljs-params">f</span>) </span>&#123;<br><span class="hljs-keyword">var</span> x = <span class="hljs-number">20</span>;<br>f();<br>&#125;<br>show(fn);<span class="hljs-comment">//函数作为参数 - 调用了fn() - fn里面没有x - 去全局找x=10</span><br><br><span class="hljs-comment">//10</span><br><span class="hljs-comment">//这道题！！千万注意！！就是作用域是固定的，两个作用域平行。还是两个函数各自分离的，只是调用了它一下！并不是在show()里调用了fn()，不 像 想象的：</span><br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">show</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-keyword">var</span> x = <span class="hljs-number">20</span>;<br>        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params"></span>)</span>&#123;<span class="hljs-comment">//这里fn的作用域就是show的子作用域了</span><br>        <span class="hljs-built_in">console</span>.log(x);<br>        &#125;<br>        fn();<span class="hljs-comment">//在这里确实是20</span><br>    &#125;<br>  <br>---------------<br><span class="hljs-number">2</span><br><span class="hljs-keyword">var</span> fn = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(fn)<br>  &#125;<br>  fn()<span class="hljs-comment">//log fn本级没有，往外找了，全局找到了 ƒ () &#123;console.log(fn)&#125;。。。</span><br>  <span class="hljs-comment">//注意这里function简写成f了吗？</span><br><br>  <span class="hljs-keyword">var</span> obj = &#123;<br>    <span class="hljs-attr">fn2</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>      <span class="hljs-built_in">console</span>.log(fn2)<span class="hljs-comment">//</span><br>    &#125;<br>  &#125;<br>  obj.fn2()<span class="hljs-comment">//会报错 is not defined。因为本级没有fn2。向上一级（注意obj不算一级！！！！，即全局）也没有fn2，因为只有obj！！！</span><br>    <span class="hljs-comment">// 所以 console.log()里面写obj.fn2 或 this.fn2 才能实现fn2所表示函数的打印。</span><br></code></pre></td></tr></table></figure><h1 id="4-闭包"><a href="#4-闭包" class="headerlink" title="4. 闭包"></a>4. 闭包</h1><p>定义：是一个闭合的容器，可以理解为是一个对象，以键值对形式存在</p><p>特点：闭包在使用的时候通常会将内部的函数return出去</p><ol start="3"><li>产生闭包的条件?</li></ol><ul><li>函数嵌套</li><li>内部函数引用了外部函数的数据(变量/函数)</li><li>外部函数调用</li></ul><h2 id="2-作用"><a href="#2-作用" class="headerlink" title="2). 作用:"></a>2). 作用:</h2><pre><code>延长外部函数 局部变量的 生命周期从外部访问函数内部的局部变量</code></pre><h2 id="3-写一个闭包程序"><a href="#3-写一个闭包程序" class="headerlink" title="3). 写一个闭包程序"></a>3). 写一个闭包程序</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//经典闭包作用：</span><br>&lt;script type=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;<br>  <br>  <br>  <span class="hljs-keyword">var</span> btns = <span class="hljs-built_in">document</span>.getElementsByTagName(<span class="hljs-string">&#x27;button&#x27;</span>)<br>  <span class="hljs-comment">//它是个伪数组：因为它具备数组的一般特征，可以通过下标取值，还有Length属性，但是！！没有数组的一般方法: foreach等等等</span><br><br> <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i=<span class="hljs-number">0</span>,length=btns.length;i&lt;length;i++) &#123;<br>    <span class="hljs-keyword">var</span> btn = btns[i]<br>    <span class="hljs-built_in">console</span>.log(i)<span class="hljs-comment">//0 1 2</span><br>    btn.onclick = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>      <span class="hljs-comment">// console.log(i)</span><br>      <span class="hljs-comment">//回调函数！！在for循环的时候没执行，跳过了。</span><br>      <span class="hljs-comment">// 等它执行的时候，每次都是3。而且本以为是2，但是循环完之后又i++了，所以是3.</span><br>      alert(<span class="hljs-string">&#x27;第&#x27;</span>+(i)+<span class="hljs-string">&#x27;个&#x27;</span>) <span class="hljs-comment">//每次都是3</span><br>    &#125;<br>  &#125;<br>-----------------------------<br><br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i=<span class="hljs-number">0</span>,length=btns.length;i&lt;length;i++) &#123;<br>    <span class="hljs-keyword">var</span> btn = btns[i]<br>    btn.index = i <span class="hljs-comment">//在这里集体都排好队起好属性名，等会对象.属性名就不会混了。通过这里 + this回调对象 实现按钮不同的信息</span><br>    btn.onclick = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>      alert(<span class="hljs-string">&#x27;第&#x27;</span>+(<span class="hljs-built_in">this</span>.index+<span class="hljs-number">1</span>)+<span class="hljs-string">&#x27;个&#x27;</span>)<br>    &#125;<br>  &#125;<br>-----------------------------<br><br>  <span class="hljs-comment">//闭包解决</span><br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i=<span class="hljs-number">0</span>,length=btns.length;i&lt;length;i++) &#123;<br>    (<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">i</span>) </span>&#123;<br>      <span class="hljs-keyword">var</span> btn = btns[i]<br>      btn.onclick = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>        alert(<span class="hljs-string">&#x27;第&#x27;</span>+(i+<span class="hljs-number">1</span>)+<span class="hljs-string">&#x27;个&#x27;</span>)<br>      &#125;<br>    &#125;)(i)<br>  &#125;<br><br><br>----------------------------<br><span class="hljs-comment">//一个简单的闭包，嵌套，引用外面的值了</span><br><span class="hljs-comment">//闭包在此处的作用：从外部访问\操作函数内部的局部变量。???</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn1</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span>;<br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn2</span>(<span class="hljs-params"></span>) </span>&#123;<br>    a++;<br>    <span class="hljs-built_in">console</span>.log(a);<br>  &#125;<br>  <span class="hljs-keyword">return</span> fn2;<br>&#125;<br><span class="hljs-keyword">var</span> f = fn1();<br>f();<br>f();<br></code></pre></td></tr></table></figure><p>外部调用，操作内部变量的操作：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-number">1.</span>在html中<br>&lt;script <span class="hljs-keyword">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span> src=<span class="hljs-string">&quot;05_coolModule.js&quot;</span>&gt;&lt;/script&gt;<br>&lt;!--外部引用跟我在这直接写一个coolModule是一样的--&gt;<br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><span class="javascript"></span></span><br><span class="javascript"><span class="xml">  <span class="hljs-keyword">var</span> <span class="hljs-built_in">module</span> = coolModule()</span></span><br><span class="javascript"><span class="xml">  <span class="hljs-built_in">module</span>.doSomething()<span class="hljs-comment">//如果log 就是ATGUIGU,即用了内部变量。</span></span></span><br><span class="javascript"><span class="xml">  <span class="hljs-built_in">module</span>.doOtherthing()</span></span><br><span class="javascript"><span class="xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><br><br><span class="hljs-number">2.</span>在coolModule.js中<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">coolModule</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-comment">//私有的数据，外部引用了也看不到，但是可以选择向外暴露就能看到了。</span><br>  <span class="hljs-keyword">var</span> msg = <span class="hljs-string">&#x27;atguigu&#x27;</span><br>  <span class="hljs-keyword">var</span> names = [<span class="hljs-string">&#x27;I&#x27;</span>, <span class="hljs-string">&#x27;Love&#x27;</span>, <span class="hljs-string">&#x27;you&#x27;</span>]<br><br>  <span class="hljs-comment">//私有的操作数据的函数</span><br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">doSomething</span>(<span class="hljs-params"></span>) </span>&#123;<span class="hljs-comment">//产生了闭包</span><br>    <span class="hljs-built_in">console</span>.log(msg.toUpperCase())<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">doOtherthing</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(names.join(<span class="hljs-string">&#x27; &#x27;</span>))<br>  &#125;<br>  <br>  <span class="hljs-comment">//向外暴露包含多个方法的对象</span><br>  <span class="hljs-keyword">return</span> &#123;<br>    <span class="hljs-attr">doSomething</span>: doSomething,<br>    <span class="hljs-attr">doOtherthing</span>: doOtherthing<br>  &#125;<br>&#125;<br>-----------------------------<br>用法<span class="hljs-number">2</span><br><span class="hljs-number">1.</span>在html中<br>&lt;script <span class="hljs-keyword">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span> src=<span class="hljs-string">&quot;05_coolModule2.js&quot;</span>&gt;&lt;/script&gt;<br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><span class="javascript"></span></span><br><span class="javascript"><span class="xml">  coolModule2.a()<span class="hljs-comment">//coolModule2是个对象了</span></span></span><br><span class="javascript"><span class="xml">  coolModule2.b()</span></span><br><span class="javascript"><span class="xml">  </span></span><br><span class="javascript"><span class="xml"><span class="hljs-number">2.</span>在js中coolModule2.js</span></span><br><span class="javascript"><span class="xml">(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"><span class="hljs-built_in">window</span></span>) </span>&#123;</span></span><br><span class="javascript"><span class="xml">  <span class="hljs-comment">//私有的数据</span></span></span><br><span class="javascript"><span class="xml">  <span class="hljs-keyword">var</span> msg = <span class="hljs-string">&#x27;atguigu&#x27;</span></span></span><br><span class="javascript"><span class="xml">  <span class="hljs-keyword">var</span> names = [<span class="hljs-string">&#x27;I&#x27;</span>, <span class="hljs-string">&#x27;Love&#x27;</span>, <span class="hljs-string">&#x27;you&#x27;</span>]</span></span><br><span class="javascript"><span class="xml">  <span class="hljs-comment">//操作数据的函数</span></span></span><br><span class="javascript"><span class="xml">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">a</span>(<span class="hljs-params"></span>) </span>&#123;</span></span><br><span class="javascript"><span class="xml">    <span class="hljs-built_in">console</span>.log(msg.toUpperCase())</span></span><br><span class="javascript"><span class="xml">  &#125;</span></span><br><span class="javascript"><span class="xml">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">b</span>(<span class="hljs-params"></span>) </span>&#123;</span></span><br><span class="javascript"><span class="xml">    <span class="hljs-built_in">console</span>.log(names.join(<span class="hljs-string">&#x27; &#x27;</span>))</span></span><br><span class="javascript"><span class="xml">  &#125;</span></span><br><span class="javascript"><span class="xml"></span></span><br><span class="javascript"><span class="xml">  <span class="hljs-built_in">window</span>.coolModule2 =  &#123;<span class="hljs-comment">//这是啥玩意操作？对象.属性 = 对象</span></span></span><br><span class="javascript"><span class="xml">    <span class="hljs-attr">a</span>: a,<span class="hljs-comment">//前面的a可以任意起名，后面是函数名</span></span></span><br><span class="javascript"><span class="xml">    <span class="hljs-attr">b</span>: b</span></span><br><span class="javascript"><span class="xml">  &#125;</span></span><br><span class="javascript"><span class="xml">&#125;)(<span class="hljs-built_in">window</span>)</span></span><br></code></pre></td></tr></table></figure><h2 id="4-闭包应用"><a href="#4-闭包应用" class="headerlink" title="4). 闭包应用:"></a>4). 闭包应用:</h2><pre><code>循环遍历加监听（按钮赋值例子）将内部的函数返出来将函数作为实参传递给另一个函数调用JS框架(jQuery)大量使用了闭包</code></pre><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> 产生: 在嵌套内部函数定义执行完时就产生了(不是在调用)<br><span class="hljs-bullet">2.</span> 死亡: 在嵌套的内部函数成为垃圾对象时<br></code></pre></td></tr></table></figure><h2 id="5-缺点及解决"><a href="#5-缺点及解决" class="headerlink" title="5). 缺点及解决:"></a>5). 缺点及解决:</h2><pre><code>变量占用内存的时间可能会过长可能导致内存泄露解决: 能不用就不用闭包/及时释放 : var f = null; //让内部函数变量 成为垃圾对 象</code></pre><h2 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h2><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">//代码片段一</span><br><span class="hljs-keyword">var</span> name = <span class="hljs-string">&quot;The Window&quot;</span>;<br><span class="hljs-keyword">var</span> <span class="hljs-built_in">object</span> = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;My Object&quot;</span>,<br>  <span class="hljs-attr">getNameFunc</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-comment">//此处this是object</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.name;<br>    &#125;;<br>  &#125;<br>&#125;;<br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">object</span>.getNameFunc()());  <span class="hljs-comment">//? My Object</span><br><span class="hljs-comment">//这个()()是连续执行。相当于</span><br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.name;<br>  &#125;());<br>  <span class="hljs-comment">//这里的this是(),window</span><br><br><span class="hljs-comment">//代码片段二</span><br><span class="hljs-keyword">var</span> name2 = <span class="hljs-string">&quot;The Window&quot;</span>;<br><span class="hljs-keyword">var</span> object2 = &#123;<br>  <span class="hljs-attr">name2</span>: <span class="hljs-string">&quot;My Object&quot;</span>,<br>  <span class="hljs-attr">getNameFunc</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">var</span> that = <span class="hljs-built_in">this</span>;<span class="hljs-comment">//缓存this 保证this的指向不发生改变，即object2</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>      <span class="hljs-keyword">return</span> that.name2;<br>    &#125;;<br>  &#125;<br>&#125;;<br><span class="hljs-built_in">console</span>.log(object2.getNameFunc()()); <span class="hljs-comment">//My Object</span><br></code></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">习题<br><br>  function <span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">()</span></span>&#123;<br>  <span class="hljs-keyword">return</span> console.log(<span class="hljs-number">1</span>);<br>  <span class="hljs-comment">// return alert(1); 也是同样的效果</span><br>  &#125;<br>  console.log(<span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">()</span></span>);<br>  <span class="hljs-comment">//会输出两次，1，undefined。undefined是因为console.log 返回值是undefined</span><br>  <br>  -----------------------<br></code></pre></td></tr></table></figure><h1 id="5-内存溢出与内存泄露"><a href="#5-内存溢出与内存泄露" class="headerlink" title="5. 内存溢出与内存泄露"></a>5. 内存溢出与内存泄露</h1><h2 id="1-内存溢出"><a href="#1-内存溢出" class="headerlink" title="1). 内存溢出"></a>1). 内存溢出</h2><pre><code>一种程序运行出现的错误当程序运行需要的内存超过了剩余的内存时, 就出抛出内存溢出的错误</code></pre><h2 id="2-内存泄露"><a href="#2-内存泄露" class="headerlink" title="2). 内存泄露"></a>2). 内存泄露</h2><pre><code>占用的内存没有及时释放内存泄露积累多了就容易导致内存溢出常见的内存泄露:    意外的全局变量    没有及时清理的计时器或回调函数    闭包</code></pre><h1 id="函数高级补充知识："><a href="#函数高级补充知识：" class="headerlink" title="函数高级补充知识："></a>函数高级补充知识：</h1><h2 id="1-同步与异步"><a href="#1-同步与异步" class="headerlink" title="1.同步与异步"></a>1.同步与异步</h2><p>同步：没有回调。阻塞后续代码执行，一个一个执行。</p><p>异步：一定有回调函数。可能不立马执行，但是非阻塞，同时进行。例如：定时器。</p>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>JS高级01_类型、对象、函数、Git基本操作</title>
    <link href="/2021/08/29/JSadvance01/"/>
    <url>/2021/08/29/JSadvance01/</url>
    
    <content type="html"><![CDATA[<h1 id="1-数据类型的分类和判断"><a href="#1-数据类型的分类和判断" class="headerlink" title="1. 数据类型的分类和判断"></a>1. 数据类型的分类和判断</h1><h2 id="1-基本-值-类型"><a href="#1-基本-值-类型" class="headerlink" title="1). 基本(值)类型"></a>1). 基本(值)类型</h2><pre><code>Number ----- 任意数值 -------- typeofString ----- 任意字符串 ------ typeofBoolean ---- true/false ----- typeofundefined --- undefined ----- typeof/===null -------- null ---------- ===</code></pre><h2 id="2-对象-引用-类型"><a href="#2-对象-引用-类型" class="headerlink" title="2). 对象(引用)类型"></a>2). 对象(引用)类型</h2><pre><code>Object ----- typeof/instanceofArray ------ instanceofFunction ---- typeof/instanceof</code></pre><ol><li><h2 id="数据类型分类-2大类"><a href="#数据类型分类-2大类" class="headerlink" title="数据类型分类(2大类)"></a>数据类型分类(2大类)</h2></li></ol><ul><li><p>基本(值)类型（赋值的时候 值传递）</p><ul><li>Number: 任意数值</li><li>String: 任意文本</li><li>Boolean: true/false</li><li>undefined: undefined</li><li>null: null</li></ul></li><li><p>对象(引用)类型（赋值的时候 引用传递）</p><ul><li><p>Object: 任意对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123;<span class="hljs-attr">name</span> : <span class="hljs-string">&#x27;kobe&#x27;</span>&#125;; <br><span class="hljs-comment">//obj是一个变量在栈里面 指向一个 在堆里的对象的 地址。=后面是一个对象的值</span><br><br><span class="hljs-keyword">var</span> a = <span class="hljs-literal">null</span>;<br>a = <span class="hljs-number">123</span>;<br><span class="hljs-keyword">var</span> b = a;<span class="hljs-comment">//值传递 因为此处把a指向的，即一个值赋值给了b</span><br>b = <span class="hljs-number">234</span>;<span class="hljs-comment">//b就改值了，不关a的事</span><br><span class="hljs-built_in">console</span>. log(a); <span class="hljs-comment">// 123</span><br><br><br><span class="hljs-keyword">var</span> obj = &#123;<span class="hljs-attr">name</span>: <span class="hljs-string">&quot;kobe&quot;</span>&#125;; <br><span class="hljs-keyword">var</span> obj2 = obj;<span class="hljs-comment">//因为是地址的传递 指向堆里面的对象的地址了</span><br>obj2.name = <span class="hljs-string">&#x27;wade&#x27;</span>;<span class="hljs-comment">//然后此处直接指人家里，把人名改了</span><br><span class="hljs-built_in">console</span>.log(obj);<span class="hljs-comment">//wade</span><br><br><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">12</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>];<br><span class="hljs-keyword">var</span> arr2 = arr;<span class="hljs-comment">//引用传 arr2[1]= 234;</span><br><span class="hljs-built_in">console</span>.log(arr); <span class="hljs-comment">// [12，234，4]</span><br><br></code></pre></td></tr></table></figure></li><li><p>Array: 特别的对象类型(下标/内部数据有序)</p></li><li><p>Function: 特别的对象类型(可执行)</p></li></ul></li></ul><ol start="2"><li><h2 id="判断"><a href="#判断" class="headerlink" title="判断"></a>判断</h2></li></ol><ul><li><p>typeof:检测数据类型</p><ul><li>可以区别: string number booLean undefined object（null、array也是o） function</li><li>不能区别: null与对象, 数组与一般对象</li></ul></li><li><p>instanceof</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">A</span> instanceof <span class="hljs-selector-tag">B</span> 判断<span class="hljs-selector-tag">A</span>是否是<span class="hljs-selector-tag">B</span>的实例<br></code></pre></td></tr></table></figure><ul><li>专门用来判断对象数据的类型: Object, Array与Function</li></ul></li><li><p>===</p><ul><li>可以判断: undefined和null</li></ul></li></ul><ol><li><h2 id="undefined与null的区别"><a href="#undefined与null的区别" class="headerlink" title="undefined与null的区别?"></a>undefined与null的区别?</h2></li></ol><ul><li><p>undefined代表没有赋值，未定义</p></li><li><p>null代表赋值了, 只是值为null</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">console</span>.log(<span class="hljs-literal">null</span> == <span class="hljs-literal">undefined</span>); //<span class="hljs-literal">true</span> <span class="hljs-literal">undefined</span>来自于<span class="hljs-literal">null</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-literal">null</span>=== <span class="hljs-literal">undefined</span>); <span class="hljs-regexp">//</span> <span class="hljs-literal">false</span> 类型不一样<br></code></pre></td></tr></table></figure></li></ul><ol start="2"><li><h2 id="什么时候给变量赋值为null呢"><a href="#什么时候给变量赋值为null呢" class="headerlink" title="什么时候给变量赋值为null呢?"></a>什么时候给变量赋值为null呢?</h2></li></ol><ul><li>var a = null //a将指向一个对象, 但对象此时还没有确定</li><li>a = null //让a指向的对象成为垃圾对象</li></ul><ol start="3"><li>严格区别变量类型与数据类型?</li></ol><ul><li>js的变量本身是没有类型的, 变量的类型实际上是变量内存中数据的类型</li><li>变量类型:<ul><li>基本类型: 保存基本类型数据的变量</li><li>引用类型: 保存对象地址值的变量</li></ul></li><li>数据对象<ul><li>基本类型</li><li>对象类型</li></ul></li></ul><h1 id="2-数据-变量-内存的理解"><a href="#2-数据-变量-内存的理解" class="headerlink" title="2. 数据,变量, 内存的理解"></a>2. 数据,变量, 内存的理解</h1><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs stata">问题: JS引擎如何管理内存?<br>  1. 内存生命周期<br>    1). 分配需要的内存<br>    2). 使用分配到的内存<br>    3). 不需要时将其释放/归还<br>  2. 释放内存<br><span class="hljs-comment">    * 为执行函数分配的栈空间内存: 函数执行完自动释放</span><br><span class="hljs-comment">    * 存储对象的堆空间内存: 当内存没有引用指向时, 对象成为垃圾对象, 垃圾回收器后面就会回收释放此内存</span><br></code></pre></td></tr></table></figure><h2 id="1-什么是数据"><a href="#1-什么是数据" class="headerlink" title="1). 什么是数据?"></a>1). 什么是数据?</h2><pre><code>在内存中可读的, 可传递的保存了特定信息的&#39;东东&#39;一切皆数据, 函数也是数据在内存中的所有操作的目标: 数据</code></pre><h2 id="2-什么是变量"><a href="#2-什么是变量" class="headerlink" title="2). 什么是变量?"></a>2). 什么是变量?</h2><pre><code>在程序运行过程中它的值是允许改变的量一个变量对应一块小内存, 它的值保存在此内存中  </code></pre><h2 id="3-什么是内存"><a href="#3-什么是内存" class="headerlink" title="3). 什么是内存?"></a>3). 什么是内存?</h2><pre><code>内存条通电后产生的存储空间(临时的)一块内存包含2个方面的数据    内部存储的数据    地址值数据内存空间的分类    栈空间: 全局变量和局部变量    堆空间: 对象 </code></pre><h2 id="4-内存-数据-变量三者之间的关系"><a href="#4-内存-数据-变量三者之间的关系" class="headerlink" title="4). 内存,数据, 变量三者之间的关系"></a>4). 内存,数据, 变量三者之间的关系</h2><pre><code>内存是容器, 用来存储不同数据变量是内存的标识, 通过变量我们可以操作(读/写)内存中的数据  </code></pre><h1 id="3-对象的理解和使用"><a href="#3-对象的理解和使用" class="headerlink" title="3. 对象的理解和使用"></a>3. 对象的理解和使用</h1><h2 id="1-什么是对象"><a href="#1-什么是对象" class="headerlink" title="1). 什么是对象?"></a>1). 什么是对象?</h2><pre><code>多个数据(对象)的集合用来保存多个数据(对象)的容器</code></pre><h2 id="2-属性组成"><a href="#2-属性组成" class="headerlink" title="2). 属性组成:"></a>2). 属性组成:</h2><pre><code>属性名 : 字符串(标识)属性值 : 任意类型</code></pre><h2 id="3-属性的分类"><a href="#3-属性的分类" class="headerlink" title="3). 属性的分类:"></a>3). 属性的分类:</h2><pre><code>一般 : 属性值不是function  描述对象的状态方法 : 属性值为function的属性  描述对象的行为</code></pre><h2 id="4-特别的对象"><a href="#4-特别的对象" class="headerlink" title="4). 特别的对象"></a>4). 特别的对象</h2><pre><code>数组: 属性名是0,1,2,3之类的索引函数: 可以执行的</code></pre><h2 id="5-如何操作内部属性-方法"><a href="#5-如何操作内部属性-方法" class="headerlink" title="5). 如何操作内部属性(方法)"></a>5). 如何操作内部属性(方法)</h2><pre><code>对象.属性名 = 对象[&#39;属性名&#39;] = 属性名有特殊字符/属性名是一个变量</code></pre><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript">对象[变量] = 此时不加单引号，直接引用了变量的值<br><span class="hljs-keyword">var</span> xxx = <span class="hljs-string">&#x27;sex&#x27;</span>;<br><span class="hljs-keyword">var</span> obj = &#123;<br><span class="hljs-attr">str</span>: <span class="hljs-string">&#x27;abc&#x27;</span>,<br><span class="hljs-attr">num</span>: <span class="hljs-number">123</span>&#125;<br><span class="hljs-built_in">console</span>.log(obj.str);<br><span class="hljs-comment">//对象中的key一定是字符串</span><br>obj[xxx] =<span class="hljs-string">&#x27;男&#x27;</span>;<br><span class="hljs-built_in">console</span>.log(obj);<span class="hljs-comment">// &#123;sex:&#x27;男&#x27;&#125;！</span><br><br><span class="hljs-comment">//对象中的key一定是字符串 也就是a[]框里的就是key，自动调用了toString</span><br><span class="hljs-built_in">console</span>.log(num.toString());<br><span class="hljs-built_in">console</span>.log(obj1.toString());<span class="hljs-comment">//[object Object]</span><br><span class="hljs-keyword">var</span> a = &#123;&#125;<br><span class="hljs-keyword">var</span> obj1 = &#123;<span class="hljs-attr">n</span>: <span class="hljs-number">2</span>&#125;<br><span class="hljs-keyword">var</span> obj2 = &#123;<span class="hljs-attr">m</span>: <span class="hljs-number">3</span>&#125;<br>a[obj1] = <span class="hljs-number">4</span><br><span class="hljs-comment">//调用对象的时候用了toString 相当于两行a[&#x27;[object Object]&#x27;] = 4，5</span><br>a[obj2] = <span class="hljs-number">5</span><br><span class="hljs-built_in">console</span>.log(a[obj1]) <span class="hljs-comment">// 输出多少? 5</span><br></code></pre></td></tr></table></figure><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sqf">var obj =&#123;<span class="hljs-built_in">name</span>: <span class="hljs-string">&#x27;kobe&#x27;</span>&#125;<br>obj = &#123;<span class="hljs-built_in">name</span> : <span class="hljs-string">&#x27;kobe&#x27;</span>&#125; <span class="hljs-comment">//指向了一个新对象（栈里存的 堆内存的地址变了），只不过对象和刚才长得一样。</span><br>obj.<span class="hljs-built_in">name</span> = <span class="hljs-string">&#x27;wade&#x27;</span><span class="hljs-comment">//这个没指向新的，只是在上面的对象属性里修改了。</span><br></code></pre></td></tr></table></figure><h1 id="4-函数的理解和使用"><a href="#4-函数的理解和使用" class="headerlink" title="4. 函数的理解和使用"></a>4. 函数的理解和使用</h1><h2 id="1-什么是函数"><a href="#1-什么是函数" class="headerlink" title="1). 什么是函数?"></a>1). 什么是函数?</h2><pre><code>用来实现特定功能的, n条语句的封装体只有函数类型的数据是可以执行的, 其它的都不可以</code></pre><h2 id="2-为什么要用函数"><a href="#2-为什么要用函数" class="headerlink" title="2). 为什么要用函数?"></a>2). 为什么要用函数?</h2><pre><code>提高复用性便于阅读交流</code></pre><h2 id="3-函数也是对象"><a href="#3-函数也是对象" class="headerlink" title="3). 函数也是对象"></a>3). 函数也是对象</h2><pre><code>instanceof Object===true函数有属性: prototype函数有方法: call()/apply()可以添加新的属性/方法</code></pre><h2 id="4-函数的调用"><a href="#4-函数的调用" class="headerlink" title="4). 函数的调用"></a>4). 函数的调用</h2><p>1一般函数 : 直接调用 函数自调用 === window.函数调用</p><p>2构造函数 : 通过new调用 实例化对象。this指向的当前构造函数的实例对象。<br>构造函数名可以是小写。但是一般构造函数都是首字母大写</p><pre><code>function person(name,age) &#123;    this.name = name;    this.age = age;    this.eat = function () iconsole.log( &#39;吃东西&quot;);&#125;    &#125;        var person1 = new Person( &#39; kobe&#39; ,42);    var person2 = new Person( &quot; wade&#39; ,38);|</code></pre><p>​    3回调函数 : callback 事件的回调 定时器的回调</p><p>​    4call apply 强制改变this，我理解即指定对象调用函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> obj4 = &#123;<span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;kobe&#x27;</span>&#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fun3</span>(<span class="hljs-params"> </span>)</span>&#123;<br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>)<br>&#125;<br>fun3(); \\ <span class="hljs-built_in">this</span> ---&gt; <span class="hljs-built_in">window</span><br>fun3.call(obj4)<br>fun3.apply(obj4)<br></code></pre></td></tr></table></figure><h2 id="5-函数中的this"><a href="#5-函数中的this" class="headerlink" title="5). 函数中的this"></a>5). 函数中的this</h2><p>this是什么?<br>  1 一个关键字, 一个内置的引用变量</p><p>  2 this本身是一个内置的变量 此变量用于指向一个对象</p><p> 3 this有两种：</p><ul><li>全局this = window<br>两种的例子：</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">    function <span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">()</span></span> &#123;<br>    console.log(<span class="hljs-keyword">this</span>);<br>    <span class="hljs-keyword">this</span>.name = <span class="hljs-string">&#x27;kobe&#x27;</span><span class="hljs-comment">//可以不写死</span><br>&#125;<br><br>window.<span class="hljs-keyword">fun</span>();<span class="hljs-comment">//this 是 window</span><br></code></pre></td></tr></table></figure><ul><li> 局部（函数）this = 调用此函数的对象；</li></ul><p>   构造函数this = 当前构造函数的实例对象</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-keyword">new</span> fun();<span class="hljs-regexp">//</span>只要<span class="hljs-keyword">new</span>了，里面的<span class="hljs-built_in">this</span>就一定指的实例对象。这里的<span class="hljs-built_in">this</span>是实例对象，只不过不像下面一行有接收，所以这里<span class="hljs-built_in">this</span>显示为<span class="hljs-literal">undefined</span><br><br>//fun 其实等于var fun1 = <span class="hljs-keyword">new</span> fun();实例对象fun1 上面只不过没定义接收的变量<br></code></pre></td></tr></table></figure><p>​       另：new操作符语法: new function( );<br>​       1．创建空对象<br>​       2．执行函数<br>​       3．确认this 的指向 指向堆中的哪里: this —&gt;创建空对象<br>​       4．返回执行的结果<br>​       可以拿一个构造函数来理解</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span><span class="hljs-params">( name, age)</span> </span>&#123;<br>    <span class="hljs-comment">//1.创建空对象&#123;&#125;</span><br>    <span class="hljs-keyword">this</span>.name = name;<br>    <span class="hljs-keyword">this</span>.age = age;<br>&#125;<br><br><span class="hljs-keyword">var</span> person1 = <span class="hljs-keyword">new</span> Person( <span class="hljs-string">&#x27;KOBE&#x27;</span>， <span class="hljs-number">41</span>)<br><span class="hljs-comment">// &#123;name : &#x27;xxx&#x27; , age: xxx&#125;</span><br></code></pre></td></tr></table></figure><p> 4 特殊this：call apply 强制修改this</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">fun.call(obj);<span class="hljs-regexp">//</span>obj<br></code></pre></td></tr></table></figure><p>​    显式指定谁: obj.xxx()<br>​    通过call/apply指定谁调用: xxx.call(obj)<br>​    不指定谁调用: xxx()  : window<br>​    回调函数: 看背后是通过谁来调用的: window/其它</p><h2 id="6-匿名函数自调用（立即调用）-IIEF"><a href="#6-匿名函数自调用（立即调用）-IIEF" class="headerlink" title="6). 匿名函数自调用（立即调用）:IIEF"></a>6). 匿名函数自调用（立即调用）:IIEF</h2><p>特点：</p><pre><code>特点:1．只执行一次2．什么时候执行:代码执行到函数位置立即执行3．内部的数据是私有的-----------------//内部的数据是私有的(function () &#123;var num = 123;&#125;)()console.Log(num);//报错，num未定义。因为看不到自调用函数里面数据了-----------------(function()&#123;  //实现代码&#125;)()专业术语为: IIFE (Immediately Invoked Function Expression) 立即调用函数表达式                          </code></pre><h2 id="7-回调函数的理解△"><a href="#7-回调函数的理解△" class="headerlink" title="7). 回调函数的理解△"></a>7). 回调函数的理解△</h2><pre><code>1什么函数才是回调函数?    你定义的    你没有调用    但它最终执行了(在一定条件下 或某个时刻) 回头调用!!2常用的回调函数    dom事件回调函数(如按钮)    定时器回调函数    ajax请求回调函数(后面讲解)    生命周期回调函数(后面讲解)</code></pre><h1 id="git管理项目"><a href="#git管理项目" class="headerlink" title="git管理项目"></a>git管理项目</h1><h2 id="1-创建本地仓库"><a href="#1-创建本地仓库" class="headerlink" title="1). 创建本地仓库"></a>1). 创建本地仓库</h2><pre><code>创建.gitignore配置文件git initgit add *git commit -m &quot;xxx&quot;</code></pre><h2 id="2-创建github远程仓库"><a href="#2-创建github远程仓库" class="headerlink" title="2). 创建github远程仓库"></a>2). 创建github远程仓库</h2><pre><code>New Repository指定名称创建</code></pre><h2 id="3-将本地仓库推送到远程仓库"><a href="#3-将本地仓库推送到远程仓库" class="headerlink" title="3). 将本地仓库推送到远程仓库"></a>3). 将本地仓库推送到远程仓库</h2><pre><code>git remote add origin https://github.com/zxfjd3g/170612_JSAdvance.git 关联远程仓库git push origin master</code></pre><h2 id="4-push本地的更新"><a href="#4-push本地的更新" class="headerlink" title="4). push本地的更新"></a>4). push本地的更新</h2><pre><code>git add *git commit -m &quot;xxx&quot;git push origin master</code></pre><h2 id="5-克隆github上的项目"><a href="#5-克隆github上的项目" class="headerlink" title="5). 克隆github上的项目:"></a>5). 克隆github上的项目:</h2><pre><code>git clone https://github.com/zxfjd3g/170612_JSAdvance.git</code></pre><h2 id="6-pull远程的更新"><a href="#6-pull远程的更新" class="headerlink" title="6). pull远程的更新"></a>6). pull远程的更新</h2><pre><code>git pull origin master</code></pre><h2 id="7-撤消本地修改"><a href="#7-撤消本地修改" class="headerlink" title="7). 撤消本地修改"></a>7). 撤消本地修改</h2><pre><code>git status  查看变化git checkout -- xxx文件  撤消指定文件的修改</code></pre>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java各类的常用方法总结</title>
    <link href="/2021/08/29/Java-function/"/>
    <url>/2021/08/29/Java-function/</url>
    
    <content type="html"><![CDATA[<h1 id="1-Collection接口（List、Set）"><a href="#1-Collection接口（List、Set）" class="headerlink" title="1.Collection接口（List、Set）"></a>1.Collection接口（List、Set）</h1><p><a href="https://www.matools.com/api/java8">https://www.matools.com/api/java8</a></p><p><img src="/2021/08/29/Java-function/Collection.png" alt="img"></p><p>常用类：</p><p>ArrayList ，HashSet ， LinkedList ， PriorityQueue， Stack ， TreeSet ， Vector</p><table><thead><tr><th align="left">修饰符和类型</th><th align="left">方法及描述</th></tr></thead><tbody><tr><td align="left"><code>boolean</code></td><td align="left"><code>add(E e)</code>确保此集合包含指定的元素（可选操作）。</td></tr><tr><td align="left"><code>boolean</code></td><td align="left"><code>addAll(Collection&lt;? extends E&gt; c)</code>将指定集合中的所有元素添加到此集合（可选操作）。</td></tr><tr><td align="left"><code>void</code></td><td align="left"><code>clear()</code>从此集合中删除所有元素（可选操作）。</td></tr><tr><td align="left"><code>boolean</code></td><td align="left"><code>contains(Object o)</code>如果此集合包含指定的元素，则返回 <code>true</code> 。</td></tr><tr><td align="left"><code>boolean</code></td><td align="left"><code>containsAll(Collection&lt;?&gt; c)</code>如果此集合包含指定 <code>集合</code>中的所有元素，则返回true。</td></tr><tr><td align="left"><code>boolean</code></td><td align="left"><code>equals(Object o)</code>将指定的对象与此集合进行比较以获得相等性。</td></tr><tr><td align="left"><code>boolean</code></td><td align="left"><code>isEmpty()</code>如果此集合不包含元素，则返回 <code>true</code> 。</td></tr><tr><td align="left"><code>Iterator&lt;E&gt;</code></td><td align="left"><code>iterator()</code>返回此集合中的元素的迭代器。</td></tr><tr><td align="left"><code>boolean</code></td><td align="left"><code>remove(Object o)</code>从该集合中删除指定元素的单个实例（如果存在）（可选操作）。</td></tr><tr><td align="left"><code>boolean</code></td><td align="left"><code>removeAll(Collection&lt;?&gt; c)</code>删除指定集合中包含的所有此集合的元素（可选操作）。</td></tr><tr><td align="left"><code>int</code></td><td align="left"><code>size()</code>返回此集合中的元素数。</td></tr><tr><td align="left"><code>Object[]</code></td><td align="left"><code>toArray()</code>返回一个包含此集合中所有元素的数组。</td></tr></tbody></table><h2 id="1-List"><a href="#1-List" class="headerlink" title="1.List"></a>1.List</h2><table><thead><tr><th><code>void</code></th><th><code>add(int index, E element)</code>将指定的元素插入此列表中的指定位置（可选操作）。</th></tr></thead><tbody><tr><td><code>E</code></td><td><code>get(int index)</code>返回此列表中指定位置的元素。</td></tr><tr><td><code>int</code></td><td><code>indexOf(Object o)</code>返回此列表中指定元素的第一次出现的索引，如果此列表不包含元素，则返回-1。</td></tr><tr><td><code>E</code></td><td><code>set(int index, E element)</code>用指定的元素（可选操作）替换此列表中指定位置的元素。</td></tr><tr><td><code>default void</code></td><td><code>sort(Comparator&lt;? super E&gt; c)</code>使用随附的 <code>Comparator</code>排序此列表来比较元素。</td></tr><tr><td><code>List&lt;E&gt;</code></td><td><code>subList(int fromIndex, int toIndex)</code>返回此列表中指定的 <code>fromIndex</code> （含）和 <code>toIndex</code>之间的视图。</td></tr></tbody></table><h3 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h3><table><thead><tr><th><code>int</code></th><th><code>lastIndexOf(Object o)</code>返回此列表中指定元素的最后一次出现的索引，如果此列表不包含元素，则返回-1。</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><h3 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h3><table><thead><tr><th><code>void</code></th><th><code>addFirst(E e)</code>在该列表开头插入指定的元素。</th></tr></thead><tbody><tr><td><code>void</code></td><td><code>addLast(E e)</code>将指定的元素追加到此列表的末尾。</td></tr><tr><td><code>E</code></td><td><code>getFirst()</code>返回此列表中的第一个元素。</td></tr><tr><td><code>E</code></td><td><code>getLast()</code>返回此列表中的最后一个元素。</td></tr><tr><td><code>int</code></td><td><code>lastIndexOf(Object o)</code>返回此列表中指定元素的最后一次出现的索引，如果此列表不包含元素，则返回-1。</td></tr><tr><td><code>boolean</code></td><td><code>offer(E e)</code>将指定的元素添加为此列表的尾部（最后一个元素）。</td></tr><tr><td><code>boolean</code></td><td><code>offerFirst(E e)</code>在此列表的前面插入指定的元素。</td></tr><tr><td><code>boolean</code></td><td><code>offerLast(E e)</code>在该列表的末尾插入指定的元素。</td></tr><tr><td><code>E</code></td><td><code>peek()</code>检索但不删除此列表的头（第一个元素）。<br>//另有peekFirst()  peekLast()</td></tr><tr><td><code>E</code></td><td><code>poll()</code>检索并删除此列表的头（第一个元素）。<br>//pollFirst() pollLast()</td></tr><tr><td><code>E</code></td><td><code>pop()</code>从此列表表示的堆栈中弹出一个元素。</td></tr><tr><td><code>void</code></td><td><code>push(E e)</code>将元素推送到由此列表表示的堆栈上。</td></tr></tbody></table><h3 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h3><table><thead><tr><th align="left">Modifier and Type</th><th align="left">Method and Description</th></tr></thead><tbody><tr><td align="left"><code>boolean</code></td><td align="left"><code>empty()</code>测试此堆栈是否为空。</td></tr><tr><td align="left"><code>E</code></td><td align="left"><code>peek()</code>查看此堆栈顶部的对象，而不从堆栈中删除它。</td></tr><tr><td align="left"><code>E</code></td><td align="left"><code>pop()</code>删除此堆栈顶部的对象，并将该对象作为此函数的值返回。</td></tr><tr><td align="left"><code>E</code></td><td align="left"><code>push(E item)</code>将项目推送到此堆栈的顶部。</td></tr><tr><td align="left"><code>int</code></td><td align="left"><code>search(Object o)</code>返回一个对象在此堆栈上的基于1的位置。</td></tr></tbody></table><h2 id="2-Set-唯一值，无键-没什么特别的方法"><a href="#2-Set-唯一值，无键-没什么特别的方法" class="headerlink" title="2.Set 唯一值，无键(没什么特别的方法)"></a>2.Set 唯一值，无键(没什么特别的方法)</h2><h3 id="HashSet-没什么特别的方法，它所有的方法："><a href="#HashSet-没什么特别的方法，它所有的方法：" class="headerlink" title="HashSet 没什么特别的方法，它所有的方法："></a>HashSet 没什么特别的方法，它所有的方法：</h3><table><thead><tr><th align="left">Modifier and Type</th><th align="left">Method and Description</th></tr></thead><tbody><tr><td align="left"><code>boolean</code></td><td align="left"><code>add(E e)</code>将指定的元素添加到此集合（如果尚未存在）。</td></tr><tr><td align="left"><code>void</code></td><td align="left"><code>clear()</code>从此集合中删除所有元素。</td></tr><tr><td align="left"><code>Object</code></td><td align="left"><code>clone()</code>返回此 <code>HashSet</code>实例的浅层副本：元素本身不被克隆。</td></tr><tr><td align="left"><code>boolean</code></td><td align="left"><code>contains(Object o)</code>如果此集合包含指定的元素，则返回 <code>true</code> 。</td></tr><tr><td align="left"><code>boolean</code></td><td align="left"><code>isEmpty()</code>如果此集合不包含元素，则返回 <code>true</code> 。</td></tr><tr><td align="left"><code>Iterator&lt;E&gt;</code></td><td align="left"><code>iterator()</code>返回此集合中元素的迭代器。</td></tr><tr><td align="left"><code>boolean</code></td><td align="left"><code>remove(Object o)</code>如果存在，则从该集合中删除指定的元素。</td></tr><tr><td align="left"><code>int</code></td><td align="left"><code>size()</code>返回此集合中的元素数（其基数）。</td></tr></tbody></table><h3 id="TreeSet特别的方法（元素唯一，且按照顺序排序）"><a href="#TreeSet特别的方法（元素唯一，且按照顺序排序）" class="headerlink" title="TreeSet特别的方法（元素唯一，且按照顺序排序）"></a>TreeSet特别的方法（元素唯一，且按照顺序排序）</h3><table><thead><tr><th><code>E</code></th><th><code>first()</code>返回此集合中当前的第一个（最低）元素。</th></tr></thead><tbody><tr><td><code>E</code></td><td><code>floor(E e)</code>返回此集合中最大的元素小于或等于给定元素，如果没有这样的元素，则返回 <code>null</code> 。</td></tr><tr><td><code>E</code></td><td><code>last()</code>返回此集合中当前的最后（最高）元素。</td></tr><tr><td><code>E</code></td><td><code>lower(E e)</code>返回这个集合中最大的元素严格小于给定的元素，如果没有这样的元素，则返回 <code>null</code> 。</td></tr><tr><td><code>E</code></td><td><code>pollFirst()</code>检索并删除第一个（最低）元素，或返回 <code>null</code>如果该集合为空。</td></tr><tr><td><code>E</code></td><td><code>pollLast()</code>检索并删除最后一个（最高）元素，如果此集合为空，则返回 <code>null</code> 。</td></tr><tr><td><code>NavigableSet&lt;E&gt;</code></td><td><code>subSet(E fromElement, boolean fromInclusive, E toElement, boolean toInclusive)</code>返回该集合的部分的视图，其元素的范围从 <code>fromElement</code>到 <code>toElement</code> 。</td></tr><tr><td><code>SortedSet&lt;E&gt;</code></td><td><code>subSet(E fromElement, E toElement)</code>返回此集合的部分的视图，其元素的范围从 <code>fromElement</code> （含）到 <code>toElement</code> ，排他。</td></tr><tr><td><code>SortedSet&lt;E&gt;</code></td><td><code>tailSet(E fromElement)</code>返回此组件的元素大于或等于 <code>fromElement</code>的部分的视图。</td></tr><tr><td><code>NavigableSet&lt;E&gt;</code></td><td><code>tailSet(E fromElement, boolean inclusive)</code>返回此集合的部分的视图，其元素大于（或等于，如果 <code>inclusive</code>为真） <code>fromElement</code> 。</td></tr></tbody></table><h1 id="2-Queue"><a href="#2-Queue" class="headerlink" title="2.Queue"></a>2.Queue</h1><table><thead><tr><th><code>boolean</code></th><th><code>add(E e)</code>将指定的元素插入到此队列中，如果可以立即执行此操作，而不会违反容量限制， <code>true</code>在成功后返回 <code>IllegalStateException</code>如果当前没有可用空间，则抛出IllegalStateException。</th></tr></thead><tbody><tr><td><code>E</code></td><td><code>element()</code>检索，但不删除，这个队列的头。</td></tr><tr><td><code>boolean</code></td><td><code>offer(E e)</code>如果在不违反容量限制的情况下立即执行，则将指定的元素插入到此队列中。</td></tr><tr><td><code>E</code></td><td><code>peek()</code>检索但不删除此队列的头，如果此队列为空，则返回 <code>null</code> 。</td></tr><tr><td><code>E</code></td><td><code>poll()</code>检索并删除此队列的头，如果此队列为空，则返回 <code>null</code> 。</td></tr><tr><td><code>E</code></td><td><code>remove()</code>检索并删除此队列的头。</td></tr></tbody></table><h2 id="1-PriorityQueue"><a href="#1-PriorityQueue" class="headerlink" title="1.PriorityQueue"></a>1.PriorityQueue</h2><table><thead><tr><th><code>boolean</code></th><th><code>add(E e)</code>将指定的元素插入到此优先级队列中。</th></tr></thead><tbody><tr><td><code>void</code></td><td><code>clear()</code>从此优先级队列中删除所有元素。</td></tr><tr><td><code>Comparator&lt;? super E&gt;</code></td><td><code>comparator()</code>返回用于为了在这个队列中的元素，或比较<code>null</code>如果此队列根据所述排序<a href="https://www.matools.com/file/manual/jdk_api_1.8_google/java/lang/Comparable.html">natural ordering</a>的元素。</td></tr><tr><td><code>boolean</code></td><td><code>contains(Object o)</code>如果此队列包含指定的元素，则返回 <code>true</code> 。</td></tr><tr><td><code>Iterator&lt;E&gt;</code></td><td><code>iterator()</code>返回此队列中的元素的迭代器。</td></tr><tr><td><code>boolean</code></td><td><code>offer(E e)</code>将指定的元素插入到此优先级队列中。</td></tr><tr><td><code>int</code></td><td><code>size()</code>返回此集合中的元素数。</td></tr><tr><td><code>Object[]</code></td><td><code>toArray()</code>返回一个包含此队列中所有元素的数组。</td></tr><tr><td><code>&lt;T&gt; T[]</code></td><td><code>toArray(T[] a)</code>返回一个包含此队列中所有元素的数组; 返回的数组的运行时类型是指定数组的运行时类型。</td></tr></tbody></table><h2 id="2-Deque"><a href="#2-Deque" class="headerlink" title="2.Deque"></a>2.Deque</h2><table><thead><tr><th>addLast(E e) / offerLast(E e)</th><th>添加元素到队尾</th></tr></thead><tbody><tr><td>E removeFirst() / E pollFirst()</td><td>取队首元素并删除</td></tr><tr><td>E getFirst() / E peekFirst()</td><td>取队首元素但不删除</td></tr><tr><td>addFirst(E e) / offerFirst(E e)</td><td>添加元素到队首</td></tr><tr><td>E removeLast() / E pollLast()</td><td>取队尾元素并删除</td></tr><tr><td>E getLast() / E peekLast()</td><td>取队尾元素但不删除</td></tr></tbody></table><h1 id="3-Map接口（HashMap、TreeMap）"><a href="#3-Map接口（HashMap、TreeMap）" class="headerlink" title="3.Map接口（HashMap、TreeMap）"></a>3.Map接口（HashMap、TreeMap）</h1><p><img src="/2021/08/29/Java-function/Map.png" alt="img"></p><table><thead><tr><th align="left">Modifier and Type</th><th align="left">Method and Description</th></tr></thead><tbody><tr><td align="left"><code>void</code></td><td align="left"><code>clear()</code>从该地图中删除所有的映射（可选操作）。</td></tr><tr><td align="left"><code>boolean</code></td><td align="left"><code>containsKey(Object key)</code>如果此映射包含指定键的映射，则返回 <code>true</code> 。</td></tr><tr><td align="left"><code>boolean</code></td><td align="left"><code>containsValue(Object value)</code>如果此地图将一个或多个键映射到指定的值，则返回 <code>true</code> 。</td></tr><tr><td align="left"><code>boolean</code></td><td align="left"><code>equals(Object o)</code>将指定的对象与此映射进行比较以获得相等性。</td></tr><tr><td align="left"><code>default void</code></td><td align="left"><code>forEach(BiConsumer&lt;? super K,? super V&gt; action)</code>对此映射中的每个条目执行给定的操作，直到所有条目都被处理或操作引发异常。</td></tr><tr><td align="left"><code>V</code></td><td align="left"><code>get(Object key)</code>返回到指定键所映射的值，或 <code>null</code>如果此映射包含该键的映射。</td></tr><tr><td align="left"><code>default V</code></td><td align="left"><code>getOrDefault(Object key, V defaultValue)</code>返回到指定键所映射的值，或 <code>defaultValue</code>如果此映射包含该键的映射。</td></tr><tr><td align="left"><code>boolean</code></td><td align="left"><code>isEmpty()</code>如果此地图不包含键值映射，则返回 <code>true</code> 。</td></tr><tr><td align="left"><code>V</code></td><td align="left"><code>put(K key, V value)</code>将指定的值与该映射中的指定键相关联（可选操作）。</td></tr><tr><td align="left"><code>void</code></td><td align="left"><code>putAll(Map&lt;? extends K,? extends V&gt; m)</code>将指定地图的所有映射复制到此映射（可选操作）。</td></tr><tr><td align="left"><code>default V</code></td><td align="left"><code>putIfAbsent(K key, V value)</code>如果指定的键尚未与某个值相关联（或映射到 <code>null</code> ）将其与给定值相关联并返回 <code>null</code> ，否则返回当前值。</td></tr><tr><td align="left"><code>V</code></td><td align="left"><code>remove(Object key)</code>如果存在（从可选的操作），从该地图中删除一个键的映射。</td></tr><tr><td align="left"><code>default V</code></td><td align="left"><code>replace(K key, V value)</code>只有当目标映射到某个值时，才能替换指定键的条目。</td></tr><tr><td align="left"><code>default boolean</code></td><td align="left"><code>replace(K key, V oldValue, V newValue)</code>仅当当前映射到指定的值时，才能替换指定键的条目。</td></tr><tr><td align="left"><code>default void</code></td><td align="left"><code>replaceAll(BiFunction&lt;? super K,? super V,? extends V&gt; function)</code>将每个条目的值替换为对该条目调用给定函数的结果，直到所有条目都被处理或该函数抛出异常。</td></tr><tr><td align="left"><code>int</code></td><td align="left"><code>size()</code>返回此地图中键值映射的数量。</td></tr></tbody></table><h2 id="HashMap-没什么特别的方法"><a href="#HashMap-没什么特别的方法" class="headerlink" title="HashMap 没什么特别的方法"></a>HashMap 没什么特别的方法</h2><h2 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h2><table><thead><tr><th align="left">Modifier and Type</th><th align="left">Method and Description</th></tr></thead><tbody><tr><td align="left"><code>Map.Entry&lt;K,V&gt;</code></td><td align="left"><code>ceilingEntry(K key)</code>返回与大于或等于给定键的最小键相关联的键值映射，如果没有此键，则 <code>null</code> 。</td></tr><tr><td align="left"><code>K</code></td><td align="left"><code>ceilingKey(K key)</code>返回大于或等于给定键的 <code>null</code>键，如果没有此键，则返回 <code>null</code> 。</td></tr><tr><td align="left"><code>Comparator&lt;? super K&gt;</code></td><td align="left"><code>comparator()</code>返回用于订购此地图中的键的比较器，或<code>null</code>如果此地图使用其键的<a href="https://www.matools.com/file/manual/jdk_api_1.8_google/java/lang/Comparable.html">natural ordering</a> 。</td></tr><tr><td align="left"><code>NavigableSet&lt;K&gt;</code></td><td align="left"><code>descendingKeySet()</code>返回此地图中包含的键的相反顺序<a href="https://www.matools.com/file/manual/jdk_api_1.8_google/java/util/NavigableSet.html"><code>NavigableSet</code></a> 。</td></tr><tr><td align="left"><code>NavigableMap&lt;K,V&gt;</code></td><td align="left"><code>descendingMap()</code>返回此映射中包含的映射的反向排序视图。</td></tr><tr><td align="left"><code>Map.Entry&lt;K,V&gt;</code></td><td align="left"><code>firstEntry()</code>返回与该地图中的最小键相关联的键值映射，如果地图为空，则返回 <code>null</code> 。</td></tr><tr><td align="left"><code>K</code></td><td align="left"><code>firstKey()</code>返回此地图中当前的第一个（最低）键。</td></tr><tr><td align="left"><code>Map.Entry&lt;K,V&gt;</code></td><td align="left"><code>floorEntry(K key)</code>返回与小于或等于给定键的最大键相关联的键值映射，如果没有此键，则 <code>null</code> 。</td></tr><tr><td align="left"><code>K</code></td><td align="left"><code>floorKey(K key)</code>返回小于或等于给定键的最大键，如果没有这样的键，则返回 <code>null</code> 。</td></tr><tr><td align="left"><code>void</code></td><td align="left"><code>forEach(BiConsumer&lt;? super K,? super V&gt; action)</code>对此映射中的每个条目执行给定的操作，直到所有条目都被处理或操作引发异常。</td></tr><tr><td align="left"><code>V</code></td><td align="left"><code>get(Object key)</code>返回到指定键所映射的值，或 <code>null</code>如果此映射包含该键的映射。</td></tr><tr><td align="left"><code>Map.Entry&lt;K,V&gt;</code></td><td align="left"><code>higherEntry(K key)</code>返回与最小密钥相关联的密钥值映射严格大于给定密钥，如果没有这样的密钥则 <code>null</code> 。</td></tr><tr><td align="left"><code>K</code></td><td align="left"><code>higherKey(K key)</code>返回严格大于给定键的最小键，如果没有这样的键，则返回 <code>null</code> 。</td></tr><tr><td align="left"><code>Map.Entry&lt;K,V&gt;</code></td><td align="left"><code>lastEntry()</code>返回与该地图中最大关键字关联的键值映射，如果地图为空，则返回 <code>null</code> 。</td></tr><tr><td align="left"><code>K</code></td><td align="left"><code>lastKey()</code>返回当前在此地图中的最后（最高）键。</td></tr><tr><td align="left"><code>Map.Entry&lt;K,V&gt;</code></td><td align="left"><code>lowerEntry(K key)</code>返回与最大密钥相关联的密钥值映射严格小于给定密钥，如果没有这样的密钥，则 <code>null</code> 。</td></tr><tr><td align="left"><code>K</code></td><td align="left"><code>lowerKey(K key)</code>返回严格小于给定键的最大键，如果没有这样的键，则返回 <code>null</code> 。</td></tr><tr><td align="left"><code>Map.Entry&lt;K,V&gt;</code></td><td align="left"><code>pollFirstEntry()</code>删除并返回与该地图中的最小键相关联的键值映射，如果地图为空，则返回 <code>null</code> 。</td></tr><tr><td align="left"><code>Map.Entry&lt;K,V&gt;</code></td><td align="left"><code>pollLastEntry()</code>删除并返回与该地图中最大密钥相关联的键值映射，如果地图为空，则返回 <code>null</code> 。</td></tr><tr><td align="left"><code>V</code></td><td align="left"><code>put(K key, V value)</code>将指定的值与此映射中的指定键相关联。</td></tr><tr><td align="left"><code>void</code></td><td align="left"><code>putAll(Map&lt;? extends K,? extends V&gt; map)</code>将指定地图的所有映射复制到此地图。</td></tr><tr><td align="left"><code>V</code></td><td align="left"><code>remove(Object key)</code>从此TreeMap中删除此键的映射（如果存在）。</td></tr><tr><td align="left"><code>V</code></td><td align="left"><code>replace(K key, V value)</code>只有当目标映射到某个值时，才能替换指定键的条目。</td></tr><tr><td align="left"><code>boolean</code></td><td align="left"><code>replace(K key, V oldValue, V newValue)</code>仅当当前映射到指定的值时，才能替换指定键的条目。</td></tr><tr><td align="left"><code>void</code></td><td align="left"><code>replaceAll(BiFunction&lt;? super K,? super V,? extends V&gt; function)</code>将每个条目的值替换为对该条目调用给定函数的结果，直到所有条目都被处理或该函数抛出异常。</td></tr><tr><td align="left"><code>int</code></td><td align="left"><code>size()</code>返回此地图中键值映射的数量。</td></tr><tr><td align="left"><code>NavigableMap&lt;K,V&gt;</code></td><td align="left"><code>subMap(K fromKey, boolean fromInclusive, K toKey, boolean toInclusive)</code>返回此地图部分的视图，其关键范围为 <code>fromKey</code>至 <code>toKey</code> 。</td></tr><tr><td align="left"><code>SortedMap&lt;K,V&gt;</code></td><td align="left"><code>subMap(K fromKey, K toKey)</code>返回此地图部分的视图，其关键字范围从 <code>fromKey</code> （含）到 <code>toKey</code> ，独占。</td></tr><tr><td align="left"><code>SortedMap&lt;K,V&gt;</code></td><td align="left"><code>tailMap(K fromKey)</code>返回此地图部分的视图，其键大于等于 <code>fromKey</code> 。</td></tr><tr><td align="left"><code>NavigableMap&lt;K,V&gt;</code></td><td align="left"><code>tailMap(K fromKey, boolean inclusive)</code>返回此地图部分的视图，其键大于（或等于，如果 <code>inclusive</code>为真） <code>fromKey</code> 。</td></tr></tbody></table><h1 id="4-Object"><a href="#4-Object" class="headerlink" title="4.Object"></a>4.Object</h1><table><thead><tr><th><code>static String</code></th><th><code>toString(xx)</code>返回指定数组的内容的字符串表示形式。</th></tr></thead><tbody><tr><td>以下都有</td><td>这个方法</td></tr></tbody></table><h2 id="Number"><a href="#Number" class="headerlink" title="Number"></a>Number</h2><h3 id="Integer（另有Float、Double…不全写了）"><a href="#Integer（另有Float、Double…不全写了）" class="headerlink" title="Integer（另有Float、Double…不全写了）"></a>Integer（另有Float、Double…不全写了）</h3><table><thead><tr><th><code>static int</code></th><th><code>compare(int x, int y)</code>比较两个 <code>int</code>数字值。</th></tr></thead><tbody><tr><td><code>int</code></td><td><code>compareTo(Integer anotherInteger)</code>数字比较两个 <code>Integer</code>对象。</td></tr><tr><td><code>boolean</code></td><td><code>equals(Object obj)</code>将此对象与指定的对象进行比较。</td></tr><tr><td><code>static int</code></td><td><code>max(int a, int b)</code>返回两个 <code>int</code>的较大值，就像调用 <a href="https://www.matools.com/file/manual/jdk_api_1.8_google/java/lang/Math.html#max-int-int-"><code>Math.max</code>一样</a> 。</td></tr><tr><td><code>static int</code></td><td><code>min(int a, int b)</code>返回两个 <code>int</code>的较小值，就像调用 <a href="https://www.matools.com/file/manual/jdk_api_1.8_google/java/lang/Math.html#min-int-int-"><code>Math.min</code>一样</a> 。</td></tr><tr><td><code>static int</code></td><td><code>parseInt(String s)</code>将字符串参数解析为带符号的十进制整数。</td></tr><tr><td><code>static Integer</code></td><td><code>valueOf(int i)</code>返回一个 <code>Integer</code>指定的 <code>int</code>值的 <code>Integer</code>实例。</td></tr><tr><td><code>static Integer</code></td><td><code>valueOf(String s)</code>返回一个 <code>Integer</code>对象，保存指定的值为 <code>String</code> 。</td></tr></tbody></table><h2 id="Character"><a href="#Character" class="headerlink" title="Character"></a>Character</h2><table><thead><tr><th><code>static char</code></th><th><code>toUpperCase(char ch)</code>将字符参数转换为大写。</th></tr></thead><tbody><tr><td><code>static Character</code></td><td><code>valueOf(char c)</code>返回一个 <code>表示</code>指定的 <code>char</code>值的 <code>Character</code>实例。</td></tr><tr><td><code>int</code></td><td><code>compareTo(Character anotherCharacter)</code>数字比较两个 <code>Character</code>对象。</td></tr><tr><td><code>static int</code></td><td><code>compare(char x, char y)</code>数值比较两个 <code>char</code>数值。</td></tr><tr><td><code>boolean</code></td><td><code>equals(Object obj)</code>将此对象与指定对象进行比较。</td></tr></tbody></table><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><table><thead><tr><th><code>char</code></th><th><code>charAt(int index)</code>返回 <code>char</code>指定索引处的值。</th></tr></thead><tbody><tr><td><code>int</code></td><td><code>compareTo(String anotherString)</code>按字典顺序比较两个字符串。</td></tr><tr><td><code>String</code></td><td><code>concat(String str)</code>将指定的字符串连接到该字符串的末尾。</td></tr><tr><td><code>boolean</code></td><td><code>contains(CharSequence s)</code>当且仅当此字符串包含指定的char值序列时才返回true。（可以检测是否包含字符串）</td></tr><tr><td><code>boolean</code></td><td><code>equals(Object anObject)</code>将此字符串与指定对象进行比较。</td></tr><tr><td><code>int</code></td><td><code>indexOf(int ch)</code>返回指定字符第一次出现的字符串内的索引。</td></tr><tr><td><code>int</code></td><td><code>indexOf(int ch, int fromIndex)</code>返回指定字符第一次出现的字符串内的索引，以指定的索引开始搜索。</td></tr><tr><td><code>boolean</code></td><td><code>isEmpty()</code>返回 <code>true</code>如果，且仅当 <a href="https://www.matools.com/file/manual/jdk_api_1.8_google/java/lang/String.html#length--"><code>length()</code></a>为 <code>0</code> 。</td></tr><tr><td><code>int</code></td><td><code>lastIndexOf(int ch)</code>返回指定字符的最后一次出现的字符串中的索引。</td></tr><tr><td><code>String</code></td><td><code>replace(char oldChar, char newChar)</code>返回从替换所有出现的导致一个字符串 <code>oldChar</code>在此字符串 <code>newChar</code> 。</td></tr><tr><td><code>String</code></td><td><code>replaceAll(String regex, String replacement)</code>用给定的替换替换与给定的 <a href="https://www.matools.com/file/manual/jdk_api_1.8_google/java/util/regex/Pattern.html#sum">regular expression</a>匹配的此字符串的每个子字符串。</td></tr><tr><td><code>String[]</code></td><td><code>split(String regex)</code>将此字符串分割为给定的 <a href="https://www.matools.com/file/manual/jdk_api_1.8_google/java/util/regex/Pattern.html#sum">regular expression的</a>匹配。</td></tr><tr><td><code>char[]</code></td><td><code>toCharArray()</code>将此字符串转换为新的字符数组。</td></tr><tr><td><code>String</code></td><td><code>toLowerCase()</code>将所有在此字符 <code>String</code>使用默认语言环境的规则，以小写。/<strong><a href="https://www.matools.com/file/manual/jdk_api_1.8_google/java/lang/String.html#toUpperCase--">toUpperCase</a></strong>()大写</td></tr><tr><td><code>String</code></td><td><strong><a href="https://www.matools.com/file/manual/jdk_api_1.8_google/java/lang/String.html#valueOf-boolean-">valueOf</a></strong>(boolean b)(char c)….  返回 <code>xx</code>参数的字符串 <code>xx</code>形式。</td></tr><tr><td><code>String</code></td><td><code>substring(int beginIndex, int endIndex)</code>返回一个字符串，该字符串是此字符串的子字符串。endIndex不包括。</td></tr><tr><td><code>CharSequence</code></td><td><code>subSequence(int beginIndex, int endIndex)</code>返回一个字符序列，该序列是该序列的子序列。</td></tr></tbody></table><h2 id="StringBuilder"><a href="#StringBuilder" class="headerlink" title="StringBuilder"></a>StringBuilder</h2><p>比 StringBuffer更常用，后者在安全线程里更常用</p><table><thead><tr><th><code>StringBuilder</code></th><th><code>append()</code>将 各种类型的参数 加到序列中。</th></tr></thead><tbody><tr><td><code>char</code></td><td><code>charAt(int index)</code>返回 <code>char</code>在指定索引在这个序列值。</td></tr><tr><td><code>StringBuilder</code></td><td><code>delete(int start, int end)</code>删除此序列的子字符串中的字符。</td></tr><tr><td><code>StringBuilder</code></td><td><code>deleteCharAt(int index)</code>删除 <code>char</code>在这个序列中的指定位置。</td></tr><tr><td><code>void</code></td><td><code>getChars(int srcBegin, int srcEnd, char[] dst, int dstBegin)</code>字符从该序列复制到目标字符数组 <code>dst</code> 。</td></tr><tr><td><code>int</code></td><td><code>indexOf(String str)</code>返回指定子字符串第一次出现的字符串内的索引。</td></tr><tr><td><code>int</code></td><td><code>indexOf(String str, int fromIndex)</code>返回指定子串的第一次出现的字符串中的索引，从指定的索引开始。</td></tr><tr><td><code>StringBuilder</code></td><td><code>insert(int offset, xx)</code>将 xx参数的字符串表示插入到此序列中。offset 偏移量</td></tr><tr><td><code>int</code></td><td><code>lastIndexOf(String str)</code>返回指定子字符串最右边出现的字符串内的索引。</td></tr><tr><td><code>StringBuilder</code></td><td><code>replace(int start, int end, String str)</code>用指定的String中的字符替换此序列的子字符串中的 <code>String</code> 。</td></tr><tr><td><code>StringBuilder</code></td><td><code>reverse()</code>导致该字符序列被序列的相反代替。</td></tr><tr><td><code>void</code></td><td><code>setCharAt(int index, char ch)</code>指定索引处的字符设置为 <code>ch</code> 。</td></tr><tr><td><code>void</code></td><td><code>setLength(int newLength)</code>设置字符序列的长度。</td></tr><tr><td><code>CharSequence</code></td><td><code>subSequence(int start, int end)</code>返回一个新的字符序列，该序列是该序列的子序列。</td></tr><tr><td><code>String</code></td><td><code>substring(int start, int end)</code>返回一个新的 <code>String</code> ，其中包含此序列中当前包含的字符的子序列。</td></tr><tr><td><code>String</code></td><td><code>toString()</code>返回表示此顺序中的数据的字符串。</td></tr></tbody></table><h2 id="Array数组"><a href="#Array数组" class="headerlink" title="Array数组"></a>Array数组</h2><p><code>Array</code>类提供静态方法来动态创建和访问Java数组。</p><table><thead><tr><th>4</th><th><strong>public static void sort(Object[] a)</strong> （？？？有无此方法？）<br>对指定对象数组根据其元素的自然顺序进行升序排列。同样的方法适用于所有的其他基本数据类型（Byte，short，Int等）。</th></tr></thead><tbody><tr><td><code>static Object</code></td><td><code>get(Object array, int index)</code>返回指定数组对象中的索引组件的值。</td></tr><tr><td><code>static void</code></td><td><code>set(Object array, int index, Object value)</code>将指定数组对象的索引组件的值设置为指定的新值。</td></tr></tbody></table><h2 id="Arrays"><a href="#Arrays" class="headerlink" title="Arrays"></a>Arrays</h2><p>该类包含用于操作数组的各种方法（如排序和搜索）。</p><table><thead><tr><th><code>static &lt;T&gt; List&lt;T&gt;</code></th><th><code>asList(T... a)</code>返回由指定数组支持的固定大小的列表。</th></tr></thead><tbody><tr><td><code>static boolean</code></td><td><code>equals(xx, xx)</code>如果两个指定的xx数组彼此 <em>相等</em> ，则返回 <code>true</code> 。</td></tr><tr><td><code>static void</code></td><td><code>fill(xx, xxxx)</code>将指定的xxxx值分配给指定的xx数组的每个元素。</td></tr><tr><td><code>static void</code></td><td><code>sort(xx)</code>按照xx顺序排列指定的数组。xx：一些基本数据类型</td></tr></tbody></table><h2 id="Scanner"><a href="#Scanner" class="headerlink" title="Scanner"></a>Scanner</h2><table><thead><tr><th>String nextLine()</th><th>返回一行字符串</th></tr></thead><tbody><tr><td>next()</td><td>返回一字符串，以空格结束</td></tr><tr><td>int NextInt()</td><td>读下一个（行）整数</td></tr><tr><td>NextFloat()</td><td></td></tr><tr><td>NextDouble()</td><td></td></tr><tr><td>hasnext()</td><td>返回是否还有下一个</td></tr><tr><td>hasnextLine()</td><td>返回是否还有下一行</td></tr><tr><td>hasNextInt()</td><td></td></tr><tr><td>hasNextFloat()</td><td></td></tr><tr><td>hasNextDouble()</td><td></td></tr><tr><td><code>void</code></td><td><code>close()</code>关闭此扫描仪。</td></tr></tbody></table><h2 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h2><table><thead><tr><th><code>static int</code></th><th><code>abs(int a)</code>返回值为 <code>int</code>绝对值。</th></tr></thead><tbody><tr><td><code>static double</code></td><td><code>exp(double a)</code>返回欧拉的数字 <em>e</em>提高到一个 <code>double</code>价值。</td></tr><tr><td><code>static double</code></td><td><code>floor(double a)</code>返回小于或等于参数的最大（最接近正无穷大） <code>double</code>值，等于一个数学整数。</td></tr><tr><td><code>static int</code></td><td><code>max(int a, int b)</code>返回两个 <code>int</code>值中的较大值。</td></tr><tr><td><code>static int</code></td><td><code>min(int a, int b)</code>返回两个 <code>int</code>的较小值。</td></tr><tr><td><code>static double</code></td><td><code>pow(double a, double b)</code>将第一个参数的值返回到第二个参数的幂。</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2021/08/28/hello-world/"/>
    <url>/2021/08/28/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>roslaunch找不到包 详细 ros 工作空间 永久添加环境变量</title>
    <link href="/2021/05/27/roslaunch/"/>
    <url>/2021/05/27/roslaunch/</url>
    
    <content type="html"><![CDATA[<p>roslaunch一个包时报错:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">[aaa] is neither a launch file <span class="hljs-keyword">in</span> package [aaaa] nor is [aaaa] a launch file name<br>The traceback <span class="hljs-keyword">for</span> the exception was written to the <span class="hljs-built_in">log</span> file<br></code></pre></td></tr></table></figure><p>ubuntu16.04使用ros包时找不到,需要创建+编译工作空间,设置环境变量解决.</p><p>ros小白看了好多帖子都不可以 去B站上找了一个视频一试即成功,把它整理成文字版.如果还是不懂的话可以去看视频<br><a href="https://www.bilibili.com/video/BV1YK4y1P7jS?from=search&seid=685743644250064773">https://www.bilibili.com/video/BV1YK4y1P7jS?from=search&amp;seid=685743644250064773</a></p><h2 id="一-创建工作空间"><a href="#一-创建工作空间" class="headerlink" title="一.创建工作空间"></a>一.创建工作空间</h2><p>1.创建文件夹,这里可以是任意位置,也可以是任意名称</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">mkdir -p ~/xxx/src<br></code></pre></td></tr></table></figure><p>2.进入文件夹</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> ~/xxx/src<br></code></pre></td></tr></table></figure><p>3.将你的包放到src中,并初始化工作空间.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">catkin_init_workspace<br></code></pre></td></tr></table></figure><h2 id="二-编译工作空间"><a href="#二-编译工作空间" class="headerlink" title="二.编译工作空间"></a>二.编译工作空间</h2><p>1.回到工作空间路径下,从src返回工作空间,即到xxx目录下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span>..<br></code></pre></td></tr></table></figure><p>2.编译工作空间,编译过后就会多出两个文件夹,build和devel</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">catkin_make<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/202105272056222.png" alt="编译工作空间后"><br>编译过后xxx文件夹下如图所示,例此处 xxx 为 tuw_multi_robot.</p><h2 id="三-设置环境变量-告诉系统这是工作空间的一个路径-建议直接跳2永久添加进系统"><a href="#三-设置环境变量-告诉系统这是工作空间的一个路径-建议直接跳2永久添加进系统" class="headerlink" title="三.设置环境变量,告诉系统这是工作空间的一个路径,建议直接跳2永久添加进系统!!"></a>三.设置环境变量,告诉系统这是工作空间的一个路径,<strong>建议直接跳2永久添加进系统!!</strong></h2><p>1.添加环境变量,还是在上面的xxx文件夹下.(建议直接用2)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">source</span> devel/setup.bash<br></code></pre></td></tr></table></figure><p>查看添加是否成功,执行此命令后能看到xxx就是成功了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-variable">$ROS_PACKAGE_PATH</span><br></code></pre></td></tr></table></figure><p>此时,再roslaunch你的包就可以了.<br>不过!!!!当我们重新打开一个终端roslaunch的时候,还是找不到,原因是没有将路径全局地写进系统.</p><p>2.永久添加环境变量</p><p>2.1 写入.bashrc文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">gedit ~/.bashrc<br></code></pre></td></tr></table></figure><p>2.2 在.bashrc最下面加入环境变量,把xxx的文件路径加上devel/setup.bash,source进去.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">source</span> ......./xxx/devel/setup.bash<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210527211106879.png" alt="bashrc加入环境变量"><br>编辑好后点击save</p><p>2.3 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">source</span> devel/setup.bash<br></code></pre></td></tr></table></figure><p>此时roslaunch应该也可以了.</p>]]></content>
    
    
    <categories>
      
      <category>MARL</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>ubuntu16.04启动vrep V4.1.0、使用python API需要的文件</title>
    <link href="/2021/01/19/vrep/"/>
    <url>/2021/01/19/vrep/</url>
    
    <content type="html"><![CDATA[<h2 id="1-ubuntu16-04启动vrep-V4-1-0教育版方法（感觉它更名CoppeliaSim了）"><a href="#1-ubuntu16-04启动vrep-V4-1-0教育版方法（感觉它更名CoppeliaSim了）" class="headerlink" title="1.ubuntu16.04启动vrep V4.1.0教育版方法（感觉它更名CoppeliaSim了）"></a>1.ubuntu16.04启动vrep V4.1.0教育版方法（感觉它更名CoppeliaSim了）</h2><p>打开文件夹位置，输入：./coppeliaSim.sh</p><h2 id="2-要用vrep（coppeliaSim）python脚本的远程API，需要以下三项："><a href="#2-要用vrep（coppeliaSim）python脚本的远程API，需要以下三项：" class="headerlink" title="2.要用vrep（coppeliaSim）python脚本的远程API，需要以下三项："></a>2.要用vrep（coppeliaSim）python脚本的远程API，需要以下三项：</h2><ol><li>sim.py</li><li>simConst.py</li><li>remoteApi.dll, remoteApi.dylib or remoteApi.so (取决于你的操作系统)</li></ol><p>以上第1.2文件在CoppeliaSim的安装位置的：<em>programming/remoteApiBindings/python</em><br><img src="https://img-blog.csdnimg.cn/20210119162441475.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Zhbjk2MDkxOQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>第3在<em>programming/remoteApiBindings/lib/lib</em>中<br><img src="https://img-blog.csdnimg.cn/20210119162441412.png" alt="在这里插入图片描述"></p><p>CoppeliaSim远程API功能的前缀都是”simx”。</p><h3 id="附python-remote-API使用说明书原文："><a href="#附python-remote-API使用说明书原文：" class="headerlink" title="附python remote API使用说明书原文："></a>附python remote API使用说明书原文：</h3><p><img src="https://img-blog.csdnimg.cn/20210119162441569.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Zhbjk2MDkxOQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>参考：<br>官方说明书 <a href="https://www.coppeliarobotics.com/helpFiles/index.html">https://www.coppeliarobotics.com/helpFiles/index.html</a></p>]]></content>
    
    
    <categories>
      
      <category>MARL</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
